        -:    0:Source:flex.c
        -:    0:Graph:flex.gcno
        -:    0:Data:flex.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* flex - tool to generate fast lexical analyzers */
        -:    2:
        -:    3:/*-
        -:    4: * Copyright (c) 1990 The Regents of the University of California.
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This code is derived from software contributed to Berkeley by
        -:    8: * Vern Paxson.
        -:    9: *
        -:   10: * The United States Government has rights in this work pursuant
        -:   11: * to contract no. DE-AC03-76SF00098 between the United States
        -:   12: * Department of Energy and the University of California.
        -:   13: *
        -:   14: * Redistribution and use in source and binary forms are permitted provided
        -:   15: * that: (1) source distributions retain this entire copyright notice and
        -:   16: * comment, and (2) distributions including binaries display the following
        -:   17: * acknowledgement:  ``This product includes software developed by the
        -:   18: * University of California, Berkeley and its contributors'' in the
        -:   19: * documentation or other materials provided with the distribution and in
        -:   20: * all advertising materials mentioning features or use of this software.
        -:   21: * Neither the name of the University nor the names of its contributors may
        -:   22: * be used to endorse or promote products derived from this software without
        -:   23: * specific prior written permission.
        -:   24: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:   25: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:   26: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:   27: */
        -:   28:
        -:   29:#ifndef lint
        -:   30:char copyright[] =
        -:   31:"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
        -:   32: All rights reserved.\n";
        -:   33:#endif /* not lint */
        -:   34:
        -:   35:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $
        -:   36:*/
        -:   37:
        -:   38:#include "flexdef.h"
        -:   39:#include "version.h"
        -:   40:#include <ctype.h> 
        -:   41:#include "parse.h"
        -:   42:#include "FaultSeeds.h"
        -:   43:
        -:   44:static char flex_version[] = FLEX_VERSION;
        -:   45:
        -:   46:
        -:   47:/* declare functions that have forward references */
        -:   48:
        -:   49:void flexinit PROTO((int, char**));
        -:   50:void readin PROTO((void));
        -:   51:void set_up_initial_allocations PROTO((void));
        -:   52:
        -:   53:#ifdef NEED_ARGV_FIXUP
        -:   54:extern void argv_fixup PROTO((int *, char ***));
        -:   55:#endif
        -:   56:
        -:   57:
        -:   58:/* these globals are all defined and commented in flexdef.h */
        -:   59:int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
        -:   60:int interactive, caseins, lex_compat, do_yylineno, useecs, fulltbl, usemecs;
        -:   61:int fullspd, gen_line_dirs, performance_report, backing_up_report;
        -:   62:int C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap, csize;
        -:   63:int yymore_used, reject, real_reject, continued_action, in_rule;
        -:   64:int yymore_really_used, reject_really_used;
        -:   65:int datapos, dataline, linenum, out_linenum;
        -:   66:FILE *skelfile = NULL;
        -:   67:
        -:   68:/* ### add for testing ### */
        -:   69:FILE *err = NULL;
        -:   70:/* ####################### */
        -:   71:
        -:   72:int skel_ind = 0;
        -:   73:char *action_array;
        -:   74:int action_size, defs1_offset, prolog_offset, action_offset, action_index;
        -:   75:char *infilename = NULL, *outfilename = NULL;
        -:   76:int did_outfilename;
        -:   77:char *prefix, *yyclass;
        -:   78:int do_stdinit, use_stdout;
        -:   79:int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
        -:   80:int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
        -:   81:int current_mns, current_max_rules;
        -:   82:int num_rules, num_eof_rules, default_rule, lastnfa;
        -:   83:int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
        -:   84:int *accptnum, *assoc_rule, *state_type;
        -:   85:int *rule_type, *rule_linenum, *rule_useful;
        -:   86:int current_state_type;
        -:   87:int variable_trailing_context_rules;
        -:   88:int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
        -:   89:int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
        -:   90:int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
        -:   91:int tecbck[CSIZE + 1];
        -:   92:int lastsc, *scset, *scbol, *scxclu, *sceof;
        -:   93:int current_max_scs;
        -:   94:char **scname;
        -:   95:int current_max_dfa_size, current_max_xpairs;
        -:   96:int current_max_template_xpairs, current_max_dfas;
        -:   97:int lastdfa, *nxt, *chk, *tnxt;
        -:   98:int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
        -:   99:union dfaacc_union *dfaacc;
        -:  100:int *accsiz, *dhash, numas;
        -:  101:int numsnpairs, jambase, jamstate;
        -:  102:int lastccl, *cclmap, *ccllen, *cclng, cclreuse;
        -:  103:int current_maxccls, current_max_ccl_tbl_size;
        -:  104:Char *ccltbl;
        -:  105:char nmstr[MAXLINE];
        -:  106:int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
        -:  107:int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
        -:  108:int num_backing_up, bol_needed;
        -:  109:FILE *backing_up_file;
        -:  110:int end_of_buffer_state;
        -:  111:char **input_files;
        -:  112:int num_input_files;
        -:  113:
        -:  114:/* Make sure program_name is initialized so we don't crash if writing
        -:  115: * out an error message before getting the program name from argv[0].
        -:  116: */
        -:  117:char *program_name = "flex";
        -:  118:
        -:  119:#ifndef SHORT_FILE_NAMES
        -:  120:static char *outfile_template = "lex.%s.%s";
        -:  121:static char *backing_name = "lex.backup";
        -:  122:#else
        -:  123:static char *outfile_template = "lex%s.%s";
        -:  124:static char *backing_name = "lex.bck";
        -:  125:#endif
        -:  126:
        -:  127:#ifdef THINK_C
        -:  128:#include <console.h>
        -:  129:#endif
        -:  130:
        -:  131:#ifdef MS_DOS
        -:  132:extern unsigned _stklen = 16384;
        -:  133:#endif
        -:  134:
        -:  135:static char outfile_path[MAXLINE];
        -:  136:static int outfile_created = 0;
        -:  137:static char *skelname = NULL;
        -:  138:
        -:  139:
        1:  140:int main( argc, argv )
        -:  141:int argc;
        -:  142:char **argv;
        -:  143:	{
        -:  144:	int i;
        -:  145:
        -:  146:#ifdef THINK_C
        -:  147:	argc = ccommand( &argv );
        -:  148:#endif
        -:  149:#ifdef NEED_ARGV_FIXUP
        -:  150:	argv_fixup( &argc, &argv );
        -:  151:#endif
        -:  152:
        -:  153:/* ### add for testing ### */
        1:  154:        if(--argc >0){
        1:  155:                err = fopen( *++argv, "w" );
        1:  156:                --argv; ++argc;
        -:  157:        }
        -:  158:/* ####################### */
        -:  159:
        1:  160:	flexinit( argc, argv );
        -:  161:
        1:  162:	readin();
        -:  163:
        1:  164:	ntod();
        -:  165:
        8:  166:	for ( i = 1; i <= num_rules; ++i )
        7:  167:		if ( ! rule_useful[i] && i != default_rule )
    #####:  168:			line_warning( _( "rule cannot be matched" ),
    #####:  169:					rule_linenum[i] );
        -:  170:
        1:  171:	if ( spprdflt && ! reject && rule_useful[default_rule] )
    #####:  172:		line_warning(
        -:  173:			_( "-s option given but default rule can be matched" ),
    #####:  174:			rule_linenum[default_rule] );
        -:  175:
        -:  176:	/* Generate the C state transition tables from the DFA. */
        1:  177:	make_tables();
        -:  178:
        -:  179:	/* Note, flexend does not return.  It exits with its argument
        -:  180:	 * as status.
        -:  181:	 */
        1:  182:	flexend( 0 );
        -:  183:
    #####:  184:	return 0;	/* keep compilers/lint happy */
        -:  185:	}
        -:  186:
        -:  187:
        -:  188:/* check_options - check user-specified options */
        -:  189:
        1:  190:void check_options()
        -:  191:	{
        -:  192:	int i;
        -:  193:
        1:  194:	if ( lex_compat )
        -:  195:		{
    #####:  196:		if ( C_plus_plus )
    #####:  197:			flexerror( _( "Can't use -+ with -l option" ) );
        -:  198:
    #####:  199:		if ( fulltbl || fullspd )
    #####:  200:			flexerror( _( "Can't use -f or -F with -l option" ) );
        -:  201:
        -:  202:		/* Don't rely on detecting use of yymore() and REJECT,
        -:  203:		 * just assume they'll be used.
        -:  204:		 */
    #####:  205:		yymore_really_used = reject_really_used = true;
        -:  206:
    #####:  207:		yytext_is_array = true;
    #####:  208:		do_yylineno = true;
    #####:  209:		use_read = false;
        -:  210:		}
        -:  211:
        1:  212:	if ( do_yylineno )
        -:  213:		/* This should really be "maintain_backup_tables = true" */
    #####:  214:		reject_really_used = true;
        -:  215:
        1:  216:	if ( csize == unspecified )
        -:  217:		{
        1:  218:		if ( (fulltbl || fullspd) && ! useecs )
    #####:  219:			csize = DEFAULT_CSIZE;
        -:  220:		else
        1:  221:			csize = CSIZE;
        -:  222:		}
        -:  223:
        1:  224:	if ( interactive == unspecified )
        -:  225:		{
        1:  226:		if ( fulltbl || fullspd )
    #####:  227:			interactive = false;
        -:  228:		else
        1:  229:			interactive = true;
        -:  230:		}
        -:  231:
        1:  232:	if ( fulltbl || fullspd )
        -:  233:		{
    #####:  234:		if ( usemecs )
    #####:  235:			flexerror(
        -:  236:			_( "-Cf/-CF and -Cm don't make sense together" ) );
        -:  237:
    #####:  238:		if ( interactive )
    #####:  239:			flexerror( _( "-Cf/-CF and -I are incompatible" ) );
        -:  240:
    #####:  241:		if ( lex_compat )
    #####:  242:			flexerror(
        -:  243:		_( "-Cf/-CF are incompatible with lex-compatibility mode" ) );
        -:  244:
    #####:  245:		if ( do_yylineno )
    #####:  246:			flexerror(
        -:  247:			_( "-Cf/-CF and %option yylineno are incompatible" ) );
        -:  248:
    #####:  249:		if ( fulltbl && fullspd )
    #####:  250:			flexerror( _( "-Cf and -CF are mutually exclusive" ) );
        -:  251:		}
        -:  252:
        1:  253:	if ( C_plus_plus && fullspd )
    #####:  254:		flexerror( _( "Can't use -+ with -CF option" ) );
        -:  255:
        1:  256:	if ( C_plus_plus && yytext_is_array )
        -:  257:		{
    #####:  258:		warn( _( "%array incompatible with -+ option" ) );
    #####:  259:		yytext_is_array = false;
        -:  260:		}
        -:  261:
        -:  262:#ifndef F_B17
        1:  263:	if ( useecs )
        -:  264:#else
        -:  265:	if ( 0 &&  useecs )
        -:  266:#endif
        -:  267:		{ /* Set up doubly-linked equivalence classes. */
        -:  268:
        -:  269:		/* We loop all the way up to csize, since ecgroup[csize] is
        -:  270:		 * the position used for NUL characters.
        -:  271:		 */
        1:  272:		ecgroup[1] = NIL;
        -:  273:
      256:  274:		for ( i = 2; i <= csize; ++i )
        -:  275:			{
      255:  276:			ecgroup[i] = i - 1;
      255:  277:			nextecm[i - 1] = i;
        -:  278:			}
        -:  279:
        1:  280:		nextecm[csize] = NIL;
        -:  281:		}
        -:  282:
        -:  283:	else
        -:  284:		{
        -:  285:		/* Put everything in its own equivalence class. */
    #####:  286:		for ( i = 1; i <= csize; ++i )
        -:  287:			{
    #####:  288:			ecgroup[i] = i;
    #####:  289:			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
        -:  290:			}
        -:  291:		}
        -:  292:
        1:  293:	if ( ! use_stdout )
        -:  294:		{
        -:  295:		FILE *prev_stdout;
        -:  296:
        1:  297:		if ( ! did_outfilename )
        -:  298:			{
        -:  299:			char *suffix;
        -:  300:
        1:  301:			if ( C_plus_plus )
    #####:  302:				suffix = "cc";
        -:  303:			else
        1:  304:				suffix = "c";
        -:  305:
        1:  306:			sprintf( outfile_path, outfile_template,
        -:  307:				prefix, suffix );
        -:  308:
        1:  309:			outfilename = outfile_path;
        -:  310:			}
        -:  311:
        1:  312:		prev_stdout = freopen( outfilename, "w", stdout );
        -:  313:
        1:  314:		if ( prev_stdout == NULL )
    #####:  315:			lerrsf( _( "could not create %s" ), outfilename );
        -:  316:
        1:  317:		outfile_created = 1;
        -:  318:		}
        -:  319:
        1:  320:	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
    #####:  321:		lerrsf( _( "can't open skeleton file %s" ), skelname );
        -:  322:
        1:  323:	if ( strcmp( prefix, "yy" ) )
        -:  324:		{
        -:  325:#define GEN_PREFIX(name) out_str3( "#define yy%s %s%s\n", name, prefix, name )
    #####:  326:		if ( C_plus_plus )
    #####:  327:			GEN_PREFIX( "FlexLexer" );
        -:  328:		else
        -:  329:			{
    #####:  330:			GEN_PREFIX( "_create_buffer" );
    #####:  331:			GEN_PREFIX( "_delete_buffer" );
    #####:  332:			GEN_PREFIX( "_scan_buffer" );
    #####:  333:			GEN_PREFIX( "_scan_string" );
    #####:  334:			GEN_PREFIX( "_scan_bytes" );
    #####:  335:			GEN_PREFIX( "_flex_debug" );
    #####:  336:			GEN_PREFIX( "_init_buffer" );
    #####:  337:			GEN_PREFIX( "_flush_buffer" );
    #####:  338:			GEN_PREFIX( "_load_buffer_state" );
    #####:  339:			GEN_PREFIX( "_switch_to_buffer" );
    #####:  340:			GEN_PREFIX( "in" );
    #####:  341:			GEN_PREFIX( "leng" );
    #####:  342:			GEN_PREFIX( "lex" );
    #####:  343:			GEN_PREFIX( "out" );
    #####:  344:			GEN_PREFIX( "restart" );
    #####:  345:			GEN_PREFIX( "text" );
        -:  346:
    #####:  347:			if ( do_yylineno )
    #####:  348:				GEN_PREFIX( "lineno" );
        -:  349:			}
        -:  350:
    #####:  351:		if ( do_yywrap )
    #####:  352:			GEN_PREFIX( "wrap" );
        -:  353:
    #####:  354:		outn( "" );
        -:  355:		}
        -:  356:
        1:  357:	if ( did_outfilename )
    #####:  358:		line_directive_out( stdout, 0 );
        -:  359:
        1:  360:	skelout();
        1:  361:	}
        -:  362:
        -:  363:
        -:  364:/* flexend - terminate flex
        -:  365: *
        -:  366: * note
        -:  367: *    This routine does not return.
        -:  368: */
        -:  369:
        1:  370:void flexend( exit_status )
        -:  371:int exit_status;
        -:  372:
        -:  373:	{
        -:  374:	int tblsiz;
        -:  375:	int unlink();
        -:  376:
        1:  377:	if ( skelfile != NULL )
        -:  378:		{
    #####:  379:		if ( ferror( skelfile ) )
    #####:  380:			lerrsf( _( "input error reading skeleton file %s" ),
        -:  381:				skelname );
        -:  382:
    #####:  383:		else if ( fclose( skelfile ) )
    #####:  384:			lerrsf( _( "error closing skeleton file %s" ),
        -:  385:				skelname );
        -:  386:		}
        -:  387:
        1:  388:	if ( exit_status != 0 && outfile_created )
        -:  389:		{
    #####:  390:		if ( ferror( stdout ) )
    #####:  391:			lerrsf( _( "error writing output file %s" ),
        -:  392:				outfilename );
        -:  393:
    #####:  394:		else if ( fclose( stdout ) )
    #####:  395:			lerrsf( _( "error closing output file %s" ),
        -:  396:				outfilename );
        -:  397:
    #####:  398:		else if ( unlink( outfilename ) )
    #####:  399:			lerrsf( _( "error deleting output file %s" ),
        -:  400:				outfilename );
        -:  401:		}
        -:  402:
        1:  403:	if ( backing_up_report && backing_up_file )
        -:  404:		{
    #####:  405:		if ( num_backing_up == 0 )
    #####:  406:			fprintf( backing_up_file, _( "No backing up.\n" ) );
    #####:  407:		else if ( fullspd || fulltbl )
    #####:  408:			fprintf( backing_up_file,
        -:  409:				_( "%d backing up (non-accepting) states.\n" ),
        -:  410:				num_backing_up );
        -:  411:		else
    #####:  412:			fprintf( backing_up_file,
        -:  413:				_( "Compressed tables always back up.\n" ) );
        -:  414:
    #####:  415:		if ( ferror( backing_up_file ) )
    #####:  416:			lerrsf( _( "error writing backup file %s" ),
        -:  417:				backing_name );
        -:  418:
    #####:  419:		else if ( fclose( backing_up_file ) )
    #####:  420:			lerrsf( _( "error closing backup file %s" ),
        -:  421:				backing_name );
        -:  422:		}
        -:  423:
        1:  424:	if ( printstats )
        -:  425:		{
    #####:  426:		fprintf( err, _( "%s version %s usage statistics:\n" ),
        -:  427:			program_name, flex_version );
        -:  428:
    #####:  429:		fprintf( err, _( "  scanner options: -" ) );
        -:  430:
    #####:  431:		if ( C_plus_plus )
    #####:  432:			putc( '+', err );
    #####:  433:		if ( backing_up_report )
    #####:  434:			putc( 'b', err );
    #####:  435:		if ( ddebug )
    #####:  436:			putc( 'd', err );
    #####:  437:		if ( caseins )
    #####:  438:			putc( 'i', err );
    #####:  439:		if ( lex_compat )
    #####:  440:			putc( 'l', err );
    #####:  441:		if ( performance_report > 0 )
    #####:  442:			putc( 'p', err );
    #####:  443:		if ( performance_report > 1 )
    #####:  444:			putc( 'p', err );
    #####:  445:		if ( spprdflt )
    #####:  446:			putc( 's', err );
    #####:  447:		if ( use_stdout )
    #####:  448:			putc( 't', err );
    #####:  449:		if ( printstats )
    #####:  450:			putc( 'v', err );	/* always true! */
    #####:  451:		if ( nowarn )
    #####:  452:			putc( 'w', err );
    #####:  453:		if ( interactive == false )
    #####:  454:			putc( 'B', err );
    #####:  455:		if ( interactive == true )
    #####:  456:			putc( 'I', err );
    #####:  457:		if ( ! gen_line_dirs )
    #####:  458:			putc( 'L', err );
    #####:  459:		if ( trace )
    #####:  460:			putc( 'T', err );
        -:  461:
    #####:  462:		if ( csize == unspecified )
        -:  463:			/* We encountered an error fairly early on, so csize
        -:  464:			 * never got specified.  Define it now, to prevent
        -:  465:			 * bogus table sizes being written out below.
        -:  466:			 */
    #####:  467:			csize = 256;
        -:  468:
    #####:  469:		if ( csize == 128 )
    #####:  470:			putc( '7', err );
        -:  471:		else
    #####:  472:			putc( '8', err );
        -:  473:
    #####:  474:		fprintf( err, " -C" );
        -:  475:
    #####:  476:		if ( long_align )
    #####:  477:			putc( 'a', err );
    #####:  478:		if ( fulltbl )
    #####:  479:			putc( 'f', err );
    #####:  480:		if ( fullspd )
    #####:  481:			putc( 'F', err );
    #####:  482:		if ( useecs )
    #####:  483:			putc( 'e', err );
    #####:  484:		if ( usemecs )
    #####:  485:			putc( 'm', err );
    #####:  486:		if ( use_read )
    #####:  487:			putc( 'r', err );
        -:  488:
    #####:  489:		if ( did_outfilename )
    #####:  490:			fprintf( err, " -o%s", outfilename );
        -:  491:
    #####:  492:		if ( skelname )
    #####:  493:			fprintf( err, " -S%s", skelname );
        -:  494:
    #####:  495:		if ( strcmp( prefix, "yy" ) )
    #####:  496:			fprintf( err, " -P%s", prefix );
        -:  497:
    #####:  498:		putc( '\n', err );
        -:  499:
    #####:  500:		fprintf( err, _( "  %d/%d NFA states\n" ),
        -:  501:			lastnfa, current_mns );
    #####:  502:		fprintf( err, _( "  %d/%d DFA states (%d words)\n" ),
        -:  503:			lastdfa, current_max_dfas, totnst );
    #####:  504:		fprintf( err, _( "  %d rules\n" ),
    #####:  505:		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );
        -:  506:
    #####:  507:		if ( num_backing_up == 0 )
    #####:  508:			fprintf( err, _( "  No backing up\n" ) );
    #####:  509:		else if ( fullspd || fulltbl )
    #####:  510:			fprintf( err,
        -:  511:			_( "  %d backing-up (non-accepting) states\n" ),
        -:  512:				num_backing_up );
        -:  513:		else
    #####:  514:			fprintf( err,
        -:  515:				_( "  Compressed tables always back-up\n" ) );
        -:  516:
    #####:  517:		if ( bol_needed )
    #####:  518:			fprintf( err,
        -:  519:				_( "  Beginning-of-line patterns used\n" ) );
        -:  520:
    #####:  521:		fprintf( err, _( "  %d/%d start conditions\n" ), lastsc,
        -:  522:			current_max_scs );
    #####:  523:		fprintf( err,
        -:  524:			_( "  %d epsilon states, %d double epsilon states\n" ),
        -:  525:			numeps, eps2 );
        -:  526:
    #####:  527:		if ( lastccl == 0 )
    #####:  528:			fprintf( err, _( "  no character classes\n" ) );
        -:  529:		else
    #####:  530:			fprintf( err,
        -:  531:_( "  %d/%d character classes needed %d/%d words of storage, %d reused\n" ),
        -:  532:				lastccl, current_maxccls,
    #####:  533:				cclmap[lastccl] + ccllen[lastccl],
        -:  534:				current_max_ccl_tbl_size, cclreuse );
        -:  535:
    #####:  536:		fprintf( err, _( "  %d state/nextstate pairs created\n" ),
        -:  537:			numsnpairs );
    #####:  538:		fprintf( err, _( "  %d/%d unique/duplicate transitions\n" ),
        -:  539:			numuniq, numdup );
        -:  540:
    #####:  541:		if ( fulltbl )
        -:  542:			{
    #####:  543:			tblsiz = lastdfa * numecs;
    #####:  544:			fprintf( err, _( "  %d table entries\n" ), tblsiz );
        -:  545:			}
        -:  546:
        -:  547:		else
        -:  548:			{
    #####:  549:			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
        -:  550:
    #####:  551:			fprintf( err,
        -:  552:				_( "  %d/%d base-def entries created\n" ),
        -:  553:				lastdfa + numtemps, current_max_dfas );
    #####:  554:			fprintf( err,
        -:  555:			_( "  %d/%d (peak %d) nxt-chk entries created\n" ),
        -:  556:				tblend, current_max_xpairs, peakpairs );
    #####:  557:			fprintf( err,
        -:  558:		_( "  %d/%d (peak %d) template nxt-chk entries created\n" ),
        -:  559:				numtemps * nummecs,
        -:  560:				current_max_template_xpairs,
        -:  561:				numtemps * numecs );
    #####:  562:			fprintf( err, _( "  %d empty table entries\n" ),
        -:  563:				nummt );
    #####:  564:			fprintf( err, _( "  %d protos created\n" ),
        -:  565:				numprots );
    #####:  566:			fprintf( err,
        -:  567:				_( "  %d templates created, %d uses\n" ),
        -:  568:				numtemps, tmpuses );
        -:  569:			}
        -:  570:
    #####:  571:		if ( useecs )
        -:  572:			{
    #####:  573:			tblsiz = tblsiz + csize;
    #####:  574:			fprintf( err,
        -:  575:				_( "  %d/%d equivalence classes created\n" ),
        -:  576:				numecs, csize );
        -:  577:			}
        -:  578:
    #####:  579:		if ( usemecs )
        -:  580:			{
    #####:  581:			tblsiz = tblsiz + numecs;
    #####:  582:			fprintf( err,
        -:  583:			_( "  %d/%d meta-equivalence classes created\n" ),
        -:  584:				nummecs, csize );
        -:  585:			}
        -:  586:
    #####:  587:		fprintf( err,
        -:  588:		_( "  %d (%d saved) hash collisions, %d DFAs equal\n" ),
        -:  589:			hshcol, hshsave, dfaeql );
    #####:  590:		fprintf( err, _( "  %d sets of reallocations needed\n" ),
        -:  591:			num_reallocs );
    #####:  592:		fprintf( err, _( "  %d total table entries needed\n" ),
        -:  593:			tblsiz );
        -:  594:		}
        -:  595:
        1:  596:	exit( exit_status );
        -:  597:	}
        -:  598:
        -:  599:
        -:  600:/* flexinit - initialize flex */
        -:  601:
        1:  602:void flexinit( argc, argv )
        -:  603:int argc;
        -:  604:char **argv;
        -:  605:	{
        -:  606:	int i, sawcmpflag;
        -:  607:	char *arg;
        -:  608:
        1:  609:	printstats = syntaxerror = trace = spprdflt = caseins = false;
        1:  610:	lex_compat = C_plus_plus = backing_up_report = ddebug = fulltbl = false;
        1:  611:	fullspd = long_align = nowarn = yymore_used = continued_action = false;
        1:  612:	do_yylineno = yytext_is_array = in_rule = reject = do_stdinit = false;
        1:  613:	yymore_really_used = reject_really_used = unspecified;
        1:  614:	interactive = csize = unspecified;
        1:  615:	do_yywrap = gen_line_dirs = usemecs = useecs = true;
        1:  616:	performance_report = 0;
        1:  617:	did_outfilename = 0;
        1:  618:	prefix = "yy";
        1:  619:	yyclass = 0;
        1:  620:	use_read = use_stdout = false;
        -:  621:
        1:  622:	sawcmpflag = false;
        -:  623:
        -:  624:	/* Initialize dynamic array for holding the rule actions. */
        1:  625:	action_size = 2048;	/* default size of action array in bytes */
        1:  626:	action_array = allocate_character_array( action_size );
        1:  627:	defs1_offset = prolog_offset = action_offset = action_index = 0;
        1:  628:	action_array[0] = '\0';
        -:  629:
        -:  630:/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */
        -:  631:/*	program_name = argv[0];  */
        -:  632:/* Added by Amit Goel on 5th September 2001 */
        1:  633:        program_name = "Executable";
        -:  634:
        2:  635:	if ( program_name[0] != '\0' &&
        1:  636:	     program_name[strlen( program_name ) - 1] == '+' )
    #####:  637:		C_plus_plus = true;
        -:  638:
        -:  639:/* ### add for testing ### */
        1:  640:        ++argv;--argc;
        -:  641:/* ####################### */
        -:  642:
        -:  643:	/* read flags */
        3:  644:	for ( --argc, ++argv; argc ; --argc, ++argv )
        -:  645:		{
        3:  646:		arg = argv[0];
        -:  647:
        3:  648:		if ( arg[0] != '-' || arg[1] == '\0' )
        -:  649:			break;
        -:  650:
        2:  651:		if ( arg[1] == '-' )
        -:  652:			{ /* --option */
    #####:  653:			if ( ! strcmp( arg, "--help" ) )
    #####:  654:				arg = "-h";
        -:  655:
    #####:  656:			else if ( ! strcmp( arg, "--version" ) )
    #####:  657:				arg = "-V";
        -:  658:
    #####:  659:			else if ( ! strcmp( arg, "--" ) )
        -:  660:				{ /* end of options */
    #####:  661:				--argc;
    #####:  662:				++argv;
    #####:  663:				break;
        -:  664:				}
        -:  665:			}
        -:  666:
        3:  667:		for ( i = 1; arg[i] != '\0'; ++i )
        2:  668:			switch ( arg[i] )
        -:  669:				{
        -:  670:				case '+':
    #####:  671:					C_plus_plus = true;
    #####:  672:					break;
        -:  673:
        -:  674:				case 'B':
    #####:  675:					interactive = false;
    #####:  676:					break;
        -:  677:
        -:  678:				case 'b':
    #####:  679:					backing_up_report = true;
    #####:  680:					break;
        -:  681:
        -:  682:				case 'c':
    #####:  683:					break;
        -:  684:
        -:  685:				case 'C':
        1:  686:					if ( i != 1 )
    #####:  687:						flexerror(
        -:  688:				_( "-C flag must be given separately" ) );
        -:  689:
        1:  690:					if ( ! sawcmpflag )
        -:  691:						{
        1:  692:						useecs = false;
        1:  693:						usemecs = false;
        1:  694:						fulltbl = false;
        1:  695:						sawcmpflag = true;
        -:  696:						}
        -:  697:
        5:  698:					for ( ++i; arg[i] != '\0'; ++i )
        4:  699:						switch ( arg[i] )
        -:  700:							{
        -:  701:							case 'a':
        1:  702:								long_align =
        -:  703:									true;
        1:  704:								break;
        -:  705:
        -:  706:							case 'e':
        1:  707:								useecs = true;
        1:  708:								break;
        -:  709:
        -:  710:							case 'F':
    #####:  711:								fullspd = true;
    #####:  712:								break;
        -:  713:
        -:  714:							case 'f':
    #####:  715:								fulltbl = true;
    #####:  716:								break;
        -:  717:
        -:  718:							case 'm':
        1:  719:								usemecs = true;
        1:  720:								break;
        -:  721:
        -:  722:							case 'r':
        1:  723:								use_read = true;
        1:  724:								break;
        -:  725:
        -:  726:							default:
    #####:  727:								lerrif(
        -:  728:						_( "unknown -C option '%c'" ),
    #####:  729:								(int) arg[i] );
    #####:  730:								break;
        -:  731:							}
        -:  732:
        1:  733:					goto get_next_arg;
        -:  734:
        -:  735:				case 'd':
        1:  736:					ddebug = true;
        1:  737:					break;
        -:  738:
        -:  739:				case 'f':
    #####:  740:					useecs = usemecs = false;
    #####:  741:					use_read = fulltbl = true;
    #####:  742:					break;
        -:  743:
        -:  744:				case 'F':
    #####:  745:					useecs = usemecs = false;
    #####:  746:					use_read = fullspd = true;
    #####:  747:					break;
        -:  748:
        -:  749:				case '?':
        -:  750:				case 'h':
    #####:  751:					usage();
    #####:  752:					exit( 0 );
        -:  753:
        -:  754:				case 'I':
    #####:  755:					interactive = true;
    #####:  756:					break;
        -:  757:
        -:  758:				case 'i':
    #####:  759:					caseins = true;
    #####:  760:					break;
        -:  761:
        -:  762:				case 'l':
    #####:  763:					lex_compat = true;
    #####:  764:					break;
        -:  765:
        -:  766:				case 'L':
    #####:  767:					gen_line_dirs = false;
    #####:  768:					break;
        -:  769:
        -:  770:				case 'n':
        -:  771:					/* Stupid do-nothing deprecated
        -:  772:					 * option.
        -:  773:					 */
    #####:  774:					break;
        -:  775:
        -:  776:				case 'o':
    #####:  777:					if ( i != 1 )
    #####:  778:						flexerror(
        -:  779:				_( "-o flag must be given separately" ) );
        -:  780:
    #####:  781:					outfilename = arg + i + 1;
    #####:  782:					did_outfilename = 1;
    #####:  783:					goto get_next_arg;
        -:  784:
        -:  785:				case 'P':
    #####:  786:					if ( i != 1 )
    #####:  787:						flexerror(
        -:  788:				_( "-P flag must be given separately" ) );
        -:  789:
    #####:  790:					prefix = arg + i + 1;
    #####:  791:					goto get_next_arg;
        -:  792:
        -:  793:				case 'p':
    #####:  794:					++performance_report;
    #####:  795:					break;
        -:  796:
        -:  797:				case 'S':
    #####:  798:					if ( i != 1 )
    #####:  799:						flexerror(
        -:  800:				_( "-S flag must be given separately" ) );
        -:  801:
    #####:  802:					skelname = arg + i + 1;
    #####:  803:					goto get_next_arg;
        -:  804:
        -:  805:				case 's':
    #####:  806:					spprdflt = true;
    #####:  807:					break;
        -:  808:
        -:  809:				case 't':
    #####:  810:					use_stdout = true;
    #####:  811:					break;
        -:  812:
        -:  813:				case 'T':
    #####:  814:					trace = true;
    #####:  815:					break;
        -:  816:
        -:  817:				case 'v':
    #####:  818:					printstats = true;
    #####:  819:					break;
        -:  820:
        -:  821:				case 'V':
    #####:  822:					printf( _( "%s version %s\n" ),
        -:  823:						program_name, flex_version );
    #####:  824:					exit( 0 );
        -:  825:
        -:  826:				case 'w':
    #####:  827:					nowarn = true;
    #####:  828:					break;
        -:  829:
        -:  830:				case '7':
    #####:  831:					csize = 128;
    #####:  832:					break;
        -:  833:
        -:  834:				case '8':
    #####:  835:					csize = CSIZE;
    #####:  836:					break;
        -:  837:
        -:  838:				default:
    #####:  839:					fprintf( err,
        -:  840:		_( "%s: unknown flag '%c'.  For usage, try\n\t%s --help\n" ),
    #####:  841:						program_name, (int) arg[i],
        -:  842:						program_name );
    #####:  843:					exit( 1 );
        -:  844:				}
        -:  845:
        -:  846:		/* Used by -C, -S, -o, and -P flags in lieu of a "continue 2"
        -:  847:		 * control.
        -:  848:		 */
        -:  849:		get_next_arg: ;
        -:  850:		}
        -:  851:
        1:  852:	num_input_files = argc;
        1:  853:	input_files = argv;
        1:  854:	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
        -:  855:
        1:  856:	lastccl = lastsc = lastdfa = lastnfa = 0;
        1:  857:	num_rules = num_eof_rules = default_rule = 0;
        1:  858:	numas = numsnpairs = tmpuses = 0;
        1:  859:	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
        1:  860:	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
        1:  861:	num_backing_up = onesp = numprots = 0;
        1:  862:	variable_trailing_context_rules = bol_needed = false;
        -:  863:
        1:  864:	out_linenum = linenum = sectnum = 1;
        1:  865:	firstprot = NIL;
        -:  866:
        -:  867:	/* Used in mkprot() so that the first proto goes in slot 1
        -:  868:	 * of the proto queue.
        -:  869:	 */
        1:  870:	lastprot = 1;
        -:  871:
        1:  872:	set_up_initial_allocations();
        1:  873:	}
        -:  874:
        -:  875:
        -:  876:/* readin - read in the rules section of the input file(s) */
        -:  877:
        1:  878:void readin()
        -:  879:	{
        -:  880:	static char yy_stdinit[] = "FILE *yyin = stdin, *yyout = stdout;";
        -:  881:	static char yy_nostdinit[] =
        -:  882:		"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;";
        -:  883:
        1:  884:	line_directive_out( (FILE *) 0, 1 );
        -:  885:
        1:  886:	if ( yyparse() )
        -:  887:		{
    #####:  888:		pinpoint_message( _( "fatal parse error" ) );
    #####:  889:		flexend( 1 );
        -:  890:		}
        -:  891:
        1:  892:	if ( syntaxerror )
    #####:  893:		flexend( 1 );
        -:  894:
        1:  895:	if ( backing_up_report )
        -:  896:		{
    #####:  897:		backing_up_file = fopen( backing_name, "w" );
    #####:  898:		if ( backing_up_file == NULL )
    #####:  899:			lerrsf(
        -:  900:			_( "could not create backing-up info file %s" ),
        -:  901:				backing_name );
        -:  902:		}
        -:  903:
        -:  904:	else
        1:  905:		backing_up_file = NULL;
        -:  906:
        1:  907:	if ( yymore_really_used == true )
    #####:  908:		yymore_used = true;
        1:  909:	else if ( yymore_really_used == false )
    #####:  910:		yymore_used = false;
        -:  911:
        1:  912:	if ( reject_really_used == true )
    #####:  913:		reject = true;
        1:  914:	else if ( reject_really_used == false )
    #####:  915:		reject = false;
        -:  916:
        1:  917:	if ( performance_report > 0 )
        -:  918:		{
    #####:  919:		if ( lex_compat )
        -:  920:			{
    #####:  921:			fprintf( err,
        -:  922:_( "-l AT&T lex compatibility option entails a large performance penalty\n" ) );
    #####:  923:			fprintf( err,
        -:  924:_( " and may be the actual source of other reported performance penalties\n" ) );
        -:  925:			}
        -:  926:
    #####:  927:		else if ( do_yylineno )
        -:  928:			{
    #####:  929:			fprintf( err,
        -:  930:	_( "%%option yylineno entails a large performance penalty\n" ) );
        -:  931:			}
        -:  932:
    #####:  933:		if ( performance_report > 1 )
        -:  934:			{
    #####:  935:			if ( interactive )
    #####:  936:				fprintf( err,
        -:  937:	_( "-I (interactive) entails a minor performance penalty\n" ) );
        -:  938:
    #####:  939:			if ( yymore_used )
    #####:  940:				fprintf( err,
        -:  941:		_( "yymore() entails a minor performance penalty\n" ) );
        -:  942:			}
        -:  943:
    #####:  944:		if ( reject )
    #####:  945:			fprintf( err,
        -:  946:			_( "REJECT entails a large performance penalty\n" ) );
        -:  947:
    #####:  948:		if ( variable_trailing_context_rules )
    #####:  949:			fprintf( err,
        -:  950:_( "Variable trailing context rules entail a large performance penalty\n" ) );
        -:  951:		}
        -:  952:
        1:  953:	if ( reject )
    #####:  954:		real_reject = true;
        -:  955:
        -:  956:#ifndef F_B16
        1:  957:	if ( variable_trailing_context_rules )
        -:  958:#else
        -:  959:	if  (!  variable_trailing_context_rules )
        -:  960:#endif
    #####:  961:		reject = true;
        -:  962:
        1:  963:	if ( (fulltbl || fullspd) && reject )
        -:  964:		{
    #####:  965:		if ( real_reject )
    #####:  966:			flexerror(
        -:  967:				_( "REJECT cannot be used with -f or -F" ) );
    #####:  968:		else if ( do_yylineno )
    #####:  969:			flexerror(
        -:  970:			_( "%option yylineno cannot be used with -f or -F" ) );
        -:  971:		else
    #####:  972:			flexerror(
        -:  973:	_( "variable trailing context rules cannot be used with -f or -F" ) );
        -:  974:		}
        -:  975:
        1:  976:	if ( reject )
    #####:  977:		outn( "\n#define YY_USES_REJECT" );
        -:  978:
        1:  979:	if ( ! do_yywrap )
        -:  980:		{
    #####:  981:		outn( "\n#define yywrap() 1" );
    #####:  982:		outn( "#define YY_SKIP_YYWRAP" );
        -:  983:		}
        -:  984:
        1:  985:	if ( ddebug )
        1:  986:		outn( "\n#define FLEX_DEBUG" );
        -:  987:
        1:  988:	if ( csize == 256 )
        1:  989:		outn( "typedef unsigned char YY_CHAR;" );
        -:  990:	else
    #####:  991:		outn( "typedef char YY_CHAR;" );
        -:  992:
        1:  993:	if ( C_plus_plus )
        -:  994:		{
    #####:  995:		outn( "#define yytext_ptr yytext" );
        -:  996:
    #####:  997:		if ( interactive )
    #####:  998:			outn( "#define YY_INTERACTIVE" );
        -:  999:		}
        -: 1000:
        -: 1001:	else
        -: 1002:		{
        1: 1003:		if ( do_stdinit )
        -: 1004:			{
    #####: 1005:			outn( "#ifdef VMS" );
    #####: 1006:			outn( "#ifndef __VMS_POSIX" );
    #####: 1007:			outn( yy_nostdinit );
    #####: 1008:			outn( "#else" );
    #####: 1009:			outn( yy_stdinit );
    #####: 1010:			outn( "#endif" );
    #####: 1011:			outn( "#else" );
    #####: 1012:			outn( yy_stdinit );
    #####: 1013:			outn( "#endif" );
        -: 1014:			}
        -: 1015:
        -: 1016:		else
        1: 1017:			outn( yy_nostdinit );
        -: 1018:		}
        -: 1019:
        1: 1020:	if ( fullspd )
        -: 1021:#ifndef F_B13
    #####: 1022:		outn( "typedef yyconst struct yy_trans_info *yy_state_type;" );
        -: 1023:#else
        -: 1024:		outn (!  "typedef yyconst struct yy_trans_info *yy_state_type;" );
        -: 1025:#endif
        1: 1026:	else if ( ! C_plus_plus )
        1: 1027:		outn( "typedef int yy_state_type;" );
        -: 1028:
        1: 1029:	if ( ddebug )
        1: 1030:		outn( "\n#define FLEX_DEBUG" );
        -: 1031:
        1: 1032:	if ( lex_compat )
    #####: 1033:		outn( "#define YY_FLEX_LEX_COMPAT" );
        -: 1034:
        1: 1035:	if ( do_yylineno && ! C_plus_plus )
        -: 1036:		{
        -: 1037:#ifndef F_A16
    #####: 1038:		outn( "extern int yylineno;" );
        -: 1039:#else
        -: 1040:		outn( "\0extern int yylineno;" );
        -: 1041:#endif
    #####: 1042:		outn( "int yylineno = 1;" );
        -: 1043:		}
        -: 1044:
        1: 1045:	if ( C_plus_plus )
        -: 1046:		{
    #####: 1047:		outn( "\n#include <FlexLexer.h>" );
        -: 1048:
    #####: 1049:		if ( yyclass )
        -: 1050:			{
    #####: 1051:			outn( "int yyFlexLexer::yylex()" );
    #####: 1052:			outn( "\t{" );
    #####: 1053:			outn(
        -: 1054:"\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );" );
    #####: 1055:			outn( "\treturn 0;" );
    #####: 1056:			outn( "\t}" );
        -: 1057:	
    #####: 1058:			out_str( "\n#define YY_DECL int %s::yylex()\n",
        -: 1059:				yyclass );
        -: 1060:			}
        -: 1061:		}
        -: 1062:
        -: 1063:	else
        -: 1064:		{
        1: 1065:		if ( yytext_is_array )
    #####: 1066:			outn( "extern char yytext[];\n" );
        -: 1067:
        -: 1068:		else
        -: 1069:			{
        -: 1070:#ifndef F_A14
        1: 1071:			outn( "extern char *yytext;" );
        -: 1072:#else
        -: 1073:			outn( "\0extern char *yytext;" );
        -: 1074:#endif
        1: 1075:			outn( "#define yytext_ptr yytext" );
        -: 1076:			}
        -: 1077:
        1: 1078:		if ( yyclass )
    #####: 1079:			flexerror(
        -: 1080:		_( "%option yyclass only meaningful for C++ scanners" ) );
        -: 1081:		}
        -: 1082:
        -: 1083:#ifndef F_B23
        1: 1084:	if ( useecs )
        -: 1085:#else
        -: 1086:	if ( ~  useecs )
        -: 1087:#endif
        1: 1088:		numecs = cre8ecs( nextecm, ecgroup, csize );
        -: 1089:	else
    #####: 1090:		numecs = csize;
        -: 1091:
        -: 1092:	/* Now map the equivalence class for NUL to its expected place. */
        1: 1093:	ecgroup[0] = ecgroup[csize];
        1: 1094:	NUL_ec = ABS( ecgroup[0] );
        -: 1095:
        1: 1096:	if ( useecs )
        1: 1097:		ccl2ecl();
        1: 1098:	}
        -: 1099:
        -: 1100:
        -: 1101:/* set_up_initial_allocations - allocate memory for internal tables */
        -: 1102:
        1: 1103:void set_up_initial_allocations()
        -: 1104:	{
        1: 1105:	current_mns = INITIAL_MNS;
        1: 1106:	firstst = allocate_integer_array( current_mns );
        1: 1107:	lastst = allocate_integer_array( current_mns );
        1: 1108:	finalst = allocate_integer_array( current_mns );
        1: 1109:	transchar = allocate_integer_array( current_mns );
        1: 1110:	trans1 = allocate_integer_array( current_mns );
        1: 1111:	trans2 = allocate_integer_array( current_mns );
        1: 1112:	accptnum = allocate_integer_array( current_mns );
        1: 1113:	assoc_rule = allocate_integer_array( current_mns );
        1: 1114:	state_type = allocate_integer_array( current_mns );
        -: 1115:
        1: 1116:	current_max_rules = INITIAL_MAX_RULES;
        1: 1117:	rule_type = allocate_integer_array( current_max_rules );
        1: 1118:	rule_linenum = allocate_integer_array( current_max_rules );
        1: 1119:	rule_useful = allocate_integer_array( current_max_rules );
        -: 1120:
        1: 1121:	current_max_scs = INITIAL_MAX_SCS;
        1: 1122:	scset = allocate_integer_array( current_max_scs );
        1: 1123:	scbol = allocate_integer_array( current_max_scs );
        1: 1124:	scxclu = allocate_integer_array( current_max_scs );
        1: 1125:	sceof = allocate_integer_array( current_max_scs );
        1: 1126:	scname = allocate_char_ptr_array( current_max_scs );
        -: 1127:
        1: 1128:	current_maxccls = INITIAL_MAX_CCLS;
        1: 1129:	cclmap = allocate_integer_array( current_maxccls );
        1: 1130:	ccllen = allocate_integer_array( current_maxccls );
        1: 1131:	cclng = allocate_integer_array( current_maxccls );
        -: 1132:
        1: 1133:	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
        1: 1134:	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
        -: 1135:
        1: 1136:	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
        -: 1137:
        1: 1138:	current_max_xpairs = INITIAL_MAX_XPAIRS;
        1: 1139:	nxt = allocate_integer_array( current_max_xpairs );
        1: 1140:	chk = allocate_integer_array( current_max_xpairs );
        -: 1141:
        1: 1142:	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
        1: 1143:	tnxt = allocate_integer_array( current_max_template_xpairs );
        -: 1144:
        1: 1145:	current_max_dfas = INITIAL_MAX_DFAS;
        1: 1146:	base = allocate_integer_array( current_max_dfas );
        1: 1147:	def = allocate_integer_array( current_max_dfas );
        1: 1148:	dfasiz = allocate_integer_array( current_max_dfas );
        1: 1149:	accsiz = allocate_integer_array( current_max_dfas );
        1: 1150:	dhash = allocate_integer_array( current_max_dfas );
        1: 1151:	dss = allocate_int_ptr_array( current_max_dfas );
        1: 1152:	dfaacc = allocate_dfaacc_union( current_max_dfas );
        -: 1153:
        -: 1154:#ifndef F_B25
        1: 1155:	nultrans = (int *) 0;
        -: 1156:#else
        -: 1157:	nultrans = ! (int *) 0;
        -: 1158:#endif
        1: 1159:	}
        -: 1160:
        -: 1161:
    #####: 1162:void usage()
        -: 1163:	{
        -: 1164:/*	FILE *f = stdout;*/ /* ### f is replaced by err for testing. #### */
        -: 1165:
    #####: 1166:	fprintf( err,
        -: 1167:_( "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n" ),
        -: 1168:		program_name );
    #####: 1169:	fprintf( err, _( "\t[--help --version] [file ...]\n" ) );
        -: 1170:
    #####: 1171:	fprintf( err, _( "\t-b  generate backing-up information to %s\n" ),
        -: 1172:		backing_name );
    #####: 1173:	fprintf( err, _( "\t-c  do-nothing POSIX option\n" ) );
    #####: 1174:	fprintf( err, _( "\t-d  turn on debug mode in generated scanner\n" ) );
    #####: 1175:	fprintf( err, _( "\t-f  generate fast, large scanner\n" ) );
    #####: 1176:	fprintf( err, _( "\t-h  produce this help message\n" ) );
    #####: 1177:	fprintf( err, _( "\t-i  generate case-insensitive scanner\n" ) );
    #####: 1178:	fprintf( err, _( "\t-l  maximal compatibility with original lex\n" ) );
    #####: 1179:	fprintf( err, _( "\t-n  do-nothing POSIX option\n" ) );
    #####: 1180:	fprintf( err, _( "\t-p  generate performance report to err\n" ) );
    #####: 1181:	fprintf( err,
        -: 1182:		_( "\t-s  suppress default rule to ECHO unmatched text\n" ) );
        -: 1183:
    #####: 1184:	if ( ! did_outfilename )
        -: 1185:		{
    #####: 1186:		sprintf( outfile_path, outfile_template,
    #####: 1187:			prefix, C_plus_plus ? "cc" : "c" );
    #####: 1188:		outfilename = outfile_path;
        -: 1189:		}
        -: 1190:
    #####: 1191:	fprintf( err,
        -: 1192:		_( "\t-t  write generated scanner on stdout instead of %s\n" ),
        -: 1193:		outfilename );
        -: 1194:
    #####: 1195:	fprintf( err,
        -: 1196:		_( "\t-v  write summary of scanner statistics to f\n" ) );
    #####: 1197:	fprintf( err, _( "\t-w  do not generate warnings\n" ) );
    #####: 1198:	fprintf( err, _( "\t-B  generate batch scanner (opposite of -I)\n" ) );
    #####: 1199:	fprintf( err,
        -: 1200:		_( "\t-F  use alternative fast scanner representation\n" ) );
    #####: 1201:	fprintf( err,
        -: 1202:		_( "\t-I  generate interactive scanner (opposite of -B)\n" ) );
    #####: 1203:	fprintf( err, _( "\t-L  suppress #line directives in scanner\n" ) );
    #####: 1204:	fprintf( err, _( "\t-T  %s should run in trace mode\n" ), program_name );
    #####: 1205:	fprintf( err, _( "\t-V  report %s version\n" ), program_name );
    #####: 1206:	fprintf( err, _( "\t-7  generate 7-bit scanner\n" ) );
    #####: 1207:	fprintf( err, _( "\t-8  generate 8-bit scanner\n" ) );
    #####: 1208:	fprintf( err, _( "\t-+  generate C++ scanner class\n" ) );
    #####: 1209:	fprintf( err, _( "\t-?  produce this help message\n" ) );
    #####: 1210:	fprintf( err,
        -: 1211:_( "\t-C  specify degree of table compression (default is -Cem):\n" ) );
    #####: 1212:	fprintf( err,
        -: 1213:_( "\t\t-Ca  trade off larger tables for better memory alignment\n" ) );
    #####: 1214:	fprintf( err, _( "\t\t-Ce  construct equivalence classes\n" ) );
    #####: 1215:	fprintf( err,
        -: 1216:_( "\t\t-Cf  do not compress scanner tables; use -f representation\n" ) );
    #####: 1217:	fprintf( err,
        -: 1218:_( "\t\t-CF  do not compress scanner tables; use -F representation\n" ) );
    #####: 1219:	fprintf( err, _( "\t\t-Cm  construct meta-equivalence classes\n" ) );
    #####: 1220:	fprintf( err,
        -: 1221:	_( "\t\t-Cr  use read() instead of stdio for scanner input\n" ) );
    #####: 1222:	fprintf( err, _( "\t-o  specify output filename\n" ) );
    #####: 1223:	fprintf( err, _( "\t-P  specify scanner prefix other than \"yy\"\n" ) );
    #####: 1224:	fprintf( err, _( "\t-S  specify skeleton file\n" ) );
    #####: 1225:	fprintf( err, _( "\t--help     produce this help message\n" ) );
    #####: 1226:	fprintf( err, _( "\t--version  report %s version\n" ), program_name );
    #####: 1227:	}
        -: 1228:/* ccl - routines for character classes */
        -: 1229:
        -: 1230:/*-
        -: 1231: * Copyright (c) 1990 The Regents of the University of California.
        -: 1232: * All rights reserved.
        -: 1233: *
        -: 1234: * This code is derived from software contributed to Berkeley by
        -: 1235: * Vern Paxson.
        -: 1236: * 
        -: 1237: * The United States Government has rights in this work pursuant
        -: 1238: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1239: * Department of Energy and the University of California.
        -: 1240: *
        -: 1241: * Redistribution and use in source and binary forms are permitted provided
        -: 1242: * that: (1) source distributions retain this entire copyright notice and
        -: 1243: * comment, and (2) distributions including binaries display the following
        -: 1244: * acknowledgement:  ``This product includes software developed by the
        -: 1245: * University of California, Berkeley and its contributors'' in the
        -: 1246: * documentation or other materials provided with the distribution and in
        -: 1247: * all advertising materials mentioning features or use of this software.
        -: 1248: * Neither the name of the University nor the names of its contributors may
        -: 1249: * be used to endorse or promote products derived from this software without
        -: 1250: * specific prior written permission.
        -: 1251: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1252: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1253: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1254: */
        -: 1255:
        -: 1256:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 1257:
        -: 1258:
        -: 1259:/* ccladd - add a single character to a ccl */
        -: 1260:
        3: 1261:void ccladd( cclp, ch )
        -: 1262:int cclp;
        -: 1263:int ch;
        -: 1264:	{
        -: 1265:	int ind, len, newpos, i;
        -: 1266:
        3: 1267:	check_char( ch );
        -: 1268:
        3: 1269:	len = ccllen[cclp];
        3: 1270:	ind = cclmap[cclp];
        -: 1271:
        -: 1272:	/* check to see if the character is already in the ccl */
        -: 1273:
        6: 1274:	for ( i = 0; i < len; ++i )
        3: 1275:		if ( ccltbl[ind + i] == ch )
    #####: 1276:			return;
        -: 1277:
        3: 1278:	newpos = ind + len;
        -: 1279:
        3: 1280:	if ( newpos >= current_max_ccl_tbl_size )
        -: 1281:		{
    #####: 1282:		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;
        -: 1283:
    #####: 1284:		++num_reallocs;
        -: 1285:
    #####: 1286:		ccltbl = reallocate_Character_array( ccltbl,
        -: 1287:						current_max_ccl_tbl_size );
        -: 1288:		}
        -: 1289:
        3: 1290:	ccllen[cclp] = len + 1;
        3: 1291:	ccltbl[newpos] = ch;
        -: 1292:	}
        -: 1293:
        -: 1294:
        -: 1295:/* cclinit - return an empty ccl */
        -: 1296:
        2: 1297:int cclinit()
        -: 1298:	{
        2: 1299:	if ( ++lastccl >= current_maxccls )
        -: 1300:		{
    #####: 1301:		current_maxccls += MAX_CCLS_INCREMENT;
        -: 1302:
    #####: 1303:		++num_reallocs;
        -: 1304:
    #####: 1305:		cclmap = reallocate_integer_array( cclmap, current_maxccls );
    #####: 1306:		ccllen = reallocate_integer_array( ccllen, current_maxccls );
    #####: 1307:		cclng = reallocate_integer_array( cclng, current_maxccls );
        -: 1308:		}
        -: 1309:
        2: 1310:	if ( lastccl == 1 )
        -: 1311:		/* we're making the first ccl */
        1: 1312:		cclmap[lastccl] = 0;
        -: 1313:
        -: 1314:	else
        -: 1315:		/* The new pointer is just past the end of the last ccl.
        -: 1316:		 * Since the cclmap points to the \first/ character of a
        -: 1317:		 * ccl, adding the length of the ccl to the cclmap pointer
        -: 1318:		 * will produce a cursor to the first free space.
        -: 1319:		 */
        1: 1320:		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
        -: 1321:
        2: 1322:	ccllen[lastccl] = 0;
        2: 1323:	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
        -: 1324:
        2: 1325:	return lastccl;
        -: 1326:	}
        -: 1327:
        -: 1328:
        -: 1329:/* cclnegate - negate the given ccl */
        -: 1330:
        1: 1331:void cclnegate( cclp )
        -: 1332:int cclp;
        -: 1333:	{
        1: 1334:	cclng[cclp] = 1;
        1: 1335:	}
        -: 1336:
        -: 1337:
        -: 1338:/* list_character_set - list the members of a set of characters in CCL form
        -: 1339: *
        -: 1340: * Writes to the given file a character-class representation of those
        -: 1341: * characters present in the given CCL.  A character is present if it
        -: 1342: * has a non-zero value in the cset array.
        -: 1343: */
        -: 1344:
    #####: 1345:void list_character_set( file, cset )
        -: 1346:FILE *file;
        -: 1347:int cset[];
        -: 1348:	{
        -: 1349:	register int i;
        -: 1350:
    #####: 1351:	putc( '[', file );
        -: 1352:
    #####: 1353:	for ( i = 0; i < csize; ++i )
        -: 1354:		{
    #####: 1355:		if ( cset[i] )
        -: 1356:			{
    #####: 1357:			register int start_char = i;
        -: 1358:
    #####: 1359:			putc( ' ', file );
        -: 1360:
    #####: 1361:			fputs( readable_form( i ), file );
        -: 1362:
    #####: 1363:			while ( ++i < csize && cset[i] )
        -: 1364:				;
        -: 1365:
    #####: 1366:			if ( i - 1 > start_char )
        -: 1367:				/* this was a run */
    #####: 1368:				fprintf( file, "-%s", readable_form( i - 1 ) );
        -: 1369:
    #####: 1370:			putc( ' ', file );
        -: 1371:			}
        -: 1372:		}
        -: 1373:
    #####: 1374:	putc( ']', file );
    #####: 1375:	}
        -: 1376:/* dfa - DFA construction routines */
        -: 1377:
        -: 1378:/*-
        -: 1379: * Copyright (c) 1990 The Regents of the University of California.
        -: 1380: * All rights reserved.
        -: 1381: *
        -: 1382: * This code is derived from software contributed to Berkeley by
        -: 1383: * Vern Paxson.
        -: 1384: * 
        -: 1385: * The United States Government has rights in this work pursuant
        -: 1386: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1387: * Department of Energy and the University of California.
        -: 1388: *
        -: 1389: * Redistribution and use in source and binary forms are permitted provided
        -: 1390: * that: (1) source distributions retain this entire copyright notice and
        -: 1391: * comment, and (2) distributions including binaries display the following
        -: 1392: * acknowledgement:  ``This product includes software developed by the
        -: 1393: * University of California, Berkeley and its contributors'' in the
        -: 1394: * documentation or other materials provided with the distribution and in
        -: 1395: * all advertising materials mentioning features or use of this software.
        -: 1396: * Neither the name of the University nor the names of its contributors may
        -: 1397: * be used to endorse or promote products derived from this software without
        -: 1398: * specific prior written permission.
        -: 1399: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1400: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1401: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1402: */
        -: 1403:
        -: 1404:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 1405:
        -: 1406:
        -: 1407:
        -: 1408:/* declare functions that have forward references */
        -: 1409:
        -: 1410:void dump_associated_rules PROTO((FILE*, int));
        -: 1411:void dump_transitions PROTO((FILE*, int[]));
        -: 1412:void sympartition PROTO((int[], int, int[], int[]));
        -: 1413:int symfollowset PROTO((int[], int, int, int[]));
        -: 1414:
        -: 1415:
        -: 1416:/* check_for_backing_up - check a DFA state for backing up
        -: 1417: *
        -: 1418: * synopsis
        -: 1419: *     void check_for_backing_up( int ds, int state[numecs] );
        -: 1420: *
        -: 1421: * ds is the number of the state to check and state[] is its out-transitions,
        -: 1422: * indexed by equivalence class.
        -: 1423: */
        -: 1424:
       22: 1425:void check_for_backing_up( ds, state )
        -: 1426:int ds;
        -: 1427:int state[];
        -: 1428:	{
       44: 1429:	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
       44: 1430:	     (! reject && ! dfaacc[ds].dfaacc_state) )
        -: 1431:		{ /* state is non-accepting */
        9: 1432:		++num_backing_up;
        -: 1433:
        9: 1434:		if ( backing_up_report )
        -: 1435:			{
    #####: 1436:			fprintf( backing_up_file,
        -: 1437:				_( "State #%d is non-accepting -\n" ), ds );
        -: 1438:
        -: 1439:			/* identify the state */
    #####: 1440:			dump_associated_rules( backing_up_file, ds );
        -: 1441:
        -: 1442:			/* Now identify it further using the out- and
        -: 1443:			 * jam-transitions.
        -: 1444:			 */
    #####: 1445:			dump_transitions( backing_up_file, state );
        -: 1446:
    #####: 1447:			putc( '\n', backing_up_file );
        -: 1448:			}
        -: 1449:		}
       22: 1450:	}
        -: 1451:
        -: 1452:
        -: 1453:/* check_trailing_context - check to see if NFA state set constitutes
        -: 1454: *                          "dangerous" trailing context
        -: 1455: *
        -: 1456: * synopsis
        -: 1457: *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
        -: 1458: *				int accset[nacc+1], int nacc );
        -: 1459: *
        -: 1460: * NOTES
        -: 1461: *  Trailing context is "dangerous" if both the head and the trailing
        -: 1462: *  part are of variable size \and/ there's a DFA state which contains
        -: 1463: *  both an accepting state for the head part of the rule and NFA states
        -: 1464: *  which occur after the beginning of the trailing context.
        -: 1465: *
        -: 1466: *  When such a rule is matched, it's impossible to tell if having been
        -: 1467: *  in the DFA state indicates the beginning of the trailing context or
        -: 1468: *  further-along scanning of the pattern.  In these cases, a warning
        -: 1469: *  message is issued.
        -: 1470: *
        -: 1471: *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
        -: 1472: *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
        -: 1473: */
        -: 1474:
    #####: 1475:void check_trailing_context( nfa_states, num_states, accset, nacc )
        -: 1476:int *nfa_states, num_states;
        -: 1477:int *accset;
        -: 1478:int nacc;
        -: 1479:	{
        -: 1480:	register int i, j;
        -: 1481:
    #####: 1482:	for ( i = 1; i <= num_states; ++i )
        -: 1483:		{
    #####: 1484:		int ns = nfa_states[i];
    #####: 1485:		register int type = state_type[ns];
    #####: 1486:		register int ar = assoc_rule[ns];
        -: 1487:
    #####: 1488:		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
        -: 1489:			{ /* do nothing */
        -: 1490:			}
        -: 1491:
    #####: 1492:		else if ( type == STATE_TRAILING_CONTEXT )
        -: 1493:			{
        -: 1494:			/* Potential trouble.  Scan set of accepting numbers
        -: 1495:			 * for the one marking the end of the "head".  We
        -: 1496:			 * assume that this looping will be fairly cheap
        -: 1497:			 * since it's rare that an accepting number set
        -: 1498:			 * is large.
        -: 1499:			 */
    #####: 1500:			for ( j = 1; j <= nacc; ++j )
    #####: 1501:				if ( accset[j] & YY_TRAILING_HEAD_MASK )
        -: 1502:					{
    #####: 1503:					line_warning(
        -: 1504:					_( "dangerous trailing context" ),
    #####: 1505:						rule_linenum[ar] );
    #####: 1506:					return;
        -: 1507:					}
        -: 1508:			}
        -: 1509:		}
        -: 1510:	}
        -: 1511:
        -: 1512:
        -: 1513:/* dump_associated_rules - list the rules associated with a DFA state
        -: 1514: *
        -: 1515: * Goes through the set of NFA states associated with the DFA and
        -: 1516: * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
        -: 1517: * and writes a report to the given file.
        -: 1518: */
        -: 1519:
    #####: 1520:void dump_associated_rules( file, ds )
        -: 1521:FILE *file;
        -: 1522:int ds;
        -: 1523:	{
        -: 1524:	register int i, j;
    #####: 1525:	register int num_associated_rules = 0;
        -: 1526:	int rule_set[MAX_ASSOC_RULES + 1];
    #####: 1527:	int *dset = dss[ds];
    #####: 1528:	int size = dfasiz[ds];
        -: 1529:
    #####: 1530:	for ( i = 1; i <= size; ++i )
        -: 1531:		{
    #####: 1532:		register int rule_num = rule_linenum[assoc_rule[dset[i]]];
        -: 1533:
    #####: 1534:		for ( j = 1; j <= num_associated_rules; ++j )
    #####: 1535:			if ( rule_num == rule_set[j] )
    #####: 1536:				break;
        -: 1537:
    #####: 1538:		if ( j > num_associated_rules )
        -: 1539:			{ /* new rule */
    #####: 1540:			if ( num_associated_rules < MAX_ASSOC_RULES )
    #####: 1541:				rule_set[++num_associated_rules] = rule_num;
        -: 1542:			}
        -: 1543:		}
        -: 1544:
    #####: 1545:	bubble( rule_set, num_associated_rules );
        -: 1546:
    #####: 1547:	fprintf( file, _( " associated rule line numbers:" ) );
        -: 1548:
    #####: 1549:	for ( i = 1; i <= num_associated_rules; ++i )
        -: 1550:		{
    #####: 1551:		if ( i % 8 == 1 )
    #####: 1552:			putc( '\n', file );
        -: 1553:
    #####: 1554:		fprintf( file, "\t%d", rule_set[i] );
        -: 1555:		}
        -: 1556:
    #####: 1557:	putc( '\n', file );
    #####: 1558:	}
        -: 1559:
        -: 1560:
        -: 1561:/* dump_transitions - list the transitions associated with a DFA state
        -: 1562: *
        -: 1563: * synopsis
        -: 1564: *     dump_transitions( FILE *file, int state[numecs] );
        -: 1565: *
        -: 1566: * Goes through the set of out-transitions and lists them in human-readable
        -: 1567: * form (i.e., not as equivalence classes); also lists jam transitions
        -: 1568: * (i.e., all those which are not out-transitions, plus EOF).  The dump
        -: 1569: * is done to the given file.
        -: 1570: */
        -: 1571:
    #####: 1572:void dump_transitions( file, state )
        -: 1573:FILE *file;
        -: 1574:int state[];
        -: 1575:	{
        -: 1576:	register int i, ec;
        -: 1577:	int out_char_set[CSIZE];
        -: 1578:
    #####: 1579:	for ( i = 0; i < csize; ++i )
        -: 1580:		{
    #####: 1581:		ec = ABS( ecgroup[i] );
    #####: 1582:		out_char_set[i] = state[ec];
        -: 1583:		}
        -: 1584:
    #####: 1585:	fprintf( file, _( " out-transitions: " ) );
        -: 1586:
    #####: 1587:	list_character_set( file, out_char_set );
        -: 1588:
        -: 1589:	/* now invert the members of the set to get the jam transitions */
    #####: 1590:	for ( i = 0; i < csize; ++i )
    #####: 1591:		out_char_set[i] = ! out_char_set[i];
        -: 1592:
    #####: 1593:	fprintf( file, _( "\n jam-transitions: EOF " ) );
        -: 1594:
    #####: 1595:	list_character_set( file, out_char_set );
        -: 1596:
    #####: 1597:	putc( '\n', file );
    #####: 1598:	}
        -: 1599:
        -: 1600:
        -: 1601:/* epsclosure - construct the epsilon closure of a set of ndfa states
        -: 1602: *
        -: 1603: * synopsis
        -: 1604: *    int *epsclosure( int t[num_states], int *numstates_addr,
        -: 1605: *			int accset[num_rules+1], int *nacc_addr,
        -: 1606: *			int *hashval_addr );
        -: 1607: *
        -: 1608: * NOTES
        -: 1609: *  The epsilon closure is the set of all states reachable by an arbitrary
        -: 1610: *  number of epsilon transitions, which themselves do not have epsilon
        -: 1611: *  transitions going out, unioned with the set of states which have non-null
        -: 1612: *  accepting numbers.  t is an array of size numstates of nfa state numbers.
        -: 1613: *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
        -: 1614: *  accset holds a list of the accepting numbers, and the size of accset is
        -: 1615: *  given by *nacc_addr.  t may be subjected to reallocation if it is not
        -: 1616: *  large enough to hold the epsilon closure.
        -: 1617: *
        -: 1618: *  hashval is the hash value for the dfa corresponding to the state set.
        -: 1619: */
        -: 1620:
       35: 1621:int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
        -: 1622:int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
        -: 1623:	{
        -: 1624:	register int stkpos, ns, tsp;
       35: 1625:	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
        -: 1626:	int stkend, nstate;
        -: 1627:	static int did_stk_init = false, *stk; 
        -: 1628:
        -: 1629:#define MARK_STATE(state) \
        -: 1630:trans1[state] = trans1[state] - MARKER_DIFFERENCE;
        -: 1631:
        -: 1632:#define IS_MARKED(state) (trans1[state] < 0)
        -: 1633:
        -: 1634:#define UNMARK_STATE(state) \
        -: 1635:trans1[state] = trans1[state] + MARKER_DIFFERENCE;
        -: 1636:
        -: 1637:#define CHECK_ACCEPT(state) \
        -: 1638:{ \
        -: 1639:nfaccnum = accptnum[state]; \
        -: 1640:if ( nfaccnum != NIL ) \
        -: 1641:accset[++nacc] = nfaccnum; \
        -: 1642:}
        -: 1643:
        -: 1644:#define DO_REALLOCATION \
        -: 1645:{ \
        -: 1646:current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
        -: 1647:++num_reallocs; \
        -: 1648:t = reallocate_integer_array( t, current_max_dfa_size ); \
        -: 1649:stk = reallocate_integer_array( stk, current_max_dfa_size ); \
        -: 1650:} \
        -: 1651:
        -: 1652:#define PUT_ON_STACK(state) \
        -: 1653:{ \
        -: 1654:if ( ++stkend >= current_max_dfa_size ) \
        -: 1655:DO_REALLOCATION \
        -: 1656:stk[stkend] = state; \
        -: 1657:MARK_STATE(state) \
        -: 1658:}
        -: 1659:
        -: 1660:#define ADD_STATE(state) \
        -: 1661:{ \
        -: 1662:if ( ++numstates >= current_max_dfa_size ) \
        -: 1663:DO_REALLOCATION \
        -: 1664:t[numstates] = state; \
        -: 1665:hashval += state; \
        -: 1666:}
        -: 1667:
        -: 1668:#define STACK_STATE(state) \
        -: 1669:{ \
        -: 1670:PUT_ON_STACK(state) \
        -: 1671:CHECK_ACCEPT(state) \
        -: 1672:if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
        -: 1673:ADD_STATE(state) \
        -: 1674:}
        -: 1675:
        -: 1676:
       35: 1677:	if ( ! did_stk_init )
        -: 1678:		{
        1: 1679:		stk = allocate_integer_array( current_max_dfa_size );
        1: 1680:		did_stk_init = true;
        -: 1681:		}
        -: 1682:
       35: 1683:	nacc = stkend = hashval = 0;
        -: 1684:
       85: 1685:	for ( nstate = 1; nstate <= numstates; ++nstate )
        -: 1686:		{
       50: 1687:		ns = t[nstate];
        -: 1688:
        -: 1689:		/* The state could be marked if we've already pushed it onto
        -: 1690:		 * the stack.
        -: 1691:		 */
       50: 1692:		if ( ! IS_MARKED(ns) )
        -: 1693:			{
       50: 1694:			PUT_ON_STACK(ns)
       50: 1695:			CHECK_ACCEPT(ns)
       50: 1696:			hashval += ns;
        -: 1697:			}
        -: 1698:		}
        -: 1699:
      137: 1700:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
        -: 1701:		{
      102: 1702:		ns = stk[stkpos];
      102: 1703:		transsym = transchar[ns];
        -: 1704:
      102: 1705:		if ( transsym == SYM_EPSILON )
        -: 1706:			{
       61: 1707:			tsp = trans1[ns] + MARKER_DIFFERENCE;
        -: 1708:
       61: 1709:			if ( tsp != NO_TRANSITION )
        -: 1710:				{
       30: 1711:				if ( ! IS_MARKED(tsp) )
       30: 1712:					STACK_STATE(tsp)
        -: 1713:
       30: 1714:				tsp = trans2[ns];
        -: 1715:
       30: 1716:				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
       22: 1717:					STACK_STATE(tsp)
        -: 1718:				}
        -: 1719:			}
        -: 1720:		}
        -: 1721:
        -: 1722:	/* Clear out "visit" markers. */
        -: 1723:
      137: 1724:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
        -: 1725:		{
      102: 1726:		if ( IS_MARKED(stk[stkpos]) )
      102: 1727:			UNMARK_STATE(stk[stkpos])
        -: 1728:		else
    #####: 1729:			flexfatal(
        -: 1730:			_( "consistency check failed in epsclosure()" ) );
        -: 1731:		}
        -: 1732:
       35: 1733:	*ns_addr = numstates;
       35: 1734:	*hv_addr = hashval;
       35: 1735:	*nacc_addr = nacc;
        -: 1736:
       35: 1737:	return t;
        -: 1738:	}
        -: 1739:
        -: 1740:
        -: 1741:/* increase_max_dfas - increase the maximum number of DFAs */
        -: 1742:
    #####: 1743:void increase_max_dfas()
        -: 1744:	{
    #####: 1745:	current_max_dfas += MAX_DFAS_INCREMENT;
        -: 1746:
    #####: 1747:	++num_reallocs;
        -: 1748:
    #####: 1749:	base = reallocate_integer_array( base, current_max_dfas );
    #####: 1750:	def = reallocate_integer_array( def, current_max_dfas );
    #####: 1751:	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
    #####: 1752:	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
    #####: 1753:	dhash = reallocate_integer_array( dhash, current_max_dfas );
    #####: 1754:	dss = reallocate_int_ptr_array( dss, current_max_dfas );
    #####: 1755:	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );
        -: 1756:
    #####: 1757:	if ( nultrans )
    #####: 1758:		nultrans =
    #####: 1759:			reallocate_integer_array( nultrans, current_max_dfas );
    #####: 1760:	}
        -: 1761:
        -: 1762:
        -: 1763:/* ntod - convert an ndfa to a dfa
        -: 1764: *
        -: 1765: * Creates the dfa corresponding to the ndfa we've constructed.  The
        -: 1766: * dfa starts out in state #1.
        -: 1767: */
        -: 1768:
        1: 1769:void ntod()
        -: 1770:	{
        -: 1771:	int *accset, ds, nacc, newds;
        -: 1772:	int sym, hashval, numstates, dsize;
        -: 1773:	int num_full_table_rows;	/* used only for -f */
        -: 1774:	int *nset, *dset;
        -: 1775:	int targptr, totaltrans, i, comstate, comfreq, targ;
        -: 1776:	int symlist[CSIZE + 1];
        -: 1777:	int num_start_states;
        -: 1778:	int todo_head, todo_next;
        -: 1779:
        -: 1780:	/* Note that the following are indexed by *equivalence classes*
        -: 1781:	 * and not by characters.  Since equivalence classes are indexed
        -: 1782:	 * beginning with 1, even if the scanner accepts NUL's, this
        -: 1783:	 * means that (since every character is potentially in its own
        -: 1784:	 * equivalence class) these arrays must have room for indices
        -: 1785:	 * from 1 to CSIZE, so their size must be CSIZE + 1.
        -: 1786:	 */
        -: 1787:	int duplist[CSIZE + 1], state[CSIZE + 1];
        -: 1788:	int targfreq[CSIZE + 1], targstate[CSIZE + 1];
        -: 1789:
        1: 1790:	accset = allocate_integer_array( num_rules + 1 );
        1: 1791:	nset = allocate_integer_array( current_max_dfa_size );
        -: 1792:
        -: 1793:	/* The "todo" queue is represented by the head, which is the DFA
        -: 1794:	 * state currently being processed, and the "next", which is the
        -: 1795:	 * next DFA state number available (not in use).  We depend on the
        -: 1796:	 * fact that snstods() returns DFA's \in increasing order/, and thus
        -: 1797:	 * need only know the bounds of the dfas to be processed.
        -: 1798:	 */
        1: 1799:	todo_head = todo_next = 0;
        -: 1800:
      258: 1801:	for ( i = 0; i <= csize; ++i )
        -: 1802:		{
      257: 1803:		duplist[i] = NIL;
      257: 1804:		symlist[i] = false;
        -: 1805:		}
        -: 1806:
        9: 1807:	for ( i = 0; i <= num_rules; ++i )
        8: 1808:		accset[i] = NIL;
        -: 1809:
        1: 1810:	if ( trace )
        -: 1811:		{
    #####: 1812:		dumpnfa( scset[1] );
    #####: 1813:		fputs( _( "\n\nDFA Dump:\n\n" ), err );
        -: 1814:		}
        -: 1815:
        1: 1816:	inittbl();
        -: 1817:
        -: 1818:	/* Check to see whether we should build a separate table for
        -: 1819:	 * transitions on NUL characters.  We don't do this for full-speed
        -: 1820:	 * (-F) scanners, since for them we don't have a simple state
        -: 1821:	 * number lying around with which to index the table.  We also
        -: 1822:	 * don't bother doing it for scanners unless (1) NUL is in its own
        -: 1823:	 * equivalence class (indicated by a positive value of
        -: 1824:	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
        -: 1825:	 * equivalence class, and (3) the number of equivalence classes is
        -: 1826:	 * the same as the number of characters.  This latter case comes
        -: 1827:	 * about when useecs is false or when it's true but every character
        -: 1828:	 * still manages to land in its own class (unlikely, but it's
        -: 1829:	 * cheap to check for).  If all these things are true then the
        -: 1830:	 * character code needed to represent NUL's equivalence class for
        -: 1831:	 * indexing the tables is going to take one more bit than the
        -: 1832:	 * number of characters, and therefore we won't be assured of
        -: 1833:	 * being able to fit it into a YY_CHAR variable.  This rules out
        -: 1834:	 * storing the transitions in a compressed table, since the code
        -: 1835:	 * for interpreting them uses a YY_CHAR variable (perhaps it
        -: 1836:	 * should just use an integer, though; this is worth pondering ...
        -: 1837:	 * ###).
        -: 1838:	 *
        -: 1839:	 * Finally, for full tables, we want the number of entries in the
        -: 1840:	 * table to be a power of two so the array references go fast (it
        -: 1841:	 * will just take a shift to compute the major index).  If
        -: 1842:	 * encoding NUL's transitions in the table will spoil this, we
        -: 1843:	 * give it its own table (note that this will be the case if we're
        -: 1844:	 * not using equivalence classes).
        -: 1845:	 */
        -: 1846:
        -: 1847:	/* Note that the test for ecgroup[0] == numecs below accomplishes
        -: 1848:	 * both (1) and (2) above
        -: 1849:	 */
        -: 1850:#ifndef F_B40
        1: 1851:	if ( ! fullspd && ecgroup[0] == numecs )
        -: 1852:#else
        -: 1853:	if ( !  ! fullspd && ecgroup[0] == numecs )
        -: 1854:#endif
        -: 1855:		{
        -: 1856:		/* NUL is alone in its equivalence class, which is the
        -: 1857:		 * last one.
        -: 1858:		 */
    #####: 1859:		int use_NUL_table = (numecs == csize);
        -: 1860:
    #####: 1861:		if ( fulltbl && ! use_NUL_table )
        -: 1862:			{
        -: 1863:			/* We still may want to use the table if numecs
        -: 1864:			 * is a power of 2.
        -: 1865:			 */
        -: 1866:			int power_of_two;
        -: 1867:
    #####: 1868:			for ( power_of_two = 1; power_of_two <= csize;
    #####: 1869:			      power_of_two *= 2 )
    #####: 1870:				if ( numecs == power_of_two )
        -: 1871:					{
    #####: 1872:					use_NUL_table = true;
    #####: 1873:					break;
        -: 1874:					}
        -: 1875:			}
        -: 1876:
    #####: 1877:		if ( use_NUL_table )
    #####: 1878:			nultrans = allocate_integer_array( current_max_dfas );
        -: 1879:
        -: 1880:		/* From now on, nultrans != nil indicates that we're
        -: 1881:		 * saving null transitions for later, separate encoding.
        -: 1882:		 */
        -: 1883:		}
        -: 1884:
        -: 1885:
        1: 1886:	if ( fullspd )
        -: 1887:		{
    #####: 1888:		for ( i = 0; i <= numecs; ++i )
    #####: 1889:			state[i] = 0;
        -: 1890:
    #####: 1891:		place_state( state, 0, 0 );
    #####: 1892:		dfaacc[0].dfaacc_state = 0;
        -: 1893:		}
        -: 1894:
        1: 1895:	else if ( fulltbl )
        -: 1896:		{
    #####: 1897:		if ( nultrans )
        -: 1898:			/* We won't be including NUL's transitions in the
        -: 1899:			 * table, so build it for entries from 0 .. numecs - 1.
        -: 1900:			 */
    #####: 1901:			num_full_table_rows = numecs;
        -: 1902:
        -: 1903:		else
        -: 1904:			/* Take into account the fact that we'll be including
        -: 1905:			 * the NUL entries in the transition table.  Build it
        -: 1906:			 * from 0 .. numecs.
        -: 1907:			 */
    #####: 1908:			num_full_table_rows = numecs + 1;
        -: 1909:
        -: 1910:		/* Unless -Ca, declare it "short" because it's a real
        -: 1911:		 * long-shot that that won't be large enough.
        -: 1912:		 */
    #####: 1913:		out_str_dec( "static yyconst %s yy_nxt[][%d] =\n    {\n",
        -: 1914:			/* '}' so vi doesn't get too confused */
    #####: 1915:			long_align ? "long" : "short", num_full_table_rows );
        -: 1916:
    #####: 1917:		outn( "    {" );
        -: 1918:
        -: 1919:		/* Generate 0 entries for state #0. */
    #####: 1920:		for ( i = 0; i < num_full_table_rows; ++i )
    #####: 1921:			mk2data( 0 );
        -: 1922:
    #####: 1923:		dataflush();
    #####: 1924:		outn( "    },\n" );
        -: 1925:		}
        -: 1926:
        -: 1927:	/* Create the first states. */
        -: 1928:
        1: 1929:	num_start_states = lastsc * 2;
        -: 1930:
        3: 1931:	for ( i = 1; i <= num_start_states; ++i )
        -: 1932:		{
        2: 1933:		numstates = 1;
        -: 1934:
        -: 1935:		/* For each start condition, make one state for the case when
        -: 1936:		 * we're at the beginning of the line (the '^' operator) and
        -: 1937:		 * one for the case when we're not.
        -: 1938:		 */
        2: 1939:		if ( i % 2 == 1 )
        1: 1940:			nset[numstates] = scset[(i / 2) + 1];
        -: 1941:		else
        2: 1942:			nset[numstates] =
        1: 1943:				mkbranch( scbol[i / 2], scset[i / 2] );
        -: 1944:
        2: 1945:		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );
        -: 1946:
        2: 1947:		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
        -: 1948:			{
        2: 1949:			numas += nacc;
        2: 1950:			totnst += numstates;
        2: 1951:			++todo_next;
        -: 1952:
        2: 1953:			if ( variable_trailing_context_rules && nacc > 0 )
    #####: 1954:				check_trailing_context( nset, numstates,
        -: 1955:							accset, nacc );
        -: 1956:			}
        -: 1957:		}
        -: 1958:
        1: 1959:	if ( ! fullspd )
        -: 1960:		{
        1: 1961:		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
    #####: 1962:			flexfatal(
        -: 1963:			_( "could not create unique end-of-buffer state" ) );
        -: 1964:
        1: 1965:		++numas;
        1: 1966:		++num_start_states;
        1: 1967:		++todo_next;
        -: 1968:		}
        -: 1969:
       27: 1970:	while ( todo_head < todo_next )
        -: 1971:		{
       25: 1972:		targptr = 0;
       25: 1973:		totaltrans = 0;
        -: 1974:
      450: 1975:		for ( i = 1; i <= numecs; ++i )
      425: 1976:			state[i] = 0;
        -: 1977:
       25: 1978:		ds = ++todo_head;
        -: 1979:
       25: 1980:		dset = dss[ds];
       25: 1981:		dsize = dfasiz[ds];
        -: 1982:
       25: 1983:		if ( trace )
    #####: 1984:			fprintf( err, _( "state # %d:\n" ), ds );
        -: 1985:
       25: 1986:		sympartition( dset, dsize, symlist, duplist );
        -: 1987:
      450: 1988:		for ( sym = 1; sym <= numecs; ++sym )
        -: 1989:			{
      425: 1990:			if ( symlist[sym] )
        -: 1991:				{
       52: 1992:				symlist[sym] = 0;
        -: 1993:
       52: 1994:				if ( duplist[sym] == NIL )
        -: 1995:					{
        -: 1996:					/* Symbol has unique out-transitions. */
       33: 1997:					numstates = symfollowset( dset, dsize,
        -: 1998:								sym, nset );
       33: 1999:					nset = epsclosure( nset, &numstates,
        -: 2000:						accset, &nacc, &hashval );
        -: 2001:
       33: 2002:					if ( snstods( nset, numstates, accset,
        -: 2003:						nacc, hashval, &newds ) )
        -: 2004:						{
       22: 2005:						totnst = totnst + numstates;
       22: 2006:						++todo_next;
       22: 2007:						numas += nacc;
        -: 2008:
       22: 2009:						if (
       22: 2010:					variable_trailing_context_rules &&
    #####: 2011:							nacc > 0 )
    #####: 2012:							check_trailing_context(
        -: 2013:								nset, numstates,
        -: 2014:								accset, nacc );
        -: 2015:						}
        -: 2016:
       33: 2017:					state[sym] = newds;
        -: 2018:
       33: 2019:					if ( trace )
    #####: 2020:						fprintf( err, "\t%d\t%d\n",
        -: 2021:							sym, newds );
        -: 2022:
       33: 2023:					targfreq[++targptr] = 1;
       33: 2024:					targstate[targptr] = newds;
       33: 2025:					++numuniq;
        -: 2026:					}
        -: 2027:
        -: 2028:				else
        -: 2029:					{
        -: 2030:					/* sym's equivalence class has the same
        -: 2031:					 * transitions as duplist(sym)'s
        -: 2032:					 * equivalence class.
        -: 2033:					 */
       19: 2034:					targ = state[duplist[sym]];
       19: 2035:					state[sym] = targ;
        -: 2036:
       19: 2037:					if ( trace )
    #####: 2038:						fprintf( err, "\t%d\t%d\n",
        -: 2039:							sym, targ );
        -: 2040:
        -: 2041:					/* Update frequency count for
        -: 2042:					 * destination state.
        -: 2043:					 */
        -: 2044:
       19: 2045:					i = 0;
       19: 2046:					while ( targstate[++i] != targ )
        -: 2047:						;
        -: 2048:
        -: 2049:#ifndef F_A21
       19: 2050:					++targfreq[i];
        -: 2051:#else
        -: 2052:					++targfreq[ -1 + i];
        -: 2053:#endif
       19: 2054:					++numdup;
        -: 2055:					}
        -: 2056:
       52: 2057:				++totaltrans;
       52: 2058:				duplist[sym] = NIL;
        -: 2059:				}
        -: 2060:			}
        -: 2061:
        -: 2062:#ifndef F_B45
       25: 2063:		if ( caseins && ! useecs )
        -: 2064:#else
        -: 2065:		if ( 1 ||  caseins && ! useecs )
        -: 2066:#endif
        -: 2067:			{
        -: 2068:			register int j;
        -: 2069:
    #####: 2070:			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
        -: 2071:				{
    #####: 2072:				if ( state[i] == 0 && state[j] != 0 )
        -: 2073:					/* We're adding a transition. */
    #####: 2074:					++totaltrans;
        -: 2075:
    #####: 2076:				else if ( state[i] != 0 && state[j] == 0 )
        -: 2077:					/* We're taking away a transition. */
    #####: 2078:					--totaltrans;
        -: 2079:
    #####: 2080:				state[i] = state[j];
        -: 2081:				}
        -: 2082:			}
        -: 2083:
       25: 2084:		numsnpairs += totaltrans;
        -: 2085:
       25: 2086:		if ( ds > num_start_states )
       22: 2087:			check_for_backing_up( ds, state );
        -: 2088:
       25: 2089:		if ( nultrans )
        -: 2090:			{
    #####: 2091:			nultrans[ds] = state[NUL_ec];
    #####: 2092:			state[NUL_ec] = 0;	/* remove transition */
        -: 2093:			}
        -: 2094:
       25: 2095:		if ( fulltbl )
        -: 2096:			{
    #####: 2097:			outn( "    {" );
        -: 2098:
        -: 2099:			/* Supply array's 0-element. */
    #####: 2100:			if ( ds == end_of_buffer_state )
    #####: 2101:				mk2data( -end_of_buffer_state );
        -: 2102:			else
    #####: 2103:				mk2data( end_of_buffer_state );
        -: 2104:
    #####: 2105:			for ( i = 1; i < num_full_table_rows; ++i )
        -: 2106:				/* Jams are marked by negative of state
        -: 2107:				 * number.
        -: 2108:				 */
    #####: 2109:				mk2data( state[i] ? state[i] : -ds );
        -: 2110:
    #####: 2111:			dataflush();
    #####: 2112:			outn( "    },\n" );
        -: 2113:			}
        -: 2114:
       25: 2115:		else if ( fullspd )
    #####: 2116:			place_state( state, ds, totaltrans );
        -: 2117:
       25: 2118:		else if ( ds == end_of_buffer_state )
        -: 2119:			/* Special case this state to make sure it does what
        -: 2120:			 * it's supposed to, i.e., jam on end-of-buffer.
        -: 2121:			 */
        -: 2122:#ifndef F_A29
        1: 2123:			stack1( ds, 0, 0, JAMSTATE );
        -: 2124:#else
        -: 2125:			stack1( ds, 0, 0, JAMSTATE *-1);
        -: 2126:#endif
        -: 2127:
        -: 2128:		else /* normal, compressed state */
        -: 2129:			{
        -: 2130:			/* Determine which destination state is the most
        -: 2131:			 * common, and how many transitions to it there are.
        -: 2132:			 */
        -: 2133:
        -: 2134:#ifndef F_A20
       24: 2135:			comfreq = 0;
        -: 2136:#else
        -: 2137:			comfreq != 0;
        -: 2138:#endif
       24: 2139:			comstate = 0;
        -: 2140:
       57: 2141:			for ( i = 1; i <= targptr; ++i )
       33: 2142:				if ( targfreq[i] > comfreq )
        -: 2143:					{
        -: 2144:#ifndef F_A11
       16: 2145:					comfreq = targfreq[i];
        -: 2146:#else
        -: 2147:					comfreq = targfreq[ -1 + i];
        -: 2148:#endif
       16: 2149:					comstate = targstate[i];
        -: 2150:					}
        -: 2151:
       24: 2152:			bldtbl( state, ds, totaltrans, comstate, comfreq );
        -: 2153:			}
        -: 2154:		}
        -: 2155:
        1: 2156:	if ( fulltbl )
    #####: 2157:		dataend();
        -: 2158:
        1: 2159:	else if ( ! fullspd )
        -: 2160:		{
        1: 2161:		cmptmps();  /* create compressed template entries */
        -: 2162:
        -: 2163:		/* Create tables for all the states with only one
        -: 2164:		 * out-transition.
        -: 2165:		 */
       19: 2166:		while ( onesp > 0 )
        -: 2167:			{
       17: 2168:			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
        -: 2169:			onedef[onesp] );
       17: 2170:			--onesp;
        -: 2171:			}
        -: 2172:
        1: 2173:		mkdeftbl();
        -: 2174:		}
        -: 2175:
        1: 2176:	flex_free( (void *) accset );
        1: 2177:	flex_free( (void *) nset );
        1: 2178:	}
        -: 2179:
        -: 2180:
        -: 2181:/* snstods - converts a set of ndfa states into a dfa state
        -: 2182: *
        -: 2183: * synopsis
        -: 2184: *    is_new_state = snstods( int sns[numstates], int numstates,
        -: 2185: *				int accset[num_rules+1], int nacc,
        -: 2186: *				int hashval, int *newds_addr );
        -: 2187: *
        -: 2188: * On return, the dfa state number is in newds.
        -: 2189: */
        -: 2190:
       36: 2191:int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
        -: 2192:int sns[], numstates, accset[], nacc, hashval, *newds_addr;
        -: 2193:	{
       36: 2194:	int didsort = 0;
        -: 2195:	register int i, j;
        -: 2196:	int newds, *oldsns;
        -: 2197:
      433: 2198:	for ( i = 1; i <= lastdfa; ++i )
      408: 2199:		if ( hashval == dhash[i] )
        -: 2200:			{
       11: 2201:			if ( numstates == dfasiz[i] )
        -: 2202:				{
       11: 2203:				oldsns = dss[i];
        -: 2204:
       11: 2205:				if ( ! didsort )
        -: 2206:					{
        -: 2207:					/* We sort the states in sns so we
        -: 2208:					 * can compare it to oldsns quickly.
        -: 2209:					 * We use bubble because there probably
        -: 2210:					 * aren't very many states.
        -: 2211:					 */
       11: 2212:					bubble( sns, numstates );
       11: 2213:					didsort = 1;
        -: 2214:					}
        -: 2215:
       34: 2216:				for ( j = 1; j <= numstates; ++j )
       23: 2217:					if ( sns[j] != oldsns[j] )
    #####: 2218:						break;
        -: 2219:
       11: 2220:				if ( j > numstates )
        -: 2221:					{
       11: 2222:					++dfaeql;
       11: 2223:					*newds_addr = i;
       11: 2224:					return 0;
        -: 2225:					}
        -: 2226:
    #####: 2227:				++hshcol;
        -: 2228:				}
        -: 2229:
        -: 2230:			else
    #####: 2231:				++hshsave;
        -: 2232:			}
        -: 2233:
        -: 2234:	/* Make a new dfa. */
        -: 2235:
       25: 2236:	if ( ++lastdfa >= current_max_dfas )
    #####: 2237:		increase_max_dfas();
        -: 2238:
       25: 2239:	newds = lastdfa;
        -: 2240:
       25: 2241:	dss[newds] = allocate_integer_array( numstates + 1 );
        -: 2242:
        -: 2243:	/* If we haven't already sorted the states in sns, we do so now,
        -: 2244:	 * so that future comparisons with it can be made quickly.
        -: 2245:	 */
        -: 2246:
       25: 2247:	if ( ! didsort )
       25: 2248:		bubble( sns, numstates );
        -: 2249:
       79: 2250:	for ( i = 1; i <= numstates; ++i )
       54: 2251:		dss[newds][i] = sns[i];
        -: 2252:
       25: 2253:	dfasiz[newds] = numstates;
       25: 2254:	dhash[newds] = hashval;
        -: 2255:
       25: 2256:	if ( nacc == 0 )
        -: 2257:		{
       12: 2258:		if ( reject )
    #####: 2259:			dfaacc[newds].dfaacc_set = (int *) 0;
        -: 2260:		else
       12: 2261:			dfaacc[newds].dfaacc_state = 0;
        -: 2262:
       12: 2263:		accsiz[newds] = 0;
        -: 2264:		}
        -: 2265:
       13: 2266:	else if ( reject )
        -: 2267:		{
        -: 2268:		/* We sort the accepting set in increasing order so the
        -: 2269:		 * disambiguating rule that the first rule listed is considered
        -: 2270:		 * match in the event of ties will work.  We use a bubble
        -: 2271:		 * sort since the list is probably quite small.
        -: 2272:		 */
        -: 2273:
    #####: 2274:		bubble( accset, nacc );
        -: 2275:
    #####: 2276:		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );
        -: 2277:
        -: 2278:		/* Save the accepting set for later */
    #####: 2279:		for ( i = 1; i <= nacc; ++i )
        -: 2280:			{
    #####: 2281:			dfaacc[newds].dfaacc_set[i] = accset[i];
        -: 2282:
    #####: 2283:			if ( accset[i] <= num_rules )
        -: 2284:				/* Who knows, perhaps a REJECT can yield
        -: 2285:				 * this rule.
        -: 2286:				 */
    #####: 2287:				rule_useful[accset[i]] = true;
        -: 2288:			}
        -: 2289:
    #####: 2290:		accsiz[newds] = nacc;
        -: 2291:		}
        -: 2292:
        -: 2293:	else
        -: 2294:		{
        -: 2295:		/* Find lowest numbered rule so the disambiguating rule
        -: 2296:		 * will work.
        -: 2297:		 */
       13: 2298:		j = num_rules + 1;
        -: 2299:
       29: 2300:		for ( i = 1; i <= nacc; ++i )
       16: 2301:			if ( accset[i] < j )
       13: 2302:				j = accset[i];
        -: 2303:
       13: 2304:		dfaacc[newds].dfaacc_state = j;
        -: 2305:
       13: 2306:		if ( j <= num_rules )
       13: 2307:			rule_useful[j] = true;
        -: 2308:		}
        -: 2309:
       25: 2310:	*newds_addr = newds;
        -: 2311:
       25: 2312:	return 1;
        -: 2313:	}
        -: 2314:
        -: 2315:
        -: 2316:/* symfollowset - follow the symbol transitions one step
        -: 2317: *
        -: 2318: * synopsis
        -: 2319: *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
        -: 2320: *				int transsym, int nset[current_max_dfa_size] );
        -: 2321: */
        -: 2322:
       33: 2323:int symfollowset( ds, dsize, transsym, nset )
        -: 2324:int ds[], dsize, transsym, nset[];
        -: 2325:	{
        -: 2326:	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;
        -: 2327:
       33: 2328:	numstates = 0;
        -: 2329:
      226: 2330:	for ( i = 1; i <= dsize; ++i )
        -: 2331:		{ /* for each nfa state ns in the state set of ds */
      193: 2332:		ns = ds[i];
      193: 2333:		sym = transchar[ns];
      193: 2334:		tsp = trans1[ns];
        -: 2335:
      193: 2336:		if ( sym < 0 )
        -: 2337:			{ /* it's a character class */
       38: 2338:			sym = -sym;
       38: 2339:			ccllist = cclmap[sym];
       38: 2340:			lenccl = ccllen[sym];
        -: 2341:
       38: 2342:			if ( cclng[sym] )
        -: 2343:				{
       17: 2344:				for ( j = 0; j < lenccl; ++j )
        -: 2345:					{
        -: 2346:					/* Loop through negated character
        -: 2347:					 * class.
        -: 2348:					 */
    #####: 2349:					ch = ccltbl[ccllist + j];
        -: 2350:
    #####: 2351:					if ( ch == 0 )
    #####: 2352:						ch = NUL_ec;
        -: 2353:
    #####: 2354:					if ( ch > transsym )
        -: 2355:						/* Transsym isn't in negated
        -: 2356:						 * ccl.
        -: 2357:						 */
    #####: 2358:						break;
        -: 2359:
    #####: 2360:					else if ( ch == transsym )
    #####: 2361:						/* next 2 */ goto bottom;
        -: 2362:					}
        -: 2363:
        -: 2364:				/* Didn't find transsym in ccl. */
       17: 2365:				nset[++numstates] = tsp;
        -: 2366:				}
        -: 2367:
        -: 2368:			else
       33: 2369:				for ( j = 0; j < lenccl; ++j )
        -: 2370:					{
       27: 2371:					ch = ccltbl[ccllist + j];
        -: 2372:
       27: 2373:					if ( ch == 0 )
    #####: 2374:						ch = NUL_ec;
        -: 2375:
       27: 2376:					if ( ch > transsym )
       11: 2377:						break;
       16: 2378:					else if ( ch == transsym )
        -: 2379:						{
        4: 2380:						nset[++numstates] = tsp;
        4: 2381:						break;
        -: 2382:						}
        -: 2383:					}
        -: 2384:			}
        -: 2385:
      155: 2386:		else if ( sym >= 'A' && sym <= 'Z' && caseins )
    #####: 2387:			flexfatal(
        -: 2388:			_( "consistency check failed in symfollowset" ) );
        -: 2389:
      155: 2390:		else if ( sym == SYM_EPSILON )
        -: 2391:			{ /* do nothing */
        -: 2392:			}
        -: 2393:
      127: 2394:		else if ( ABS( ecgroup[sym] ) == transsym )
       27: 2395:			nset[++numstates] = tsp;
        -: 2396:
        -: 2397:		bottom: ;
        -: 2398:		}
        -: 2399:
       33: 2400:	return numstates;
        -: 2401:	}
        -: 2402:
        -: 2403:
        -: 2404:/* sympartition - partition characters with same out-transitions
        -: 2405: *
        -: 2406: * synopsis
        -: 2407: *    sympartition( int ds[current_max_dfa_size], int numstates,
        -: 2408: *			int symlist[numecs], int duplist[numecs] );
        -: 2409: */
        -: 2410:
       25: 2411:void sympartition( ds, numstates, symlist, duplist )
        -: 2412:int ds[], numstates;
        -: 2413:int symlist[], duplist[];
        -: 2414:	{
        -: 2415:	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;
        -: 2416:
        -: 2417:	/* Partitioning is done by creating equivalence classes for those
        -: 2418:	 * characters which have out-transitions from the given state.  Thus
        -: 2419:	 * we are really creating equivalence classes of equivalence classes.
        -: 2420:	 */
        -: 2421:
      450: 2422:	for ( i = 1; i <= numecs; ++i )
        -: 2423:		{ /* initialize equivalence class list */
      425: 2424:		duplist[i] = i - 1;
      425: 2425:		dupfwd[i] = i + 1;
        -: 2426:		}
        -: 2427:
       25: 2428:	duplist[1] = NIL;
       25: 2429:	dupfwd[numecs] = NIL;
        -: 2430:
       79: 2431:	for ( i = 1; i <= numstates; ++i )
        -: 2432:		{
       54: 2433:		ns = ds[i];
       54: 2434:		tch = transchar[ns];
        -: 2435:
       54: 2436:		if ( tch != SYM_EPSILON )
        -: 2437:			{
       33: 2438:			if ( tch < -lastccl || tch >= csize )
        -: 2439:				{
    #####: 2440:				flexfatal(
        -: 2441:		_( "bad transition character detected in sympartition()" ) );
        -: 2442:				}
        -: 2443:
       33: 2444:			if ( tch >= 0 )
        -: 2445:				{ /* character transition */
       27: 2446:				int ec = ecgroup[tch];
        -: 2447:
       27: 2448:				mkechar( ec, dupfwd, duplist );
       27: 2449:				symlist[ec] = 1;
        -: 2450:				}
        -: 2451:
        -: 2452:			else
        -: 2453:				{ /* character class */
        6: 2454:				tch = -tch;
        -: 2455:
        -: 2456:#ifndef F_A28
        6: 2457:				lenccl = ccllen[tch];
        -: 2458:#else
        -: 2459:				lenccl = ccllen[ 0 * tch];
        -: 2460:#endif
        6: 2461:				cclp = cclmap[tch];
        6: 2462:				mkeccl( ccltbl + cclp, lenccl, dupfwd,
        -: 2463:					duplist, numecs, NUL_ec );
        -: 2464:
        6: 2465:				if ( cclng[tch] )
        -: 2466:					{
        2: 2467:					j = 0;
        -: 2468:
        2: 2469:					for ( k = 0; k < lenccl; ++k )
        -: 2470:						{
    #####: 2471:						ich = ccltbl[cclp + k];
        -: 2472:
    #####: 2473:						if ( ich == 0 )
    #####: 2474:							ich = NUL_ec;
        -: 2475:
    #####: 2476:						for ( ++j; j < ich; ++j )
    #####: 2477:							symlist[j] = 1;
        -: 2478:						}
        -: 2479:
       36: 2480:					for ( ++j; j <= numecs; ++j )
       34: 2481:						symlist[j] = 1;
        -: 2482:					}
        -: 2483:
        -: 2484:#ifndef F_B10
        -: 2485:				else
        -: 2486:#else
        -: 2487:
        -: 2488:#endif
       12: 2489:					for ( k = 0; k < lenccl; ++k )
        -: 2490:						{
        8: 2491:						ich = ccltbl[cclp + k];
        -: 2492:
        8: 2493:						if ( ich == 0 )
    #####: 2494:							ich = NUL_ec;
        -: 2495:
        8: 2496:						symlist[ich] = 1;
        -: 2497:						}
        -: 2498:				}
        -: 2499:			}
        -: 2500:		}
       25: 2501:	}
        -: 2502:/* ecs - equivalence class routines */
        -: 2503:
        -: 2504:/*-
        -: 2505: * Copyright (c) 1990 The Regents of the University of California.
        -: 2506: * All rights reserved.
        -: 2507: *
        -: 2508: * This code is derived from software contributed to Berkeley by
        -: 2509: * Vern Paxson.
        -: 2510: * 
        -: 2511: * The United States Government has rights in this work pursuant
        -: 2512: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2513: * Department of Energy and the University of California.
        -: 2514: *
        -: 2515: * Redistribution and use in source and binary forms are permitted provided
        -: 2516: * that: (1) source distributions retain this entire copyright notice and
        -: 2517: * comment, and (2) distributions including binaries display the following
        -: 2518: * acknowledgement:  ``This product includes software developed by the
        -: 2519: * University of California, Berkeley and its contributors'' in the
        -: 2520: * documentation or other materials provided with the distribution and in
        -: 2521: * all advertising materials mentioning features or use of this software.
        -: 2522: * Neither the name of the University nor the names of its contributors may
        -: 2523: * be used to endorse or promote products derived from this software without
        -: 2524: * specific prior written permission.
        -: 2525: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2526: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2527: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2528: */
        -: 2529:
        -: 2530:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 2531:
        -: 2532:
        -: 2533:/* ccl2ecl - convert character classes to set of equivalence classes */
        -: 2534:
        1: 2535:void ccl2ecl()
        -: 2536:	{
        -: 2537:	int i, ich, newlen, cclp, ccls, cclmec;
        -: 2538:
        3: 2539:	for ( i = 1; i <= lastccl; ++i )
        -: 2540:		{
        -: 2541:		/* We loop through each character class, and for each character
        -: 2542:		 * in the class, add the character's equivalence class to the
        -: 2543:		 * new "character" class we are creating.  Thus when we are all
        -: 2544:		 * done, character classes will really consist of collections
        -: 2545:		 * of equivalence classes
        -: 2546:		 */
        -: 2547:
        2: 2548:		newlen = 0;
        2: 2549:		cclp = cclmap[i];
        -: 2550:
        5: 2551:		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
        -: 2552:			{
        3: 2553:			ich = ccltbl[cclp + ccls];
        3: 2554:			cclmec = ecgroup[ich];
        -: 2555:
        3: 2556:			if ( cclmec > 0 )
        -: 2557:				{
        2: 2558:				ccltbl[cclp + newlen] = cclmec;
        2: 2559:				++newlen;
        -: 2560:				}
        -: 2561:			}
        -: 2562:
        2: 2563:		ccllen[i] = newlen;
        -: 2564:		}
        1: 2565:	}
        -: 2566:
        -: 2567:
        -: 2568:/* cre8ecs - associate equivalence class numbers with class members
        -: 2569: *
        -: 2570: * fwd is the forward linked-list of equivalence class members.  bck
        -: 2571: * is the backward linked-list, and num is the number of class members.
        -: 2572: *
        -: 2573: * Returned is the number of classes.
        -: 2574: */
        -: 2575:
        2: 2576:int cre8ecs( fwd, bck, num )
        -: 2577:int fwd[], bck[], num;
        -: 2578:	{
        -: 2579:	int i, j, numcl;
        -: 2580:
        2: 2581:	numcl = 0;
        -: 2582:
        -: 2583:	/* Create equivalence class numbers.  From now on, ABS( bck(x) )
        -: 2584:	 * is the equivalence class number for object x.  If bck(x)
        -: 2585:	 * is positive, then x is the representative of its equivalence
        -: 2586:	 * class.
        -: 2587:	 */
      275: 2588:	for ( i = 1; i <= num; ++i )
      273: 2589:		if ( bck[i] == NIL )
        -: 2590:			{
       19: 2591:			bck[i] = ++numcl;
      273: 2592:			for ( j = fwd[i]; j != NIL; j = fwd[j] )
      254: 2593:				bck[j] = -numcl;
        -: 2594:			}
        -: 2595:
        2: 2596:	return numcl;
        -: 2597:	}
        -: 2598:
        -: 2599:
        -: 2600:/* mkeccl - update equivalence classes based on character class xtions
        -: 2601: *
        -: 2602: * synopsis
        -: 2603: *    Char ccls[];
        -: 2604: *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
        -: 2605: *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
        -: 2606: *			int llsiz, int NUL_mapping );
        -: 2607: *
        -: 2608: * ccls contains the elements of the character class, lenccl is the
        -: 2609: * number of elements in the ccl, fwd is the forward link-list of equivalent
        -: 2610: * characters, bck is the backward link-list, and llsiz size of the link-list.
        -: 2611: *
        -: 2612: * NUL_mapping is the value which NUL (0) should be mapped to.
        -: 2613: */
        -: 2614:
        8: 2615:void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
        -: 2616:Char ccls[];
        -: 2617:int lenccl, fwd[], bck[], llsiz, NUL_mapping;
        -: 2618:	{
        -: 2619:	int cclp, oldec, newec;
        -: 2620:	int cclm, i, j;
        -: 2621:	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */
        -: 2622:
        -: 2623:	/* Note that it doesn't matter whether or not the character class is
        -: 2624:	 * negated.  The same results will be obtained in either case.
        -: 2625:	 */
        -: 2626:
        8: 2627:	cclp = 0;
        -: 2628:
       22: 2629:	while ( cclp < lenccl )
        -: 2630:		{
        6: 2631:		cclm = ccls[cclp];
        -: 2632:
        6: 2633:		if ( NUL_mapping && cclm == 0 )
    #####: 2634:			cclm = NUL_mapping;
        -: 2635:
        6: 2636:		oldec = bck[cclm];
        6: 2637:		newec = cclm;
        -: 2638:
        6: 2639:		j = cclp + 1;
        -: 2640:
      183: 2641:		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
        -: 2642:			{ /* look for the symbol in the character class */
      184: 2643:			for ( ; j < lenccl; ++j )
        -: 2644:				{
        -: 2645:				register int ccl_char;
        -: 2646:
       19: 2647:				if ( NUL_mapping && ccls[j] == 0 )
    #####: 2648:					ccl_char = NUL_mapping;
        -: 2649:				else
       19: 2650:					ccl_char = ccls[j];
        -: 2651:
       19: 2652:				if ( ccl_char > i )
        4: 2653:					break;
        -: 2654:
       15: 2655:				if ( ccl_char == i && ! cclflags[j] )
        -: 2656:					{
        -: 2657:					/* We found an old companion of cclm
        -: 2658:					 * in the ccl.  Link it into the new
        -: 2659:					 * equivalence class and flag it as
        -: 2660:					 * having been processed.
        -: 2661:					 */
        -: 2662:
        8: 2663:					bck[i] = newec;
        -: 2664:#ifndef F_A02
        8: 2665:					fwd[newec] = i;
        -: 2666:#else
        -: 2667:					fwd[ 0 * newec] = i;
        -: 2668:#endif
        8: 2669:					newec = i;
        -: 2670:					/* Set flag so we don't reprocess. */
        8: 2671:					cclflags[j] = 1;
        -: 2672:
        -: 2673:					/* Get next equivalence class member. */
        -: 2674:					/* continue 2 */
        8: 2675:					goto next_pt;
        -: 2676:					}
        -: 2677:				}
        -: 2678:
        -: 2679:			/* Symbol isn't in character class.  Put it in the old
        -: 2680:			 * equivalence class.
        -: 2681:			 */
        -: 2682:
      169: 2683:			bck[i] = oldec;
        -: 2684:
        -: 2685:#ifndef F_B43
      169: 2686:			if ( oldec != NIL )
        -: 2687:#else
        -: 2688:			if ( oldec = NIL )
        -: 2689:#endif
      169: 2690:				fwd[oldec] = i;
        -: 2691:
      169: 2692:			oldec = i;
        -: 2693:
        -: 2694:			next_pt: ;
        -: 2695:			}
        -: 2696:
        6: 2697:		if ( bck[cclm] != NIL || oldec != bck[cclm] )
        -: 2698:			{
        6: 2699:			bck[cclm] = NIL;
        6: 2700:			fwd[oldec] = NIL;
        -: 2701:			}
        -: 2702:
        6: 2703:		fwd[newec] = NIL;
        -: 2704:
        -: 2705:		/* Find next ccl member to process. */
        -: 2706:
       14: 2707:		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
        -: 2708:			{
        -: 2709:			/* Reset "doesn't need processing" flag. */
        -: 2710:#ifndef F_A27
        8: 2711:			cclflags[cclp] = 0;
        -: 2712:#else
        -: 2713:			cclflags[ -1 + cclp] = 0;
        -: 2714:#endif
        -: 2715:			}
        -: 2716:		}
        8: 2717:	}
        -: 2718:
        -: 2719:
        -: 2720:/* mkechar - create equivalence class for single character */
        -: 2721:
       46: 2722:void mkechar( tch, fwd, bck )
        -: 2723:int tch, fwd[], bck[];
        -: 2724:	{
        -: 2725:	/* If until now the character has been a proper subset of
        -: 2726:	 * an equivalence class, break it away to create a new ec
        -: 2727:	 */
        -: 2728:
       46: 2729:	if ( fwd[tch] != NIL )
       38: 2730:		bck[fwd[tch]] = bck[tch];
        -: 2731:
       46: 2732:	if ( bck[tch] != NIL )
       41: 2733:		fwd[bck[tch]] = fwd[tch];
        -: 2734:
       46: 2735:	fwd[tch] = NIL;
       46: 2736:	bck[tch] = NIL;
       46: 2737:	}
        -: 2738:/* gen - actual generation (writing) of flex scanners */
        -: 2739:
        -: 2740:/*-
        -: 2741: * Copyright (c) 1990 The Regents of the University of California.
        -: 2742: * All rights reserved.
        -: 2743: *
        -: 2744: * This code is derived from software contributed to Berkeley by
        -: 2745: * Vern Paxson.
        -: 2746: * 
        -: 2747: * The United States Government has rights in this work pursuant
        -: 2748: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2749: * Department of Energy and the University of California.
        -: 2750: *
        -: 2751: * Redistribution and use in source and binary forms are permitted provided
        -: 2752: * that: (1) source distributions retain this entire copyright notice and
        -: 2753: * comment, and (2) distributions including binaries display the following
        -: 2754: * acknowledgement:  ``This product includes software developed by the
        -: 2755: * University of California, Berkeley and its contributors'' in the
        -: 2756: * documentation or other materials provided with the distribution and in
        -: 2757: * all advertising materials mentioning features or use of this software.
        -: 2758: * Neither the name of the University nor the names of its contributors may
        -: 2759: * be used to endorse or promote products derived from this software without
        -: 2760: * specific prior written permission.
        -: 2761: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2762: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2763: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2764: */
        -: 2765:
        -: 2766:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 2767:
        -: 2768:
        -: 2769:
        -: 2770:/* declare functions that have forward references */
        -: 2771:
        -: 2772:void gen_next_state PROTO((int));
        -: 2773:void genecs PROTO((void));
        -: 2774:void indent_put2s PROTO((char [], char []));
        -: 2775:void indent_puts PROTO((char []));
        -: 2776:
        -: 2777:
        -: 2778:static int indent_level = 0; /* each level is 8 spaces */
        -: 2779:
        -: 2780:#define indent_up() (++indent_level)
        -: 2781:#define indent_down() (--indent_level)
        -: 2782:#define set_indent(indent_val) indent_level = indent_val
        -: 2783:
        -: 2784:/* Almost everything is done in terms of arrays starting at 1, so provide
        -: 2785: * a null entry for the zero element of all C arrays.  (The exception
        -: 2786: * to this is that the fast table representation generally uses the
        -: 2787: * 0 elements of its arrays, too.)
        -: 2788: */
        -: 2789:static char C_int_decl[] = "static yyconst int %s[%d] =\n    {   0,\n";
        -: 2790:static char C_short_decl[] = "static yyconst short int %s[%d] =\n    {   0,\n";
        -: 2791:static char C_long_decl[] = "static yyconst long int %s[%d] =\n    {   0,\n";
        -: 2792:static char C_state_decl[] =
        -: 2793:	"static yyconst yy_state_type %s[%d] =\n    {   0,\n";
        -: 2794:
        -: 2795:
        -: 2796:/* Indent to the current level. */
        -: 2797:
       95: 2798:void do_indent()
        -: 2799:	{
       95: 2800:	register int i = indent_level * 8;
        -: 2801:
      420: 2802:	while ( i >= 8 )
        -: 2803:		{
      230: 2804:		outc( '\t' );
      230: 2805:		i -= 8;
        -: 2806:		}
        -: 2807:
      190: 2808:	while ( i > 0 )
        -: 2809:		{
    #####: 2810:		outc( ' ' );
    #####: 2811:		--i;
        -: 2812:		}
       95: 2813:	}
        -: 2814:
        -: 2815:
        -: 2816:/* Generate the code to keep backing-up information. */
        -: 2817:
        3: 2818:void gen_backing_up()
        -: 2819:	{
        3: 2820:	if ( reject || num_backing_up == 0 )
    #####: 2821:		return;
        -: 2822:
        3: 2823:	if ( fullspd )
    #####: 2824:		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
        -: 2825:	else
        3: 2826:		indent_puts( "if ( yy_accept[yy_current_state] )" );
        -: 2827:
        3: 2828:	indent_up();
        3: 2829:	indent_puts( "{" );
        3: 2830:	indent_puts( "yy_last_accepting_state = yy_current_state;" );
        3: 2831:	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
        3: 2832:	indent_puts( "}" );
        3: 2833:	indent_down();
        -: 2834:	}
        -: 2835:
        -: 2836:
        -: 2837:/* Generate the code to perform the backing up. */
        -: 2838:
        1: 2839:void gen_bu_action()
        -: 2840:	{
        1: 2841:	if ( reject || num_backing_up == 0 )
    #####: 2842:		return;
        -: 2843:
        1: 2844:	set_indent( 3 );
        -: 2845:
        1: 2846:	indent_puts( "case 0: /* must back up */" );
        1: 2847:	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
        1: 2848:	indent_puts( "*yy_cp = yy_hold_char;" );
        -: 2849:
        1: 2850:	if ( fullspd || fulltbl )
    #####: 2851:		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
        -: 2852:	else
        -: 2853:		/* Backing-up info for compressed tables is taken \after/
        -: 2854:		 * yy_cp has been incremented for the next state.
        -: 2855:		 */
        1: 2856:		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
        -: 2857:
        -: 2858:#ifndef F_B06
        1: 2859:	indent_puts( "yy_current_state = yy_last_accepting_state;" );
        -: 2860:#else
        -: 2861:	indent_puts (!  "yy_current_state = yy_last_accepting_state;" );
        -: 2862:#endif
        1: 2863:	indent_puts( "goto yy_find_action;" );
        1: 2864:	outc( '\n' );
        -: 2865:
        1: 2866:	set_indent( 0 );
        -: 2867:	}
        -: 2868:
        -: 2869:
        -: 2870:/* genctbl - generates full speed compressed transition table */
        -: 2871:
    #####: 2872:void genctbl()
        -: 2873:	{
        -: 2874:	register int i;
    #####: 2875:	int end_of_buffer_action = num_rules + 1;
        -: 2876:
        -: 2877:	/* Table of verify for transition and offset to next state. */
    #####: 2878:	out_dec( "static yyconst struct yy_trans_info yy_transition[%d] =\n",
    #####: 2879:		tblend + numecs + 1 );
    #####: 2880:	outn( "    {" );
        -: 2881:
        -: 2882:	/* We want the transition to be represented as the offset to the
        -: 2883:	 * next state, not the actual state number, which is what it currently
        -: 2884:	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
        -: 2885:	 * just the difference between the starting points of the two involved
        -: 2886:	 * states (to - from).
        -: 2887:	 *
        -: 2888:	 * First, though, we need to find some way to put in our end-of-buffer
        -: 2889:	 * flags and states.  We do this by making a state with absolutely no
        -: 2890:	 * transitions.  We put it at the end of the table.
        -: 2891:	 */
        -: 2892:
        -: 2893:	/* We need to have room in nxt/chk for two more slots: One for the
        -: 2894:	 * action and one for the end-of-buffer transition.  We now *assume*
        -: 2895:	 * that we're guaranteed the only character we'll try to index this
        -: 2896:	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
        -: 2897:	 * there's room for jam entries for other characters.
        -: 2898:	 */
        -: 2899:
    #####: 2900:	while ( tblend + 2 >= current_max_xpairs )
    #####: 2901:		expand_nxt_chk();
        -: 2902:
    #####: 2903:	while ( lastdfa + 1 >= current_max_dfas )
    #####: 2904:		increase_max_dfas();
        -: 2905:
    #####: 2906:	base[lastdfa + 1] = tblend + 2;
    #####: 2907:	nxt[tblend + 1] = end_of_buffer_action;
    #####: 2908:	chk[tblend + 1] = numecs + 1;
    #####: 2909:	chk[tblend + 2] = 1; /* anything but EOB */
        -: 2910:
        -: 2911:	/* So that "make test" won't show arb. differences. */
    #####: 2912:	nxt[tblend + 2] = 0;
        -: 2913:
        -: 2914:	/* Make sure every state has an end-of-buffer transition and an
        -: 2915:	 * action #.
        -: 2916:	 */
    #####: 2917:	for ( i = 0; i <= lastdfa; ++i )
        -: 2918:		{
    #####: 2919:		int anum = dfaacc[i].dfaacc_state;
    #####: 2920:		int offset = base[i];
        -: 2921:
    #####: 2922:		chk[offset] = EOB_POSITION;
    #####: 2923:		chk[offset - 1] = ACTION_POSITION;
    #####: 2924:		nxt[offset - 1] = anum;	/* action number */
        -: 2925:		}
        -: 2926:
    #####: 2927:	for ( i = 0; i <= tblend; ++i )
        -: 2928:		{
    #####: 2929:		if ( chk[i] == EOB_POSITION )
    #####: 2930:			transition_struct_out( 0, base[lastdfa + 1] - i );
        -: 2931:
    #####: 2932:		else if ( chk[i] == ACTION_POSITION )
    #####: 2933:			transition_struct_out( 0, nxt[i] );
        -: 2934:
    #####: 2935:		else if ( chk[i] > numecs || chk[i] == 0 )
    #####: 2936:			transition_struct_out( 0, 0 );	/* unused slot */
        -: 2937:
        -: 2938:		else	/* verify, transition */
    #####: 2939:			transition_struct_out( chk[i],
    #####: 2940:						base[nxt[i]] - (i - chk[i]) );
        -: 2941:		}
        -: 2942:
        -: 2943:
        -: 2944:	/* Here's the final, end-of-buffer state. */
    #####: 2945:	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
    #####: 2946:	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
        -: 2947:
    #####: 2948:	outn( "    };\n" );
        -: 2949:
        -: 2950:	/* Table of pointers to start states. */
    #####: 2951:	out_dec(
        -: 2952:	"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n",
    #####: 2953:		lastsc * 2 + 1 );
    #####: 2954:	outn( "    {" );	/* } so vi doesn't get confused */
        -: 2955:
    #####: 2956:	for ( i = 0; i <= lastsc * 2; ++i )
    #####: 2957:		out_dec( "    &yy_transition[%d],\n", base[i] );
        -: 2958:
    #####: 2959:	dataend();
        -: 2960:
    #####: 2961:	if ( useecs )
    #####: 2962:		genecs();
    #####: 2963:	}
        -: 2964:
        -: 2965:
        -: 2966:/* Generate equivalence-class tables. */
        -: 2967:
        1: 2968:void genecs()
        -: 2969:	{
        -: 2970:	register int i, j;
        -: 2971:	int numrows;
        -: 2972:
        1: 2973:	out_str_dec( C_int_decl, "yy_ec", csize );
        -: 2974:
      256: 2975:	for ( i = 1; i < csize; ++i )
        -: 2976:		{
      255: 2977:		if ( caseins && (i >= 'A') && (i <= 'Z') )
    #####: 2978:			ecgroup[i] = ecgroup[clower( i )];
        -: 2979:
      255: 2980:		ecgroup[i] = ABS( ecgroup[i] );
      255: 2981:		mkdata( ecgroup[i] );
        -: 2982:		}
        -: 2983:
        1: 2984:	dataend();
        -: 2985:
        1: 2986:	if ( trace )
        -: 2987:		{
    #####: 2988:		fputs( _( "\n\nEquivalence Classes:\n\n" ), err );
        -: 2989:
    #####: 2990:		numrows = csize / 8;
        -: 2991:
    #####: 2992:		for ( j = 0; j < numrows; ++j )
        -: 2993:			{
    #####: 2994:			for ( i = j; i < csize; i = i + numrows )
        -: 2995:				{
    #####: 2996:				fprintf( err, "%4s = %-2d",
        -: 2997:					readable_form( i ), ecgroup[i] );
        -: 2998:
    #####: 2999:				putc( ' ', err );
        -: 3000:				}
        -: 3001:
    #####: 3002:			putc( '\n', err );
        -: 3003:			}
        -: 3004:		}
        1: 3005:	}
        -: 3006:
        -: 3007:
        -: 3008:/* Generate the code to find the action number. */
        -: 3009:
        1: 3010:void gen_find_action()
        -: 3011:	{
        1: 3012:	if ( fullspd )
    #####: 3013:		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
        -: 3014:
        1: 3015:	else if ( fulltbl )
    #####: 3016:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
        -: 3017:
        1: 3018:	else if ( reject )
        -: 3019:		{
        -: 3020:#ifndef F_A07
    #####: 3021:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
        -: 3022:#else
        -: 3023:		indent_puts( "yy_current_state = 0 ;//*--yy_state_ptr;" );
        -: 3024:#endif
    #####: 3025:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
        -: 3026:
        -: 3027:#ifndef F_B39
    #####: 3028:		outn(
        -: 3029:#else
        -: 3030:		outn (! 
        -: 3031:#endif
        -: 3032:		"find_rule: /* we branch to this label when backing up */" );
        -: 3033:
    #####: 3034:		indent_puts(
        -: 3035:		"for ( ; ; ) /* until we find what rule we matched */" );
        -: 3036:
    #####: 3037:		indent_up();
        -: 3038:
    #####: 3039:		indent_puts( "{" );
        -: 3040:
    #####: 3041:		indent_puts(
        -: 3042:		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
    #####: 3043:		indent_up();
    #####: 3044:		indent_puts( "{" );
    #####: 3045:		indent_puts( "yy_act = yy_acclist[yy_lp];" );
        -: 3046:
    #####: 3047:		if ( variable_trailing_context_rules )
        -: 3048:			{
    #####: 3049:			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
    #####: 3050:			indent_puts( "     yy_looking_for_trail_begin )" );
    #####: 3051:			indent_up();
    #####: 3052:			indent_puts( "{" );
        -: 3053:
    #####: 3054:			indent_puts(
        -: 3055:				"if ( yy_act == yy_looking_for_trail_begin )" );
    #####: 3056:			indent_up();
    #####: 3057:			indent_puts( "{" );
    #####: 3058:			indent_puts( "yy_looking_for_trail_begin = 0;" );
    #####: 3059:			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
    #####: 3060:			indent_puts( "break;" );
    #####: 3061:			indent_puts( "}" );
    #####: 3062:			indent_down();
        -: 3063:
    #####: 3064:			indent_puts( "}" );
    #####: 3065:			indent_down();
        -: 3066:
    #####: 3067:			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
    #####: 3068:			indent_up();
    #####: 3069:			indent_puts( "{" );
    #####: 3070:			indent_puts(
        -: 3071:		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
    #####: 3072:			indent_puts(
        -: 3073:		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
        -: 3074:
    #####: 3075:			if ( real_reject )
        -: 3076:				{
        -: 3077:				/* Remember matched text in case we back up
        -: 3078:				 * due to REJECT.
        -: 3079:				 */
    #####: 3080:				indent_puts( "yy_full_match = yy_cp;" );
    #####: 3081:				indent_puts( "yy_full_state = yy_state_ptr;" );
    #####: 3082:				indent_puts( "yy_full_lp = yy_lp;" );
        -: 3083:				}
        -: 3084:
    #####: 3085:			indent_puts( "}" );
    #####: 3086:			indent_down();
        -: 3087:
    #####: 3088:			indent_puts( "else" );
    #####: 3089:			indent_up();
    #####: 3090:			indent_puts( "{" );
    #####: 3091:			indent_puts( "yy_full_match = yy_cp;" );
    #####: 3092:			indent_puts( "yy_full_state = yy_state_ptr;" );
    #####: 3093:			indent_puts( "yy_full_lp = yy_lp;" );
    #####: 3094:			indent_puts( "break;" );
    #####: 3095:			indent_puts( "}" );
    #####: 3096:			indent_down();
        -: 3097:
    #####: 3098:			indent_puts( "++yy_lp;" );
    #####: 3099:			indent_puts( "goto find_rule;" );
        -: 3100:			}
        -: 3101:
        -: 3102:		else
        -: 3103:			{
        -: 3104:			/* Remember matched text in case we back up due to
        -: 3105:			 * trailing context plus REJECT.
        -: 3106:			 */
    #####: 3107:			indent_up();
    #####: 3108:			indent_puts( "{" );
    #####: 3109:			indent_puts( "yy_full_match = yy_cp;" );
        -: 3110:#ifndef F_B30
    #####: 3111:			indent_puts( "break;" );
        -: 3112:#else
        -: 3113:			indent_puts (!  "break;" );
        -: 3114:#endif
    #####: 3115:			indent_puts( "}" );
    #####: 3116:			indent_down();
        -: 3117:			}
        -: 3118:
    #####: 3119:		indent_puts( "}" );
    #####: 3120:		indent_down();
        -: 3121:
    #####: 3122:		indent_puts( "--yy_cp;" );
        -: 3123:
        -: 3124:		/* We could consolidate the following two lines with those at
        -: 3125:		 * the beginning, but at the cost of complaints that we're
        -: 3126:		 * branching inside a loop.
        -: 3127:		 */
    #####: 3128:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
        -: 3129:#ifndef F_A17
    #####: 3130:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
        -: 3131:#else
        -: 3132:		indent_puts( "yy_lp > yy_accept[yy_current_state];" );
        -: 3133:#endif
        -: 3134:
    #####: 3135:		indent_puts( "}" );
        -: 3136:
    #####: 3137:		indent_down();
        -: 3138:		}
        -: 3139:
        -: 3140:#ifndef F_B15
        -: 3141:	else
        -: 3142:#else
        -: 3143:
        -: 3144:#endif
        -: 3145:		{ /* compressed */
        1: 3146:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
        -: 3147:
        1: 3148:		if ( interactive && ! reject )
        -: 3149:			{
        -: 3150:			/* Do the guaranteed-needed backing up to figure out
        -: 3151:			 * the match.
        -: 3152:			 */
        1: 3153:			indent_puts( "if ( yy_act == 0 )" );
        1: 3154:			indent_up();
        1: 3155:			indent_puts( "{ /* have to back up */" );
        1: 3156:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
        1: 3157:			indent_puts(
        -: 3158:				"yy_current_state = yy_last_accepting_state;" );
        1: 3159:			indent_puts( "yy_act = yy_accept[yy_current_state];" );
        1: 3160:			indent_puts( "}" );
        1: 3161:			indent_down();
        -: 3162:			}
        -: 3163:		}
        1: 3164:	}
        -: 3165:
        -: 3166:
        -: 3167:/* genftbl - generate full transition table */
        -: 3168:
    #####: 3169:void genftbl()
        -: 3170:	{
        -: 3171:	register int i;
    #####: 3172:	int end_of_buffer_action = num_rules + 1;
        -: 3173:
    #####: 3174:	out_str_dec( long_align ? C_long_decl : C_short_decl,
        -: 3175:		"yy_accept", lastdfa + 1 );
        -: 3176:
    #####: 3177:	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3178:
    #####: 3179:	for ( i = 1; i <= lastdfa; ++i )
        -: 3180:		{
    #####: 3181:		register int anum = dfaacc[i].dfaacc_state;
        -: 3182:
    #####: 3183:		mkdata( anum );
        -: 3184:
    #####: 3185:		if ( trace && anum )
    #####: 3186:			fprintf( err, _( "state # %d accepts: [%d]\n" ),
        -: 3187:				i, anum );
        -: 3188:		}
        -: 3189:
    #####: 3190:	dataend();
        -: 3191:
    #####: 3192:	if ( useecs )
    #####: 3193:		genecs();
        -: 3194:
        -: 3195:	/* Don't have to dump the actual full table entries - they were
        -: 3196:	 * created on-the-fly.
        -: 3197:	 */
    #####: 3198:	}
        -: 3199:
        -: 3200:
        -: 3201:/* Generate the code to find the next compressed-table state. */
        -: 3202:
        3: 3203:void gen_next_compressed_state( char_map )
        -: 3204:char *char_map;
        -: 3205:	{
        3: 3206:	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
        -: 3207:
        -: 3208:	/* Save the backing-up info \before/ computing the next state
        -: 3209:	 * because we always compute one more state than needed - we
        -: 3210:	 * always proceed until we reach a jam state
        -: 3211:	 */
        3: 3212:	gen_backing_up();
        -: 3213:
        3: 3214:	indent_puts(
        -: 3215:"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
        3: 3216:	indent_up();
        3: 3217:	indent_puts( "{" );
        3: 3218:	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
        -: 3219:
        3: 3220:	if ( usemecs )
        -: 3221:		{
        -: 3222:		/* We've arrange it so that templates are never chained
        -: 3223:		 * to one another.  This means we can afford to make a
        -: 3224:		 * very simple test to see if we need to convert to
        -: 3225:		 * yy_c's meta-equivalence class without worrying
        -: 3226:		 * about erroneously looking up the meta-equivalence
        -: 3227:		 * class twice
        -: 3228:		 */
        3: 3229:		do_indent();
        -: 3230:
        -: 3231:		/* lastdfa + 2 is the beginning of the templates */
        3: 3232:		out_dec( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
        -: 3233:
        3: 3234:		indent_up();
        3: 3235:		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
        3: 3236:		indent_down();
        -: 3237:		}
        -: 3238:
        3: 3239:	indent_puts( "}" );
        3: 3240:	indent_down();
        -: 3241:
        3: 3242:	indent_puts(
        -: 3243:"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
        3: 3244:	}
        -: 3245:
        -: 3246:
        -: 3247:/* Generate the code to find the next match. */
        -: 3248:
        1: 3249:void gen_next_match()
        -: 3250:	{
        -: 3251:	/* NOTE - changes in here should be reflected in gen_next_state() and
        -: 3252:	 * gen_NUL_trans().
        -: 3253:	 */
        2: 3254:	char *char_map = useecs ?
        1: 3255:				"yy_ec[YY_SC_TO_UI(*yy_cp)]" :
        -: 3256:				"YY_SC_TO_UI(*yy_cp)";
        -: 3257:
        2: 3258:	char *char_map_2 = useecs ?
        1: 3259:				"yy_ec[YY_SC_TO_UI(*++yy_cp)]" :
        -: 3260:				"YY_SC_TO_UI(*++yy_cp)";
        -: 3261:
        1: 3262:	if ( fulltbl )
        -: 3263:		{
    #####: 3264:		indent_put2s(
        -: 3265:	"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
        -: 3266:				char_map );
        -: 3267:
    #####: 3268:		indent_up();
        -: 3269:
    #####: 3270:		if ( num_backing_up > 0 )
        -: 3271:			{
    #####: 3272:			indent_puts( "{" );	/* } for vi */
    #####: 3273:			gen_backing_up();
    #####: 3274:			outc( '\n' );
        -: 3275:			}
        -: 3276:
    #####: 3277:		indent_puts( "++yy_cp;" );
        -: 3278:
    #####: 3279:		if ( num_backing_up > 0 )
        -: 3280:			/* { for vi */
    #####: 3281:			indent_puts( "}" );
        -: 3282:
    #####: 3283:		indent_down();
        -: 3284:
    #####: 3285:		outc( '\n' );
    #####: 3286:		indent_puts( "yy_current_state = -yy_current_state;" );
        -: 3287:		}
        -: 3288:
        1: 3289:	else if ( fullspd )
        -: 3290:		{
    #####: 3291:		indent_puts( "{" );	/* } for vi */
    #####: 3292:		indent_puts(
        -: 3293:		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
    #####: 3294:		indent_puts( "register YY_CHAR yy_c;\n" );
    #####: 3295:		indent_put2s( "for ( yy_c = %s;", char_map );
    #####: 3296:		indent_puts(
        -: 3297:	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
    #####: 3298:		indent_puts( "yy_verify == yy_c;" );
    #####: 3299:		indent_put2s( "      yy_c = %s )", char_map_2 );
        -: 3300:
    #####: 3301:		indent_up();
        -: 3302:
    #####: 3303:		if ( num_backing_up > 0 )
    #####: 3304:			indent_puts( "{" );	/* } for vi */
        -: 3305:
    #####: 3306:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
        -: 3307:
        -: 3308:#ifndef F_B28
    #####: 3309:		if ( num_backing_up > 0 )
        -: 3310:#else
        -: 3311:		if  (!  num_backing_up > 0 )
        -: 3312:#endif
        -: 3313:			{
    #####: 3314:			outc( '\n' );
    #####: 3315:			gen_backing_up();	/* { for vi */
    #####: 3316:			indent_puts( "}" );
        -: 3317:			}
        -: 3318:
    #####: 3319:		indent_down();	/* { for vi */
    #####: 3320:		indent_puts( "}" );
        -: 3321:		}
        -: 3322:
        -: 3323:	else
        -: 3324:		{ /* compressed */
        1: 3325:		indent_puts( "do" );
        -: 3326:
        1: 3327:		indent_up();
        1: 3328:		indent_puts( "{" );	/* } for vi */
        -: 3329:
        1: 3330:		gen_next_state( false );
        -: 3331:
        1: 3332:		indent_puts( "++yy_cp;" );
        -: 3333:
        -: 3334:		/* { for vi */
        1: 3335:		indent_puts( "}" );
        1: 3336:		indent_down();
        -: 3337:
        1: 3338:		do_indent();
        -: 3339:
        1: 3340:		if ( interactive )
        1: 3341:			out_dec( "while ( yy_base[yy_current_state] != %d );\n",
        -: 3342:				jambase );
        -: 3343:		else
    #####: 3344:			out_dec( "while ( yy_current_state != %d );\n",
        -: 3345:				jamstate );
        -: 3346:
        1: 3347:		if ( ! reject && ! interactive )
        -: 3348:			{
        -: 3349:			/* Do the guaranteed-needed backing up to figure out
        -: 3350:			 * the match.
        -: 3351:			 */
    #####: 3352:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
    #####: 3353:			indent_puts(
        -: 3354:				"yy_current_state = yy_last_accepting_state;" );
        -: 3355:			}
        -: 3356:		}
        1: 3357:	}
        -: 3358:
        -: 3359:
        -: 3360:/* Generate the code to find the next state. */
        -: 3361:
        2: 3362:void gen_next_state( worry_about_NULs )
        -: 3363:int worry_about_NULs;
        -: 3364:	{ /* NOTE - changes in here should be reflected in gen_next_match() */
        -: 3365:	char char_map[256];
        -: 3366:
        2: 3367:	if ( worry_about_NULs && ! nultrans )
        -: 3368:		{
        -: 3369:#ifndef F_B03
        2: 3370:		if ( useecs )
        -: 3371:#else
        -: 3372:		if  (!  useecs )
        -: 3373:#endif
        1: 3374:			(void) sprintf( char_map,
        -: 3375:				"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
        -: 3376:					NUL_ec );
        -: 3377:		else
    #####: 3378:			(void) sprintf( char_map,
        -: 3379:				"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)", NUL_ec );
        -: 3380:		}
        -: 3381:
        -: 3382:#ifndef F_B12
        -: 3383:	else
        -: 3384:#else
        -: 3385:
        -: 3386:#endif
        1: 3387:		strcpy( char_map, useecs ?
        -: 3388:			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)" );
        -: 3389:
        2: 3390:	if ( worry_about_NULs && nultrans )
        -: 3391:		{
    #####: 3392:		if ( ! fulltbl && ! fullspd )
        -: 3393:			/* Compressed tables back up *before* they match. */
    #####: 3394:			gen_backing_up();
        -: 3395:
    #####: 3396:		indent_puts( "if ( *yy_cp )" );
    #####: 3397:		indent_up();
    #####: 3398:		indent_puts( "{" );	/* } for vi */
        -: 3399:		}
        -: 3400:
        2: 3401:	if ( fulltbl )
    #####: 3402:		indent_put2s(
        -: 3403:			"yy_current_state = yy_nxt[yy_current_state][%s];", 
        -: 3404:				char_map );
        -: 3405:
        2: 3406:	else if ( fullspd )
    #####: 3407:		indent_put2s(
        -: 3408:			"yy_current_state += yy_current_state[%s].yy_nxt;",
        -: 3409:				char_map );
        -: 3410:
        -: 3411:	else
        2: 3412:		gen_next_compressed_state( char_map );
        -: 3413:
        2: 3414:	if ( worry_about_NULs && nultrans )
        -: 3415:		{
        -: 3416:		/* { for vi */
    #####: 3417:		indent_puts( "}" );
    #####: 3418:		indent_down();
    #####: 3419:		indent_puts( "else" );
    #####: 3420:		indent_up();
    #####: 3421:		indent_puts(
        -: 3422:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
    #####: 3423:		indent_down();
        -: 3424:		}
        -: 3425:
        2: 3426:	if ( fullspd || fulltbl )
    #####: 3427:		gen_backing_up();
        -: 3428:
        2: 3429:	if ( reject )
    #####: 3430:		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
        2: 3431:	}
        -: 3432:
        -: 3433:
        -: 3434:/* Generate the code to make a NUL transition. */
        -: 3435:
        1: 3436:void gen_NUL_trans()
        -: 3437:	{ /* NOTE - changes in here should be reflected in gen_next_match() */
        -: 3438:	/* Only generate a definition for "yy_cp" if we'll generate code
        -: 3439:	 * that uses it.  Otherwise lint and the like complain.
        -: 3440:	 */
        -: 3441:#ifndef F_A15
        1: 3442:	int need_backing_up = (num_backing_up > 0 && ! reject);
        -: 3443:#else
        -: 3444:	int need_backing_up = (num_backing_up > 0 && ! reject*0);
        -: 3445:#endif
        -: 3446:
        -: 3447:#ifndef F_B04
        1: 3448:	if ( need_backing_up && (! nultrans || fullspd || fulltbl) )
        -: 3449:#else
        -: 3450:	if ( 1 ||  need_backing_up && (! nultrans || fullspd || fulltbl) )s
        -: 3451:#endif
        -: 3452:		/* We're going to need yy_cp lying around for the call
        -: 3453:		 * below to gen_backing_up().
        -: 3454:		 */
        -: 3455:#ifndef F_B18
        1: 3456:		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
        -: 3457:#else
        -: 3458:		indent_puts (!  "register char *yy_cp = yy_c_buf_p;" );
        -: 3459:#endif
        -: 3460:
        1: 3461:	outc( '\n' );
        -: 3462:
        1: 3463:	if ( nultrans )
        -: 3464:		{
        -: 3465:#ifndef F_B01
    #####: 3466:		indent_puts(
        -: 3467:#else
        -: 3468:		indent_puts (! 
        -: 3469:#endif
        -: 3470:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
    #####: 3471:		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
        -: 3472:		}
        -: 3473:
        1: 3474:	else if ( fulltbl )
        -: 3475:		{
    #####: 3476:		do_indent();
    #####: 3477:		out_dec( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
        -: 3478:			NUL_ec );
    #####: 3479:		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
        -: 3480:		}
        -: 3481:
        1: 3482:	else if ( fullspd )
        -: 3483:		{
    #####: 3484:		do_indent();
    #####: 3485:		out_dec( "register int yy_c = %d;\n", NUL_ec );
        -: 3486:
    #####: 3487:		indent_puts(
        -: 3488:		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
    #####: 3489:		indent_puts(
        -: 3490:		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
    #####: 3491:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
        -: 3492:
    #####: 3493:		indent_puts(
        -: 3494:			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
        -: 3495:		}
        -: 3496:
        -: 3497:	else
        -: 3498:		{
        -: 3499:		char NUL_ec_str[20];
        -: 3500:
        1: 3501:		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
        1: 3502:		gen_next_compressed_state( NUL_ec_str );
        -: 3503:
        1: 3504:		do_indent();
        1: 3505:		out_dec( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
        -: 3506:
        1: 3507:		if ( reject )
        -: 3508:			{
        -: 3509:			/* Only stack this state if it's a transition we
        -: 3510:			 * actually make.  If we stack it on a jam, then
        -: 3511:			 * the state stack and yy_c_buf_p get out of sync.
        -: 3512:			 */
    #####: 3513:			indent_puts( "if ( ! yy_is_jam )" );
    #####: 3514:			indent_up();
    #####: 3515:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
    #####: 3516:			indent_down();
        -: 3517:			}
        -: 3518:		}
        -: 3519:
        -: 3520:	/* If we've entered an accepting state, back up; note that
        -: 3521:	 * compressed tables have *already* done such backing up, so
        -: 3522:	 * we needn't bother with it again.
        -: 3523:	 */
        1: 3524:	if ( need_backing_up && (fullspd || fulltbl) )
        -: 3525:		{
    #####: 3526:		outc( '\n' );
    #####: 3527:		indent_puts( "if ( ! yy_is_jam )" );
    #####: 3528:		indent_up();
    #####: 3529:		indent_puts( "{" );
    #####: 3530:		gen_backing_up();
    #####: 3531:		indent_puts( "}" );
    #####: 3532:		indent_down();
        -: 3533:		}
        1: 3534:	}
        -: 3535:
        -: 3536:
        -: 3537:/* Generate the code to find the start state. */
        -: 3538:
        2: 3539:void gen_start_state()
        -: 3540:	{
        2: 3541:	if ( fullspd )
        -: 3542:		{
        -: 3543:#ifndef F_B11
    #####: 3544:		if ( bol_needed )
        -: 3545:#else
        -: 3546:		if  (!  bol_needed )
        -: 3547:#endif
        -: 3548:			{
    #####: 3549:			indent_puts(
        -: 3550:	"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];" );
        -: 3551:			}
        -: 3552:		else
    #####: 3553:			indent_puts(
        -: 3554:			"yy_current_state = yy_start_state_list[yy_start];" );
        -: 3555:		}
        -: 3556:
        -: 3557:	else
        -: 3558:		{
        2: 3559:		indent_puts( "yy_current_state = yy_start;" );
        -: 3560:
        2: 3561:		if ( bol_needed )
        2: 3562:			indent_puts( "yy_current_state += YY_AT_BOL();" );
        -: 3563:
        -: 3564:#ifndef F_B27
        2: 3565:		if ( reject )
        -: 3566:#else
        -: 3567:		if  (!  reject )
        -: 3568:#endif
        -: 3569:			{
        -: 3570:			/* Set up for storing up states. */
    #####: 3571:			indent_puts( "yy_state_ptr = yy_state_buf;" );
    #####: 3572:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
        -: 3573:			}
        -: 3574:		}
        2: 3575:	}
        -: 3576:
        -: 3577:
        -: 3578:/* gentabs - generate data statements for the transition tables */
        -: 3579:
        1: 3580:void gentabs()
        -: 3581:	{
        -: 3582:	int i, j, k, *accset, nacc, *acc_array, total_states;
        1: 3583:	int end_of_buffer_action = num_rules + 1;
        -: 3584:
        1: 3585:	acc_array = allocate_integer_array( current_max_dfas );
        1: 3586:	nummt = 0;
        -: 3587:
        -: 3588:	/* The compressed table format jams by entering the "jam state",
        -: 3589:	 * losing information about the previous state in the process.
        -: 3590:	 * In order to recover the previous state, we effectively need
        -: 3591:	 * to keep backing-up information.
        -: 3592:	 */
        -: 3593:#ifndef F_A22
        1: 3594:	++num_backing_up;
        -: 3595:#else
        -: 3596:	--num_backing_up;
        -: 3597:#endif
        -: 3598:
        1: 3599:	if ( reject )
        -: 3600:		{
        -: 3601:		/* Write out accepting list and pointer list.
        -: 3602:		 *
        -: 3603:		 * First we generate the "yy_acclist" array.  In the process,
        -: 3604:		 * we compute the indices that will go into the "yy_accept"
        -: 3605:		 * array, and save the indices in the dfaacc array.
        -: 3606:		 */
        -: 3607:		int EOB_accepting_list[2];
        -: 3608:
        -: 3609:		/* Set up accepting structures for the End Of Buffer state. */
    #####: 3610:		EOB_accepting_list[0] = 0;
    #####: 3611:		EOB_accepting_list[1] = end_of_buffer_action;
    #####: 3612:		accsiz[end_of_buffer_state] = 1;
    #####: 3613:		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
        -: 3614:
    #####: 3615:		out_str_dec( long_align ? C_long_decl : C_short_decl,
    #####: 3616:			"yy_acclist", MAX( numas, 1 ) + 1 );
        -: 3617:
    #####: 3618:		j = 1;	/* index into "yy_acclist" array */
        -: 3619:
    #####: 3620:		for ( i = 1; i <= lastdfa; ++i )
        -: 3621:			{
    #####: 3622:			acc_array[i] = j;
        -: 3623:
    #####: 3624:			if ( accsiz[i] != 0 )
        -: 3625:				{
    #####: 3626:				accset = dfaacc[i].dfaacc_set;
    #####: 3627:				nacc = accsiz[i];
        -: 3628:
    #####: 3629:				if ( trace )
    #####: 3630:					fprintf( err,
        -: 3631:						_( "state # %d accepts: " ),
        -: 3632:						i );
        -: 3633:
    #####: 3634:				for ( k = 1; k <= nacc; ++k )
        -: 3635:					{
        -: 3636:#ifndef F_A03
        -: 3637:					int accnum = accset[k];
        -: 3638:#else
    #####: 3639:					int accnum = accset[ 1 + k];
        -: 3640:#endif
        -: 3641:
    #####: 3642:					++j;
        -: 3643:
    #####: 3644:					if ( variable_trailing_context_rules &&
    #####: 3645:					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
    #####: 3646:					   accnum > 0 && accnum <= num_rules &&
    #####: 3647:					  rule_type[accnum] == RULE_VARIABLE )
        -: 3648:						{
        -: 3649:						/* Special hack to flag
        -: 3650:						 * accepting number as part
        -: 3651:						 * of trailing context rule.
        -: 3652:						 */
    #####: 3653:						accnum |= YY_TRAILING_MASK;
        -: 3654:						}
        -: 3655:
    #####: 3656:					mkdata( accnum );
        -: 3657:
    #####: 3658:					if ( trace )
        -: 3659:						{
    #####: 3660:						fprintf( err, "[%d]",
    #####: 3661:							accset[k] );
        -: 3662:
    #####: 3663:						if ( k < nacc )
    #####: 3664:							fputs( ", ", err );
        -: 3665:						else
    #####: 3666:							putc( '\n', err );
        -: 3667:						}
        -: 3668:					}
        -: 3669:				}
        -: 3670:			}
        -: 3671:
        -: 3672:		/* add accepting number for the "jam" state */
    #####: 3673:		acc_array[i] = j;
        -: 3674:
    #####: 3675:		dataend();
        -: 3676:		}
        -: 3677:
        -: 3678:	else
        -: 3679:		{
        1: 3680:		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3681:
       26: 3682:		for ( i = 1; i <= lastdfa; ++i )
       25: 3683:			acc_array[i] = dfaacc[i].dfaacc_state;
        -: 3684:
        -: 3685:		/* add accepting number for jam state */
        1: 3686:		acc_array[i] = 0;
        -: 3687:		}
        -: 3688:
        -: 3689:	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
        -: 3690:	 * pointers into the "yy_acclist" array.  Otherwise it's actual
        -: 3691:	 * accepting numbers.  In either case, we just dump the numbers.
        -: 3692:	 */
        -: 3693:
        -: 3694:	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
        -: 3695:	 * beginning at 0 and for "jam" state.
        -: 3696:	 */
        1: 3697:	k = lastdfa + 2;
        -: 3698:
        1: 3699:	if ( reject )
        -: 3700:		/* We put a "cap" on the table associating lists of accepting
        -: 3701:		 * numbers with state numbers.  This is needed because we tell
        -: 3702:		 * where the end of an accepting list is by looking at where
        -: 3703:		 * the list for the next state starts.
        -: 3704:		 */
        -: 3705:#ifndef F_A08
    #####: 3706:		++k;
        -: 3707:#else
        -: 3708:		--k;
        -: 3709:#endif
        -: 3710:
        1: 3711:	out_str_dec( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
        -: 3712:
       26: 3713:	for ( i = 1; i <= lastdfa; ++i )
        -: 3714:		{
       25: 3715:		mkdata( acc_array[i] );
        -: 3716:
       25: 3717:		if ( ! reject && trace && acc_array[i] )
    #####: 3718:			fprintf( err, _( "state # %d accepts: [%d]\n" ),
    #####: 3719:				i, acc_array[i] );
        -: 3720:		}
        -: 3721:
        -: 3722:	/* Add entry for "jam" state. */
        1: 3723:	mkdata( acc_array[i] );
        -: 3724:
        1: 3725:	if ( reject )
        -: 3726:		/* Add "cap" for the list. */
    #####: 3727:		mkdata( acc_array[i] );
        -: 3728:
        1: 3729:	dataend();
        -: 3730:
        1: 3731:	if ( useecs )
        1: 3732:		genecs();
        -: 3733:
        -: 3734:#ifndef F_B46
        1: 3735:	if ( usemecs )
        -: 3736:#else
        -: 3737:	if ( ~  usemecs )
        -: 3738:#endif
        -: 3739:		{
        -: 3740:		/* Write out meta-equivalence classes (used to index
        -: 3741:		 * templates with).
        -: 3742:		 */
        -: 3743:
        1: 3744:		if ( trace )
    #####: 3745:			fputs( _( "\n\nMeta-Equivalence Classes:\n" ),
        -: 3746:			      err );
        -: 3747:
        -: 3748:#ifndef F_A19
        1: 3749:		out_str_dec( C_int_decl, "yy_meta", numecs + 1 );
        -: 3750:#else
        -: 3751:		out_str_dec( C_int_decl, "yy_meta", numecs + 1 *0);
        -: 3752:#endif
        -: 3753:
       18: 3754:		for ( i = 1; i <= numecs; ++i )
        -: 3755:			{
       17: 3756:			if ( trace )
    #####: 3757:				fprintf( err, "%d = %d\n",
    #####: 3758:					i, ABS( tecbck[i] ) );
        -: 3759:
       17: 3760:			mkdata( ABS( tecbck[i] ) );
        -: 3761:			}
        -: 3762:
        1: 3763:		dataend();
        -: 3764:		}
        -: 3765:
        1: 3766:	total_states = lastdfa + numtemps;
        -: 3767:
        1: 3768:	out_str_dec( (tblend >= MAX_SHORT || long_align) ?
        -: 3769:			C_long_decl : C_short_decl,
        -: 3770:		"yy_base", total_states + 1 );
        -: 3771:
       26: 3772:	for ( i = 1; i <= lastdfa; ++i )
        -: 3773:		{
       25: 3774:		register int d = def[i];
        -: 3775:
       25: 3776:		if ( base[i] == JAMSTATE )
        8: 3777:			base[i] = jambase;
        -: 3778:
       25: 3779:		if ( d == JAMSTATE )
       22: 3780:			def[i] = jamstate;
        -: 3781:
        3: 3782:		else if ( d < 0 )
        -: 3783:			{
        -: 3784:			/* Template reference. */
        2: 3785:			++tmpuses;
        2: 3786:			def[i] = lastdfa - d + 1;
        -: 3787:			}
        -: 3788:
       25: 3789:		mkdata( base[i] );
        -: 3790:		}
        -: 3791:
        -: 3792:	/* Generate jam state's base index. */
        1: 3793:	mkdata( base[i] );
        -: 3794:
        2: 3795:	for ( ++i /* skip jam state */; i <= total_states; ++i )
        -: 3796:		{
        -: 3797:#ifndef F_A01
        1: 3798:		mkdata( base[i] );
        -: 3799:#else
        -: 3800:		mkdata( base[i] *0);
        -: 3801:#endif
        -: 3802:
        -: 3803:#ifndef F_A12
        -: 3804:		def[i] = jamstate;
        -: 3805:#else
        1: 3806:		def[ 1 + i] = jamstate;
        -: 3807:#endif
        -: 3808:		}
        -: 3809:
        1: 3810:	dataend();
        -: 3811:
        1: 3812:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
        -: 3813:			C_long_decl : C_short_decl,
        -: 3814:		"yy_def", total_states + 1 );
        -: 3815:
       28: 3816:	for ( i = 1; i <= total_states; ++i )
       27: 3817:		mkdata( def[i] );
        -: 3818:
        1: 3819:	dataend();
        -: 3820:
        1: 3821:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
        -: 3822:			C_long_decl : C_short_decl,
        -: 3823:		"yy_nxt", tblend + 1 );
        -: 3824:
       53: 3825:	for ( i = 1; i <= tblend; ++i )
        -: 3826:		{
        -: 3827:		/* Note, the order of the following test is important.
        -: 3828:		 * If chk[i] is 0, then nxt[i] is undefined.
        -: 3829:		 */
       52: 3830:		if ( chk[i] == 0 || nxt[i] == 0 )
       18: 3831:			nxt[i] = jamstate;	/* new state is the JAM state */
        -: 3832:
       52: 3833:		mkdata( nxt[i] );
        -: 3834:		}
        -: 3835:
        1: 3836:	dataend();
        -: 3837:
        1: 3838:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
        -: 3839:			C_long_decl : C_short_decl,
        -: 3840:		"yy_chk", tblend + 1 );
        -: 3841:
       53: 3842:	for ( i = 1; i <= tblend; ++i )
        -: 3843:		{
       52: 3844:		if ( chk[i] == 0 )
    #####: 3845:			++nummt;
        -: 3846:
       52: 3847:		mkdata( chk[i] );
        -: 3848:		}
        -: 3849:
        1: 3850:	dataend();
        1: 3851:	}
        -: 3852:
        -: 3853:
        -: 3854:/* Write out a formatted string (with a secondary string argument) at the
        -: 3855: * current indentation level, adding a final newline.
        -: 3856: */
        -: 3857:
        3: 3858:void indent_put2s( fmt, arg )
        -: 3859:char fmt[], arg[];
        -: 3860:	{
        3: 3861:	do_indent();
        3: 3862:	out_str( fmt, arg );
        3: 3863:	outn( "" );
        3: 3864:	}
        -: 3865:
        -: 3866:
        -: 3867:/* Write out a string at the current indentation level, adding a final
        -: 3868: * newline.
        -: 3869: */
        -: 3870:
       82: 3871:void indent_puts( str )
        -: 3872:char str[];
        -: 3873:	{
       82: 3874:	do_indent();
       82: 3875:	outn( str );
       82: 3876:	}
        -: 3877:
        -: 3878:
        -: 3879:/* make_tables - generate transition tables and finishes generating output file
        -: 3880: */
        -: 3881:
        1: 3882:void make_tables()
        -: 3883:	{
        -: 3884:	register int i;
        1: 3885:	int did_eof_rule = false;
        -: 3886:
        1: 3887:	skelout();
        -: 3888:
        -: 3889:	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
        -: 3890:	 * being used.
        -: 3891:	 */
        1: 3892:	set_indent( 1 );
        1: 3893:	if ( yymore_used && ! yytext_is_array )
        -: 3894:		{
    #####: 3895:		indent_puts( "yytext_ptr -= yy_more_len; \\" );
    #####: 3896:		indent_puts( "yyleng = (int) (yy_cp - yytext_ptr); \\" );
        -: 3897:		}
        -: 3898:
        -: 3899:	else
        1: 3900:		indent_puts( "yyleng = (int) (yy_cp - yy_bp); \\" );
        -: 3901:
        -: 3902:	/* Now also deal with copying yytext_ptr to yytext if needed. */
        1: 3903:	skelout();
        1: 3904:	if ( yytext_is_array )
        -: 3905:		{
    #####: 3906:		if ( yymore_used )
    #####: 3907:			indent_puts(
        -: 3908:				"if ( yyleng + yy_more_offset >= YYLMAX ) \\" );
        -: 3909:		else
    #####: 3910:			indent_puts( "if ( yyleng >= YYLMAX ) \\" );
        -: 3911:
    #####: 3912:		indent_up();
    #####: 3913:		indent_puts(
        -: 3914:		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
    #####: 3915:		indent_down();
        -: 3916:
    #####: 3917:		if ( yymore_used )
        -: 3918:			{
    #####: 3919:			indent_puts(
        -: 3920:"yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\" );
    #####: 3921:			indent_puts( "yyleng += yy_more_offset; \\" );
    #####: 3922:			indent_puts(
        -: 3923:				"yy_prev_more_offset = yy_more_offset; \\" );
    #####: 3924:			indent_puts( "yy_more_offset = 0; \\" );
        -: 3925:			}
        -: 3926:		else
        -: 3927:			{
    #####: 3928:			indent_puts(
        -: 3929:		"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\" );
        -: 3930:			}
        -: 3931:		}
        -: 3932:
        1: 3933:	set_indent( 0 );
        -: 3934:
        1: 3935:	skelout();
        -: 3936:
        -: 3937:
        1: 3938:	out_dec( "#define YY_NUM_RULES %d\n", num_rules );
        1: 3939:	out_dec( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
        -: 3940:
        1: 3941:	if ( fullspd )
        -: 3942:		{
        -: 3943:		/* Need to define the transet type as a size large
        -: 3944:		 * enough to hold the biggest offset.
        -: 3945:		 */
    #####: 3946:		int total_table_size = tblend + numecs + 1;
    #####: 3947:		char *trans_offset_type =
    #####: 3948:			(total_table_size >= MAX_SHORT || long_align) ?
    #####: 3949:				"long" : "short";
        -: 3950:
    #####: 3951:		set_indent( 0 );
    #####: 3952:		indent_puts( "struct yy_trans_info" );
    #####: 3953:		indent_up();
    #####: 3954:		indent_puts( "{" ); 	/* } for vi */
        -: 3955:
    #####: 3956:		if ( long_align )
    #####: 3957:			indent_puts( "long yy_verify;" );
        -: 3958:		else
    #####: 3959:			indent_puts( "short yy_verify;" );
        -: 3960:
        -: 3961:		/* In cases where its sister yy_verify *is* a "yes, there is
        -: 3962:		 * a transition", yy_nxt is the offset (in records) to the
        -: 3963:		 * next state.  In most cases where there is no transition,
        -: 3964:		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
        -: 3965:		 * record of a state, though, then yy_nxt is the action number
        -: 3966:		 * for that state.
        -: 3967:		 */
        -: 3968:
    #####: 3969:		indent_put2s( "%s yy_nxt;", trans_offset_type );
    #####: 3970:		indent_puts( "};" );
    #####: 3971:		indent_down();
        -: 3972:		}
        -: 3973:
        1: 3974:	if ( fullspd )
    #####: 3975:		genctbl();
        1: 3976:	else if ( fulltbl )
    #####: 3977:		genftbl();
        -: 3978:	else
        1: 3979:		gentabs();
        -: 3980:
        -: 3981:	/* Definitions for backing up.  We don't need them if REJECT
        -: 3982:	 * is being used because then we use an alternative backin-up
        -: 3983:	 * technique instead.
        -: 3984:	 */
        1: 3985:	if ( num_backing_up > 0 && ! reject )
        -: 3986:		{
        1: 3987:		if ( ! C_plus_plus )
        -: 3988:			{
        1: 3989:			indent_puts(
        -: 3990:			"static yy_state_type yy_last_accepting_state;" );
        1: 3991:			indent_puts(
        -: 3992:				"static char *yy_last_accepting_cpos;\n" );
        -: 3993:			}
        -: 3994:		}
        -: 3995:
        1: 3996:	if ( nultrans )
        -: 3997:		{
    #####: 3998:		out_str_dec( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
        -: 3999:
    #####: 4000:		for ( i = 1; i <= lastdfa; ++i )
        -: 4001:			{
    #####: 4002:			if ( fullspd )
    #####: 4003:				out_dec( "    &yy_transition[%d],\n", base[i] );
        -: 4004:			else
    #####: 4005:				mkdata( nultrans[i] );
        -: 4006:			}
        -: 4007:
    #####: 4008:		dataend();
        -: 4009:		}
        -: 4010:
        -: 4011:#ifndef F_B20
        1: 4012:	if ( ddebug )
        -: 4013:#else
        -: 4014:	if ( ~  ddebug )
        -: 4015:#endif
        -: 4016:		{ /* Spit out table mapping rules to line numbers. */
        1: 4017:		if ( ! C_plus_plus )
        -: 4018:			{
        1: 4019:			indent_puts( "extern int yy_flex_debug;" );
        1: 4020:			indent_puts( "int yy_flex_debug = 1;\n" );
        -: 4021:			}
        -: 4022:
        1: 4023:		out_str_dec( long_align ? C_long_decl : C_short_decl,
        -: 4024:			"yy_rule_linenum", num_rules );
        7: 4025:		for ( i = 1; i < num_rules; ++i )
        6: 4026:			mkdata( rule_linenum[i] );
        1: 4027:		dataend();
        -: 4028:		}
        -: 4029:
        1: 4030:	if ( reject )
        -: 4031:		{
        -: 4032:		/* Declare state buffer variables. */
    #####: 4033:		if ( ! C_plus_plus )
        -: 4034:			{
    #####: 4035:			outn(
        -: 4036:	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
    #####: 4037:			outn( "static char *yy_full_match;" );
    #####: 4038:			outn( "static int yy_lp;" );
        -: 4039:			}
        -: 4040:
    #####: 4041:		if ( variable_trailing_context_rules )
        -: 4042:			{
    #####: 4043:			if ( ! C_plus_plus )
        -: 4044:				{
    #####: 4045:				outn(
        -: 4046:				"static int yy_looking_for_trail_begin = 0;" );
    #####: 4047:				outn( "static int yy_full_lp;" );
    #####: 4048:				outn( "static int *yy_full_state;" );
        -: 4049:				}
        -: 4050:
    #####: 4051:			out_hex( "#define YY_TRAILING_MASK 0x%x\n",
        -: 4052:				(unsigned int) YY_TRAILING_MASK );
    #####: 4053:			out_hex( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
        -: 4054:				(unsigned int) YY_TRAILING_HEAD_MASK );
        -: 4055:			}
        -: 4056:
    #####: 4057:		outn( "#define REJECT \\" );
    #####: 4058:		outn( "{ \\" );		/* } for vi */
    #####: 4059:		outn(
        -: 4060:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
    #####: 4061:		outn(
        -: 4062:	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
        -: 4063:
    #####: 4064:		if ( variable_trailing_context_rules )
        -: 4065:			{
    #####: 4066:			outn(
        -: 4067:		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
    #####: 4068:			outn(
        -: 4069:		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
    #####: 4070:			outn(
        -: 4071:	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
        -: 4072:			}
        -: 4073:
    #####: 4074:		outn( "++yy_lp; \\" );
    #####: 4075:		outn( "goto find_rule; \\" );
        -: 4076:		/* { for vi */
    #####: 4077:		outn( "}" );
        -: 4078:		}
        -: 4079:
        -: 4080:	else
        -: 4081:		{
        1: 4082:		outn(
        -: 4083:		"/* The intent behind this definition is that it'll catch" );
        1: 4084:		outn( " * any uses of REJECT which flex missed." );
        1: 4085:		outn( " */" );
        1: 4086:		outn( "#define REJECT reject_used_but_not_detected" );
        -: 4087:		}
        -: 4088:
        1: 4089:	if ( yymore_used )
        -: 4090:		{
    #####: 4091:		if ( ! C_plus_plus )
        -: 4092:			{
        -: 4093:
    #####: 4094:			if ( yytext_is_array )
        -: 4095:				{
    #####: 4096:				indent_puts( "static int yy_more_offset = 0;" );
    #####: 4097:				indent_puts(
        -: 4098:					"static int yy_prev_more_offset = 0;" );
        -: 4099:				}
        -: 4100:			else
        -: 4101:				{
    #####: 4102:				indent_puts( "static int yy_more_flag = 0;" );
    #####: 4103:				indent_puts( "static int yy_more_len = 0;" );
        -: 4104:				}
        -: 4105:			}
    #####: 4106:		if ( yytext_is_array )
        -: 4107:			{
    #####: 4108:			indent_puts(
        -: 4109:	"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))" );
    #####: 4110:			indent_puts( "#define YY_NEED_STRLEN" );
    #####: 4111:			indent_puts( "#define YY_MORE_ADJ 0" );
    #####: 4112:			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET \\" );
    #####: 4113:			indent_up();
    #####: 4114:			indent_puts( "{ \\" );
    #####: 4115:			indent_puts( "yy_more_offset = yy_prev_more_offset; \\" );
    #####: 4116:			indent_puts( "yyleng -= yy_more_offset; \\" );
    #####: 4117:			indent_puts( "}" );
    #####: 4118:			indent_down();
        -: 4119:			}
        -: 4120:		else
        -: 4121:			{
    #####: 4122:			indent_puts( "#define yymore() (yy_more_flag = 1)" );
    #####: 4123:			indent_puts( "#define YY_MORE_ADJ yy_more_len" );
    #####: 4124:			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
        -: 4125:			}
        -: 4126:		}
        -: 4127:
        -: 4128:	else
        -: 4129:		{
        1: 4130:		indent_puts( "#define yymore() yymore_used_but_not_detected" );
        1: 4131:		indent_puts( "#define YY_MORE_ADJ 0" );
        1: 4132:		indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
        -: 4133:		}
        -: 4134:
        1: 4135:	if ( ! C_plus_plus )
        -: 4136:		{
        1: 4137:		if ( yytext_is_array )
        -: 4138:			{
    #####: 4139:			outn( "#ifndef YYLMAX" );
    #####: 4140:			outn( "#define YYLMAX 8192" );
    #####: 4141:			outn( "#endif\n" );
    #####: 4142:			outn( "char yytext[YYLMAX];" );
    #####: 4143:			outn( "char *yytext_ptr;" );
        -: 4144:			}
        -: 4145:
        -: 4146:		else
        1: 4147:			outn( "char *yytext;" );
        -: 4148:		}
        -: 4149:
        1: 4150:	out( &action_array[defs1_offset] );
        -: 4151:
        1: 4152:	line_directive_out( stdout, 0 );
        -: 4153:
        1: 4154:	skelout();
        -: 4155:
        1: 4156:	if ( ! C_plus_plus )
        -: 4157:		{
        1: 4158:		if ( use_read )
        -: 4159:			{
        1: 4160:			outn(
        -: 4161:"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\" );
        1: 4162:			outn(
        -: 4163:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
        -: 4164:			}
        -: 4165:
        -: 4166:#ifndef F_B14
        -: 4167:		else
        -: 4168:#else
        -: 4169:
        -: 4170:#endif
        -: 4171:			{
    #####: 4172:			outn(
        -: 4173:			"\tif ( yy_current_buffer->yy_is_interactive ) \\" );
    #####: 4174:			outn( "\t\t{ \\" );
    #####: 4175:			outn( "\t\tint c = '*', n; \\" );
    #####: 4176:			outn( "\t\tfor ( n = 0; n < max_size && \\" );
    #####: 4177:	outn( "\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\" );
    #####: 4178:			outn( "\t\t\tbuf[n] = (char) c; \\" );
    #####: 4179:			outn( "\t\tif ( c == '\\n' ) \\" );
    #####: 4180:            outn( "\t\t\tbuf[n++] = (char) c; \\" );
    #####: 4181:			outn( "\t\tif ( c == EOF && ferror( yyin ) ) \\" );
    #####: 4182:			outn(
        -: 4183:	"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\" );
    #####: 4184:			outn( "\t\tresult = n; \\" );
    #####: 4185:			outn( "\t\t} \\" );
    #####: 4186:			outn(
        -: 4187:	"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\" );
    #####: 4188:			outn( "\t\t  && ferror( yyin ) ) \\" );
    #####: 4189:			outn(
        -: 4190:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
        -: 4191:			}
        -: 4192:		}
        -: 4193:
        1: 4194:	skelout();
        -: 4195:
        1: 4196:	indent_puts( "#define YY_RULE_SETUP \\" );
        1: 4197:	indent_up();
        1: 4198:	if ( bol_needed )
        -: 4199:		{
        1: 4200:		indent_puts( "if ( yyleng > 0 ) \\" );
        1: 4201:		indent_up();
        1: 4202:		indent_puts( "yy_current_buffer->yy_at_bol = \\" );
        1: 4203:		indent_puts( "\t\t(yytext[yyleng - 1] == '\\n'); \\" );
        1: 4204:		indent_down();
        -: 4205:		}
        1: 4206:	indent_puts( "YY_USER_ACTION" );
        1: 4207:	indent_down();
        -: 4208:
        1: 4209:	skelout();
        -: 4210:
        -: 4211:	/* Copy prolog to output file. */
        1: 4212:	out( &action_array[prolog_offset] );
        -: 4213:
        1: 4214:	line_directive_out( stdout, 0 );
        -: 4215:
        1: 4216:	skelout();
        -: 4217:
        1: 4218:	set_indent( 2 );
        -: 4219:
        1: 4220:	if ( yymore_used && ! yytext_is_array )
        -: 4221:		{
    #####: 4222:		indent_puts( "yy_more_len = 0;" );
    #####: 4223:		indent_puts( "if ( yy_more_flag )" );
    #####: 4224:		indent_up();
    #####: 4225:		indent_puts( "{" );
    #####: 4226:		indent_puts( "yy_more_len = yy_c_buf_p - yytext_ptr;" );
    #####: 4227:		indent_puts( "yy_more_flag = 0;" );
    #####: 4228:		indent_puts( "}" );
    #####: 4229:		indent_down();
        -: 4230:		}
        -: 4231:
        1: 4232:	skelout();
        -: 4233:
        1: 4234:	gen_start_state();
        -: 4235:
        -: 4236:	/* Note, don't use any indentation. */
        1: 4237:	outn( "yy_match:" );
        1: 4238:	gen_next_match();
        -: 4239:
        1: 4240:	skelout();
        1: 4241:	set_indent( 2 );
        1: 4242:	gen_find_action();
        -: 4243:
        1: 4244:	skelout();
        1: 4245:	if ( do_yylineno )
        -: 4246:		{
    #####: 4247:		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
    #####: 4248:		indent_up();
    #####: 4249:		indent_puts( "{" );
    #####: 4250:		indent_puts( "int yyl;" );
    #####: 4251:		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
    #####: 4252:		indent_up();
    #####: 4253:		indent_puts( "if ( yytext[yyl] == '\\n' )" );
    #####: 4254:		indent_up();
    #####: 4255:		indent_puts( "++yylineno;" );
    #####: 4256:		indent_down();
    #####: 4257:		indent_down();
    #####: 4258:		indent_puts( "}" );
    #####: 4259:		indent_down();
        -: 4260:		}
        -: 4261:
        1: 4262:	skelout();
        1: 4263:	if ( ddebug )
        -: 4264:		{
        1: 4265:		indent_puts( "if ( yy_flex_debug )" );
        1: 4266:		indent_up();
        -: 4267:
        1: 4268:		indent_puts( "{" );
        1: 4269:		indent_puts( "if ( yy_act == 0 )" );
        1: 4270:		indent_up();
        1: 4271:		indent_puts( C_plus_plus ?
        -: 4272:			"cerr << \"--scanner backing up\\n\";" :
        -: 4273:#ifndef F_A24
        -: 4274:			"fprintf( err, \"--scanner backing up\\n\" );" );
        -: 4275:#else
        -: 4276:			"fprintf( err, 0 *  \"--scanner backing up\\n\" );" );
        -: 4277:#endif
        1: 4278:		indent_down();
        -: 4279:
        1: 4280:		do_indent();
        1: 4281:		out_dec( "else if ( yy_act < %d )\n", num_rules );
        1: 4282:		indent_up();
        -: 4283:
        -: 4284:#ifndef F_B33
        1: 4285:		if ( C_plus_plus )
        -: 4286:#else
        -: 4287:		if  (!  C_plus_plus )
        -: 4288:#endif
        -: 4289:			{
    #####: 4290:			indent_puts(
        -: 4291:	"cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<" );
    #####: 4292:			indent_puts(
        -: 4293:			"         \"(\\\"\" << yytext << \"\\\")\\n\";" );
        -: 4294:			}
        -: 4295:		else
        -: 4296:			{
        1: 4297:			indent_puts(
        -: 4298:	"fprintf( err, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
        -: 4299:
        -: 4300:#ifndef F_B21
        1: 4301:			indent_puts(
        -: 4302:#else
        -: 4303:			indent_puts (!
        -: 4304:#endif
        -: 4305:				"         yy_rule_linenum[yy_act], yytext );" );
        -: 4306:			}
        -: 4307:
        1: 4308:		indent_down();
        -: 4309:
        1: 4310:		do_indent();
        1: 4311:		out_dec( "else if ( yy_act == %d )\n", num_rules );
        1: 4312:		indent_up();
        -: 4313:
        1: 4314:		if ( C_plus_plus )
        -: 4315:			{
    #####: 4316:			indent_puts(
        -: 4317:"cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";" );
        -: 4318:			}
        -: 4319:		else
        -: 4320:			{
        1: 4321:			indent_puts(
        -: 4322:	"fprintf( err, \"--accepting default rule (\\\"%s\\\")\\n\"," );
        1: 4323:			indent_puts( "         yytext );" );
        -: 4324:			}
        -: 4325:
        1: 4326:		indent_down();
        -: 4327:
        1: 4328:		do_indent();
        1: 4329:		out_dec( "else if ( yy_act == %d )\n", num_rules + 1 );
        1: 4330:		indent_up();
        -: 4331:
        1: 4332:		indent_puts( C_plus_plus ?
        -: 4333:			"cerr << \"--(end of buffer or a NUL)\\n\";" :
        -: 4334:		"fprintf( err, \"--(end of buffer or a NUL)\\n\" );" );
        -: 4335:
        1: 4336:		indent_down();
        -: 4337:
        1: 4338:		do_indent();
        1: 4339:		outn( "else" );
        1: 4340:		indent_up();
        -: 4341:
        -: 4342:#ifndef F_B22
        1: 4343:		if ( C_plus_plus )
        -: 4344:#else
        -: 4345:		if  (!  C_plus_plus )
        -: 4346:#endif
        -: 4347:			{
    #####: 4348:			indent_puts(
        -: 4349:	"cerr << \"--EOF (start condition \" << YY_START << \")\\n\";" );
        -: 4350:			}
        -: 4351:		else
        -: 4352:			{
        1: 4353:			indent_puts(
        -: 4354:	"fprintf( err, \"--EOF (start condition %d)\\n\", YY_START );" );
        -: 4355:			}
        -: 4356:
        1: 4357:		indent_down();
        -: 4358:
        -: 4359:#ifndef F_B05
        1: 4360:		indent_puts( "}" );
        -: 4361:#else
        -: 4362:		indent_puts (!  "}" );
        -: 4363:#endif
        1: 4364:		indent_down();
        -: 4365:		}
        -: 4366:
        -: 4367:	/* Copy actions to output file. */
        1: 4368:	skelout();
        1: 4369:	indent_up();
        1: 4370:	gen_bu_action();
        1: 4371:	out( &action_array[action_offset] );
        -: 4372:
        1: 4373:	line_directive_out( stdout, 0 );
        -: 4374:
        -: 4375:	/* generate cases for any missing EOF rules */
        2: 4376:	for ( i = 1; i <= lastsc; ++i )
        1: 4377:		if ( ! sceof[i] )
        -: 4378:			{
        1: 4379:			do_indent();
        1: 4380:			out_str( "case YY_STATE_EOF(%s):\n", scname[i] );
        1: 4381:			did_eof_rule = true;
        -: 4382:			}
        -: 4383:
        1: 4384:	if ( did_eof_rule )
        -: 4385:		{
        1: 4386:		indent_up();
        1: 4387:		indent_puts( "yyterminate();" );
        1: 4388:		indent_down();
        -: 4389:		}
        -: 4390:
        -: 4391:
        -: 4392:	/* Generate code for handling NUL's, if needed. */
        -: 4393:
        -: 4394:	/* First, deal with backing up and setting up yy_cp if the scanner
        -: 4395:	 * finds that it should JAM on the NUL.
        -: 4396:	 */
        1: 4397:	skelout();
        1: 4398:	set_indent( 4 );
        -: 4399:
        1: 4400:	if ( fullspd || fulltbl )
    #####: 4401:		indent_puts( "yy_cp = yy_c_buf_p;" );
        -: 4402:
        -: 4403:#ifndef F_B29
        -: 4404:	else
        -: 4405:#else
        -: 4406:
        -: 4407:#endif
        -: 4408:		{ /* compressed table */
        1: 4409:		if ( ! reject && ! interactive )
        -: 4410:			{
        -: 4411:			/* Do the guaranteed-needed backing up to figure
        -: 4412:			 * out the match.
        -: 4413:			 */
    #####: 4414:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
    #####: 4415:			indent_puts(
        -: 4416:				"yy_current_state = yy_last_accepting_state;" );
        -: 4417:			}
        -: 4418:
        -: 4419:		else
        -: 4420:			/* Still need to initialize yy_cp, though
        -: 4421:			 * yy_current_state was set up by
        -: 4422:			 * yy_get_previous_state().
        -: 4423:			 */
        1: 4424:			indent_puts( "yy_cp = yy_c_buf_p;" );
        -: 4425:		}
        -: 4426:
        -: 4427:
        -: 4428:	/* Generate code for yy_get_previous_state(). */
        1: 4429:	set_indent( 1 );
        1: 4430:	skelout();
        -: 4431:
        1: 4432:	gen_start_state();
        -: 4433:
        1: 4434:	set_indent( 2 );
        1: 4435:	skelout();
        1: 4436:	gen_next_state( true );
        -: 4437:
        1: 4438:	set_indent( 1 );
        1: 4439:	skelout();
        1: 4440:	gen_NUL_trans();
        -: 4441:
        1: 4442:	skelout();
        1: 4443:	if ( do_yylineno )
        -: 4444:		{ /* update yylineno inside of unput() */
    #####: 4445:		indent_puts( "if ( c == '\\n' )" );
    #####: 4446:		indent_up();
    #####: 4447:		indent_puts( "--yylineno;" );
    #####: 4448:		indent_down();
        -: 4449:		}
        -: 4450:
        1: 4451:	skelout();
        -: 4452:	/* Update BOL and yylineno inside of input(). */
        1: 4453:	if ( bol_needed )
        -: 4454:		{
        1: 4455:		indent_puts( "yy_current_buffer->yy_at_bol = (c == '\\n');" );
        1: 4456:		if ( do_yylineno )
        -: 4457:			{
    #####: 4458:			indent_puts( "if ( yy_current_buffer->yy_at_bol )" );
    #####: 4459:			indent_up();
    #####: 4460:			indent_puts( "++yylineno;" );
    #####: 4461:			indent_down();
        -: 4462:			}
        -: 4463:		}
        -: 4464:
    #####: 4465:	else if ( do_yylineno )
        -: 4466:		{
    #####: 4467:		indent_puts( "if ( c == '\\n' )" );
    #####: 4468:		indent_up();
    #####: 4469:		indent_puts( "++yylineno;" );
    #####: 4470:		indent_down();
        -: 4471:		}
        -: 4472:
        1: 4473:	skelout();
        -: 4474:
        -: 4475:	/* Copy remainder of input to output. */
        -: 4476:
        1: 4477:	line_directive_out( stdout, 1 );
        -: 4478:
        1: 4479:	if ( sectnum == 3 )
    #####: 4480:		(void) flexscan(); /* copy remainder of input to output */
        1: 4481:	}
        -: 4482:/* misc - miscellaneous flex routines */
        -: 4483:
        -: 4484:/*-
        -: 4485: * Copyright (c) 1990 The Regents of the University of California.
        -: 4486: * All rights reserved.
        -: 4487: *
        -: 4488: * This code is derived from software contributed to Berkeley by
        -: 4489: * Vern Paxson.
        -: 4490: * 
        -: 4491: * The United States Government has rights in this work pursuant
        -: 4492: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4493: * Department of Energy and the University of California.
        -: 4494: *
        -: 4495: * Redistribution and use in source and binary forms are permitted provided
        -: 4496: * that: (1) source distributions retain this entire copyright notice and
        -: 4497: * comment, and (2) distributions including binaries display the following
        -: 4498: * acknowledgement:  ``This product includes software developed by the
        -: 4499: * University of California, Berkeley and its contributors'' in the
        -: 4500: * documentation or other materials provided with the distribution and in
        -: 4501: * all advertising materials mentioning features or use of this software.
        -: 4502: * Neither the name of the University nor the names of its contributors may
        -: 4503: * be used to endorse or promote products derived from this software without
        -: 4504: * specific prior written permission.
        -: 4505: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4506: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4507: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4508: */
        -: 4509:
        -: 4510:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 4511:
        -: 4512:
        -: 4513:
        1: 4514:void action_define( defname, value )
        -: 4515:char *defname;
        -: 4516:int value;
        -: 4517:	{
        -: 4518:	char buf[MAXLINE];
        -: 4519:
        1: 4520:	if ( (int) strlen( defname ) > MAXLINE / 2 )
        -: 4521:		{
    #####: 4522:		format_pinpoint_message( _( "name \"%s\" ridiculously long" ), 
        -: 4523:			defname );
    #####: 4524:		return;
        -: 4525:		}
        -: 4526:
        1: 4527:	sprintf( buf, "#define %s %d\n", defname, value );
        1: 4528:	add_action( buf );
        -: 4529:	}
        -: 4530:
        -: 4531:
       99: 4532:void add_action( new_text )
        -: 4533:char *new_text;
        -: 4534:	{
       99: 4535:	int len = strlen( new_text );
        -: 4536:
      198: 4537:	while ( len + action_index >= action_size - 10 /* slop */ )
        -: 4538:		{
    #####: 4539:		int new_size = action_size * 2;
        -: 4540:
    #####: 4541:		if ( new_size <= 0 )
        -: 4542:			/* Increase just a little, to try to avoid overflow
        -: 4543:			 * on 16-bit machines.
        -: 4544:			 */
    #####: 4545:			action_size += action_size / 8;
        -: 4546:		else
    #####: 4547:			action_size = new_size;
        -: 4548:
    #####: 4549:		action_array =
    #####: 4550:			reallocate_character_array( action_array, action_size );
        -: 4551:		}
        -: 4552:
       99: 4553:	strcpy( &action_array[action_index], new_text );
        -: 4554:
       99: 4555:	action_index += len;
       99: 4556:	}
        -: 4557:
        -: 4558:
        -: 4559:/* allocate_array - allocate memory for an integer array of the given size */
        -: 4560:
       63: 4561:void *allocate_array( size, element_size )
        -: 4562:int size;
        -: 4563:size_t element_size;
        -: 4564:	{
        -: 4565:	register void *mem;
       63: 4566:	size_t num_bytes = element_size * size;
        -: 4567:
       63: 4568:	mem = flex_alloc( num_bytes );
       63: 4569:	if ( ! mem )
    #####: 4570:		flexfatal(
        -: 4571:			_( "memory allocation failed in allocate_array()" ) );
        -: 4572:
       63: 4573:	return mem;
        -: 4574:	}
        -: 4575:
        -: 4576:
        -: 4577:/* all_lower - true if a string is all lower-case */
        -: 4578:
    #####: 4579:int all_lower( str )
        -: 4580:register char *str;
        -: 4581:	{
    #####: 4582:	while ( *str )
        -: 4583:		{
    #####: 4584:		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
    #####: 4585:			return 0;
    #####: 4586:		++str;
        -: 4587:		}
        -: 4588:
    #####: 4589:	return 1;
        -: 4590:	}
        -: 4591:
        -: 4592:
        -: 4593:/* all_upper - true if a string is all upper-case */
        -: 4594:
    #####: 4595:int all_upper( str )
        -: 4596:register char *str;
        -: 4597:	{
    #####: 4598:	while ( *str )
        -: 4599:		{
    #####: 4600:		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
    #####: 4601:			return 0;
    #####: 4602:		++str;
        -: 4603:		}
        -: 4604:
    #####: 4605:	return 1;
        -: 4606:	}
        -: 4607:
        -: 4608:
        -: 4609:/* bubble - bubble sort an integer array in increasing order
        -: 4610: *
        -: 4611: * synopsis
        -: 4612: *   int v[n], n;
        -: 4613: *   void bubble( v, n );
        -: 4614: *
        -: 4615: * description
        -: 4616: *   sorts the first n elements of array v and replaces them in
        -: 4617: *   increasing order.
        -: 4618: *
        -: 4619: * passed
        -: 4620: *   v - the array to be sorted
        -: 4621: *   n - the number of elements of 'v' to be sorted
        -: 4622: */
        -: 4623:
       36: 4624:void bubble( v, n )
        -: 4625:int v[], n;
        -: 4626:	{
        -: 4627:	register int i, j, k;
        -: 4628:
       78: 4629:	for ( i = n; i > 1; --i )
      158: 4630:		for ( j = 1; j < i; ++j )
      116: 4631:			if ( v[j] > v[j + 1] )	/* compare */
        -: 4632:				{
       75: 4633:				k = v[j];	/* exchange */
       75: 4634:				v[j] = v[j + 1];
       75: 4635:				v[j + 1] = k;
        -: 4636:				}
       36: 4637:	}
        -: 4638:
        -: 4639:
        -: 4640:/* check_char - checks a character to make sure it's within the range
        -: 4641: *		we're expecting.  If not, generates fatal error message
        -: 4642: *		and exits.
        -: 4643: */
        -: 4644:
       22: 4645:void check_char( c )
        -: 4646:int c;
        -: 4647:	{
       22: 4648:	if ( c >= CSIZE )
    #####: 4649:		lerrsf( _( "bad character '%s' detected in check_char()" ),
    #####: 4650:			readable_form( c ) );
        -: 4651:
       22: 4652:	if ( c >= csize )
    #####: 4653:		lerrsf(
        -: 4654:		_( "scanner requires -8 flag to use the character %s" ),
    #####: 4655:			readable_form( c ) );
       22: 4656:	}
        -: 4657:
        -: 4658:
        -: 4659:
        -: 4660:/* clower - replace upper-case letter to lower-case */
        -: 4661:
    #####: 4662:Char clower( c )
        -: 4663:register int c;
        -: 4664:	{
    #####: 4665:	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
        -: 4666:	}
        -: 4667:
        -: 4668:
        -: 4669:/* copy_string - returns a dynamically allocated copy of a string */
        -: 4670:
        2: 4671:char *copy_string( str )
        -: 4672:register const char *str;
        -: 4673:	{
        -: 4674:	register const char *c1;
        -: 4675:	register char *c2;
        -: 4676:	char *copy;
        -: 4677:	unsigned int size;
        -: 4678:
        -: 4679:	/* find length */
        2: 4680:	for ( c1 = str; *c1; ++c1 )
        -: 4681:		;
        -: 4682:
        2: 4683:	size = (c1 - str + 1) * sizeof( char );
        2: 4684:	copy = (char *) flex_alloc( size );
        -: 4685:
        2: 4686:	if ( copy == NULL )
    #####: 4687:		flexfatal( _( "dynamic memory failure in copy_string()" ) );
        -: 4688:
        2: 4689:	for ( c2 = copy; (*c2++ = *str++) != 0; )
        -: 4690:		;
        -: 4691:
        2: 4692:	return copy;
        -: 4693:	}
        -: 4694:
        -: 4695:
        -: 4696:/* copy_unsigned_string -
        -: 4697: *    returns a dynamically allocated copy of a (potentially) unsigned string
        -: 4698: */
        -: 4699:
        1: 4700:Char *copy_unsigned_string( str )
        -: 4701:register Char *str;
        -: 4702:	{
        -: 4703:	register Char *c;
        -: 4704:	Char *copy;
        -: 4705:
        -: 4706:	/* find length */
        1: 4707:	for ( c = str; *c; ++c )
        -: 4708:		;
        -: 4709:
        1: 4710:	copy = allocate_Character_array( c - str + 1 );
        -: 4711:
        1: 4712:	for ( c = copy; (*c++ = *str++) != 0; )
        -: 4713:		;
        -: 4714:
        1: 4715:	return copy;
        -: 4716:	}
        -: 4717:
        -: 4718:
        -: 4719:/* cshell - shell sort a character array in increasing order
        -: 4720: *
        -: 4721: * synopsis
        -: 4722: *
        -: 4723: *   Char v[n];
        -: 4724: *   int n, special_case_0;
        -: 4725: *   cshell( v, n, special_case_0 );
        -: 4726: *
        -: 4727: * description
        -: 4728: *   Does a shell sort of the first n elements of array v.
        -: 4729: *   If special_case_0 is true, then any element equal to 0
        -: 4730: *   is instead assumed to have infinite weight.
        -: 4731: *
        -: 4732: * passed
        -: 4733: *   v - array to be sorted
        -: 4734: *   n - number of elements of v to be sorted
        -: 4735: */
        -: 4736:
    #####: 4737:void cshell( v, n, special_case_0 )
        -: 4738:Char v[];
        -: 4739:int n, special_case_0;
        -: 4740:	{
        -: 4741:	int gap, i, j, jg;
        -: 4742:	Char k;
        -: 4743:
    #####: 4744:	for ( gap = n / 2; gap > 0; gap = gap / 2 )
    #####: 4745:		for ( i = gap; i < n; ++i )
    #####: 4746:			for ( j = i - gap; j >= 0; j = j - gap )
        -: 4747:				{
    #####: 4748:				jg = j + gap;
        -: 4749:
    #####: 4750:				if ( special_case_0 )
        -: 4751:					{
        -: 4752:#ifndef F_B24
    #####: 4753:					if ( v[jg] == 0 )
        -: 4754:#else
        -: 4755:					if ( !  v[jg] == 0 )
        -: 4756:#endif
    #####: 4757:						break;
        -: 4758:
    #####: 4759:					else if ( v[j] != 0 && v[j] <= v[jg] )
    #####: 4760:						break;
        -: 4761:					}
        -: 4762:
    #####: 4763:				else if ( v[j] <= v[jg] )
    #####: 4764:					break;
        -: 4765:
    #####: 4766:				k = v[j];
    #####: 4767:				v[j] = v[jg];
    #####: 4768:				v[jg] = k;
        -: 4769:				}
    #####: 4770:	}
        -: 4771:
        -: 4772:
        -: 4773:/* dataend - finish up a block of data declarations */
        -: 4774:
        8: 4775:void dataend()
        -: 4776:	{
        8: 4777:	if ( datapos > 0 )
        8: 4778:		dataflush();
        -: 4779:
        -: 4780:	/* add terminator for initialization; { for vi */
        8: 4781:	outn( "    } ;\n" );
        -: 4782:
        8: 4783:	dataline = 0;
        8: 4784:	datapos = 0;
        8: 4785:	}
        -: 4786:
        -: 4787:
        -: 4788:/* dataflush - flush generated data statements */
        -: 4789:
       50: 4790:void dataflush()
        -: 4791:	{
       50: 4792:	outc( '\n' );
        -: 4793:
       50: 4794:	if ( ++dataline >= NUMDATALINES )
        -: 4795:		{
        -: 4796:		/* Put out a blank line so that the table is grouped into
        -: 4797:		 * large blocks that enable the user to find elements easily.
        -: 4798:		 */
        2: 4799:		outc( '\n' );
        2: 4800:		dataline = 0;
        -: 4801:		}
        -: 4802:
        -: 4803:	/* Reset the number of characters written on the current line. */
       50: 4804:	datapos = 0;
       50: 4805:	}
        -: 4806:
        -: 4807:
        -: 4808:/* flexerror - report an error message and terminate */
        -: 4809:
    #####: 4810:void flexerror( msg )
        -: 4811:const char msg[];
        -: 4812:	{
    #####: 4813:	fprintf( err, "%s: %s\n", program_name, msg );
    #####: 4814:	flexend( 1 );
    #####: 4815:	}
        -: 4816:
        -: 4817:
        -: 4818:/* flexfatal - report a fatal error message and terminate */
        -: 4819:
    #####: 4820:void flexfatal( msg )
        -: 4821:const char msg[];
        -: 4822:	{
    #####: 4823:	fprintf( err, _( "%s: fatal internal error, %s\n" ),
        -: 4824:		program_name, msg );
    #####: 4825:	exit( 1 );
        -: 4826:	}
        -: 4827:
        -: 4828:
        -: 4829:/* htoi - convert a hexadecimal digit string to an integer value */
        -: 4830:
    #####: 4831:int htoi( str )
        -: 4832:Char str[];
        -: 4833:	{
        -: 4834:	unsigned int result;
        -: 4835:
    #####: 4836:	(void) sscanf( (char *) str, "%x", &result );
        -: 4837:
    #####: 4838:	return result;
        -: 4839:	}
        -: 4840:
        -: 4841:
        -: 4842:/* lerrif - report an error message formatted with one integer argument */
        -: 4843:
    #####: 4844:void lerrif( msg, arg )
        -: 4845:const char msg[];
        -: 4846:int arg;
        -: 4847:	{
        -: 4848:	char errmsg[MAXLINE];
    #####: 4849:	(void) sprintf( errmsg, msg, arg );
    #####: 4850:	flexerror( errmsg );
    #####: 4851:	}
        -: 4852:
        -: 4853:
        -: 4854:/* lerrsf - report an error message formatted with one string argument */
        -: 4855:
    #####: 4856:void lerrsf( msg, arg )
        -: 4857:const char msg[], arg[];
        -: 4858:	{
        -: 4859:	char errmsg[MAXLINE];
        -: 4860:
    #####: 4861:	(void) sprintf( errmsg, msg, arg );
    #####: 4862:	flexerror( errmsg );
    #####: 4863:	}
        -: 4864:
        -: 4865:
        -: 4866:/* line_directive_out - spit out a "#line" statement */
        -: 4867:
       13: 4868:void line_directive_out( output_file, do_infile )
        -: 4869:FILE *output_file;
        -: 4870:int do_infile;
        -: 4871:	{
        -: 4872:	char directive[MAXLINE], filename[MAXLINE];
        -: 4873:	char *s1, *s2, *s3;
        -: 4874:	static char line_fmt[] = "#line %d \"%s\"\n";
        -: 4875:
       13: 4876:	if ( ! gen_line_dirs )
    #####: 4877:		return;
        -: 4878:
       13: 4879:	if ( (do_infile && ! infilename) || (! do_infile && ! outfilename) )
        -: 4880:		/* don't know the filename to use, skip */
    #####: 4881:		return;
        -: 4882:
       13: 4883:	s1 = do_infile ? infilename : outfilename;
       13: 4884:	s2 = filename;
       13: 4885:	s3 = &filename[sizeof( filename ) - 2];
        -: 4886:
      480: 4887:	while ( s2 < s3 && *s1 )
        -: 4888:		{
      454: 4889:		if ( *s1 == '\\' )
        -: 4890:			/* Escape the '\' */
    #####: 4891:			*s2++ = '\\';
        -: 4892:
      454: 4893:		*s2++ = *s1++;
        -: 4894:		}
        -: 4895:
       13: 4896:	*s2 = '\0';
        -: 4897:
       13: 4898:	if ( do_infile )
       10: 4899:		sprintf( directive, line_fmt, linenum, filename );
        -: 4900:	else
        -: 4901:		{
        3: 4902:		if ( output_file == stdout )
        -: 4903:			/* Account for the line directive itself. */
        3: 4904:			++out_linenum;
        -: 4905:
        3: 4906:		sprintf( directive, line_fmt, out_linenum, filename );
        -: 4907:		}
        -: 4908:
        -: 4909:	/* If output_file is nil then we should put the directive in
        -: 4910:	 * the accumulated actions.
        -: 4911:	 */
       13: 4912:	if ( output_file )
        -: 4913:		{
        4: 4914:		fputs( directive, output_file );
        -: 4915:		}
        -: 4916:	else
        9: 4917:		add_action( directive );
        -: 4918:	}
        -: 4919:
        -: 4920:
        -: 4921:/* mark_defs1 - mark the current position in the action array as
        -: 4922: *               representing where the user's section 1 definitions end
        -: 4923: *		 and the prolog begins
        -: 4924: */
        1: 4925:void mark_defs1()
        -: 4926:	{
        1: 4927:	defs1_offset = 0;
        1: 4928:	action_array[action_index++] = '\0';
        1: 4929:	action_offset = prolog_offset = action_index;
        1: 4930:	action_array[action_index] = '\0';
        1: 4931:	}
        -: 4932:
        -: 4933:
        -: 4934:/* mark_prolog - mark the current position in the action array as
        -: 4935: *               representing the end of the action prolog
        -: 4936: */
        1: 4937:void mark_prolog()
        -: 4938:	{
        1: 4939:	action_array[action_index++] = '\0';
        1: 4940:	action_offset = action_index;
        1: 4941:	action_array[action_index] = '\0';
        1: 4942:	}
        -: 4943:
        -: 4944:
        -: 4945:/* mk2data - generate a data statement for a two-dimensional array
        -: 4946: *
        -: 4947: * Generates a data statement initializing the current 2-D array to "value".
        -: 4948: */
    #####: 4949:void mk2data( value )
        -: 4950:int value;
        -: 4951:	{
    #####: 4952:	if ( datapos >= NUMDATAITEMS )
        -: 4953:		{
    #####: 4954:		outc( ',' );
    #####: 4955:		dataflush();
        -: 4956:		}
        -: 4957:
    #####: 4958:	if ( datapos == 0 )
        -: 4959:		/* Indent. */
    #####: 4960:		out( "    " );
        -: 4961:
        -: 4962:	else
    #####: 4963:		outc( ',' );
        -: 4964:
    #####: 4965:	++datapos;
        -: 4966:
    #####: 4967:	out_dec( "%5d", value );
    #####: 4968:	}
        -: 4969:
        -: 4970:
        -: 4971:/* mkdata - generate a data statement
        -: 4972: *
        -: 4973: * Generates a data statement initializing the current array element to
        -: 4974: * "value".
        -: 4975: */
      462: 4976:void mkdata( value )
        -: 4977:int value;
        -: 4978:	{
      462: 4979:	if ( datapos >= NUMDATAITEMS )
        -: 4980:		{
       42: 4981:		outc( ',' );
       42: 4982:		dataflush();
        -: 4983:		}
        -: 4984:
      462: 4985:	if ( datapos == 0 )
        -: 4986:		/* Indent. */
       50: 4987:		out( "    " );
        -: 4988:	else
      412: 4989:		outc( ',' );
        -: 4990:
      462: 4991:	++datapos;
        -: 4992:
      462: 4993:	out_dec( "%5d", value );
      462: 4994:	}
        -: 4995:
        -: 4996:
        -: 4997:/* myctoi - return the integer represented by a string of digits */
        -: 4998:
    #####: 4999:int myctoi( array )
        -: 5000:char array[];
        -: 5001:	{
    #####: 5002:	int val = 0;
        -: 5003:
    #####: 5004:	(void) sscanf( array, "%d", &val );
        -: 5005:
    #####: 5006:	return val;
        -: 5007:	}
        -: 5008:
        -: 5009:
        -: 5010:/* myesc - return character corresponding to escape sequence */
        -: 5011:
    #####: 5012:Char myesc( array )
        -: 5013:Char array[];
        -: 5014:	{
        -: 5015:	Char c, esc_char;
        -: 5016:
    #####: 5017:	switch ( array[1] )
        -: 5018:		{
    #####: 5019:		case 'b': return '\b';
    #####: 5020:		case 'f': return '\f';
    #####: 5021:		case 'n': return '\n';
    #####: 5022:		case 'r': return '\r';
    #####: 5023:		case 't': return '\t';
        -: 5024:
        -: 5025:#if __STDC__
    #####: 5026:		case 'a': return '\a';
    #####: 5027:		case 'v': return '\v';
        -: 5028:#else
        -: 5029:		case 'a': return '\007';
        -: 5030:		case 'v': return '\013';
        -: 5031:#endif
        -: 5032:
        -: 5033:		case '0':
        -: 5034:		case '1':
        -: 5035:		case '2':
        -: 5036:		case '3':
        -: 5037:		case '4':
        -: 5038:		case '5':
        -: 5039:		case '6':
        -: 5040:		case '7':
        -: 5041:			{ /* \<octal> */
    #####: 5042:			int sptr = 1;
        -: 5043:
    #####: 5044:			while ( isascii( array[sptr] ) &&
    #####: 5045:				isdigit( array[sptr] ) )
        -: 5046:				/* Don't increment inside loop control
        -: 5047:				 * because if isdigit() is a macro it might
        -: 5048:				 * expand into multiple increments ...
        -: 5049:				 */
    #####: 5050:				++sptr;
        -: 5051:
    #####: 5052:			c = array[sptr];
    #####: 5053:			array[sptr] = '\0';
        -: 5054:
    #####: 5055:			esc_char = otoi( array + 1 );
        -: 5056:
    #####: 5057:			array[sptr] = c;
        -: 5058:
    #####: 5059:			return esc_char;
        -: 5060:			}
        -: 5061:
        -: 5062:		case 'x':
        -: 5063:			{ /* \x<hex> */
    #####: 5064:			int sptr = 2;
        -: 5065:
    #####: 5066:			while ( isascii( array[sptr] ) &&
    #####: 5067:				isxdigit( (char) array[sptr] ) )
        -: 5068:				/* Don't increment inside loop control
        -: 5069:				 * because if isdigit() is a macro it might
        -: 5070:				 * expand into multiple increments ...
        -: 5071:				 */
    #####: 5072:				++sptr;
        -: 5073:
    #####: 5074:			c = array[sptr];
    #####: 5075:			array[sptr] = '\0';
        -: 5076:
    #####: 5077:			esc_char = htoi( array + 2 );
        -: 5078:
    #####: 5079:			array[sptr] = c;
        -: 5080:
    #####: 5081:			return esc_char;
        -: 5082:			}
        -: 5083:
        -: 5084:		default:
    #####: 5085:			return array[1];
        -: 5086:		}
        -: 5087:	}
        -: 5088:
        -: 5089:
        -: 5090:/* otoi - convert an octal digit string to an integer value */
        -: 5091:
    #####: 5092:int otoi( str )
        -: 5093:Char str[];
        -: 5094:	{
        -: 5095:	unsigned int result;
        -: 5096:
    #####: 5097:	(void) sscanf( (char *) str, "%o", &result );
    #####: 5098:	return result;
        -: 5099:	}
        -: 5100:
        -: 5101:
        -: 5102:/* out - various flavors of outputing a (possibly formatted) string for the
        -: 5103: *	 generated scanner, keeping track of the line count.
        -: 5104: */
        -: 5105:
       53: 5106:void out( str )
        -: 5107:const char str[];
        -: 5108:	{
       53: 5109:	fputs( str, stdout );
       53: 5110:	out_line_count( str );
       53: 5111:	}
        -: 5112:
      472: 5113:void out_dec( fmt, n )
        -: 5114:const char fmt[];
        -: 5115:int n;
        -: 5116:	{
      472: 5117:	printf( fmt, n );
      472: 5118:	out_line_count( fmt );
      472: 5119:	}
        -: 5120:
    #####: 5121:void out_dec2( fmt, n1, n2 )
        -: 5122:const char fmt[];
        -: 5123:int n1, n2;
        -: 5124:	{
    #####: 5125:	printf( fmt, n1, n2 );
    #####: 5126:	out_line_count( fmt );
    #####: 5127:	}
        -: 5128:
    #####: 5129:void out_hex( fmt, x )
        -: 5130:const char fmt[];
        -: 5131:unsigned int x;
        -: 5132:	{
    #####: 5133:	printf( fmt, x );
    #####: 5134:	out_line_count( fmt );
    #####: 5135:	}
        -: 5136:
     1960: 5137:void out_line_count( str )
        -: 5138:const char str[];
        -: 5139:	{
        -: 5140:	register int i;
        -: 5141:
    36796: 5142:	for ( i = 0; str[i]; ++i )
    34836: 5143:		if ( str[i] == '\n' )
       84: 5144:			++out_linenum;
     1960: 5145:	}
        -: 5146:
        4: 5147:void out_str( fmt, str )
        -: 5148:const char fmt[], str[];
        -: 5149:	{
        4: 5150:	printf( fmt, str );
        4: 5151:	out_line_count( fmt );
        4: 5152:	out_line_count( str );
        4: 5153:	}
        -: 5154:
    #####: 5155:void out_str3( fmt, s1, s2, s3 )
        -: 5156:const char fmt[], s1[], s2[], s3[];
        -: 5157:	{
    #####: 5158:	printf( fmt, s1, s2, s3 );
    #####: 5159:	out_line_count( fmt );
    #####: 5160:	out_line_count( s1 );
    #####: 5161:	out_line_count( s2 );
    #####: 5162:	out_line_count( s3 );
    #####: 5163:	}
        -: 5164:
        8: 5165:void out_str_dec( fmt, str, n )
        -: 5166:const char fmt[], str[];
        -: 5167:int n;
        -: 5168:	{
        8: 5169:	printf( fmt, str, n );
        8: 5170:	out_line_count( fmt );
        8: 5171:	out_line_count( str );
        8: 5172:	}
        -: 5173:
      738: 5174:void outc( c )
        -: 5175:int c;
        -: 5176:	{
      738: 5177:	putc( c, stdout );
        -: 5178:
      738: 5179:	if ( c == '\n' )
       54: 5180:		++out_linenum;
      738: 5181:	}
        -: 5182:
     1411: 5183:void outn( str )
        -: 5184:const char str[];
        -: 5185:	{
     1411: 5186:	puts( str );
     1411: 5187:	out_line_count( str );
     1411: 5188:	++out_linenum;
     1411: 5189:	}
        -: 5190:
        -: 5191:
        -: 5192:/* readable_form - return the the human-readable form of a character
        -: 5193: *
        -: 5194: * The returned string is in static storage.
        -: 5195: */
        -: 5196:
    #####: 5197:char *readable_form( c )
        -: 5198:register int c;
        -: 5199:	{
        -: 5200:	static char rform[10];
        -: 5201:
    #####: 5202:	if ( (c >= 0 && c < 32) || c >= 127 )
        -: 5203:		{
    #####: 5204:		switch ( c )
        -: 5205:			{
    #####: 5206:			case '\b': return "\\b";
    #####: 5207:			case '\f': return "\\f";
    #####: 5208:			case '\n': return "\\n";
    #####: 5209:			case '\r': return "\\r";
    #####: 5210:			case '\t': return "\\t";
        -: 5211:
        -: 5212:#if __STDC__
    #####: 5213:			case '\a': return "\\a";
    #####: 5214:			case '\v': return "\\v";
        -: 5215:#endif
        -: 5216:
        -: 5217:			default:
    #####: 5218:				(void) sprintf( rform, "\\%.3o",
        -: 5219:						(unsigned int) c );
    #####: 5220:				return rform;
        -: 5221:			}
        -: 5222:		}
        -: 5223:
    #####: 5224:	else if ( c == ' ' )
    #####: 5225:		return "' '";
        -: 5226:
        -: 5227:	else
        -: 5228:		{
    #####: 5229:		rform[0] = c;
    #####: 5230:		rform[1] = '\0';
        -: 5231:
    #####: 5232:		return rform;
        -: 5233:		}
        -: 5234:	}
        -: 5235:
        -: 5236:
        -: 5237:/* reallocate_array - increase the size of a dynamic array */
        -: 5238:
    #####: 5239:void *reallocate_array( array, size, element_size )
        -: 5240:void *array;
        -: 5241:int size;
        -: 5242:size_t element_size;
        -: 5243:	{
        -: 5244:	register void *new_array;
    #####: 5245:	size_t num_bytes = element_size * size;
        -: 5246:
    #####: 5247:	new_array = flex_realloc( array, num_bytes );
    #####: 5248:	if ( ! new_array )
    #####: 5249:		flexfatal( _( "attempt to increase array size failed" ) );
        -: 5250:
    #####: 5251:	return new_array;
        -: 5252:	}
        -: 5253:
        -: 5254:
        -: 5255:/* skelout - write out one section of the skeleton file
        -: 5256: *
        -: 5257: * Description
        -: 5258: *    Copies skelfile or skel array to stdout until a line beginning with
        -: 5259: *    "%%" or EOF is found.
        -: 5260: */
       20: 5261:void skelout()
        -: 5262:	{
        -: 5263:	char buf_storage[MAXLINE];
       20: 5264:	char *buf = buf_storage;
       20: 5265:	int do_copy = 1;
        -: 5266:
        -: 5267:	/* Loop pulling lines either from the skelfile, if we're using
        -: 5268:	 * one, or from the skel[] array.
        -: 5269:	 */
     3086: 5270:	while ( skelfile ?
    #####: 5271:		(fgets( buf, MAXLINE, skelfile ) != NULL) :
     1533: 5272:		((buf = (char *) skel[skel_ind++]) != 0) )
        -: 5273:		{ /* copy from skel array */
     1532: 5274:		if ( buf[0] == '%' )
        -: 5275:			{ /* control line */
      117: 5276:			switch ( buf[1] )
        -: 5277:				{
        -: 5278:				case '%':
       19: 5279:					return;
        -: 5280:
        -: 5281:				case '+':
       26: 5282:					do_copy = C_plus_plus;
       26: 5283:					break;
        -: 5284:
        -: 5285:				case '-':
       34: 5286:					do_copy = ! C_plus_plus;
       34: 5287:					break;
        -: 5288:
        -: 5289:				case '*':
       38: 5290:					do_copy = 1;
       38: 5291:					break;
        -: 5292:
        -: 5293:				default:
    #####: 5294:					flexfatal(
        -: 5295:					_( "bad line in skeleton file" ) );
        -: 5296:				}
        -: 5297:			}
        -: 5298:
     1415: 5299:		else if ( do_copy )
        -: 5300:			{
     1302: 5301:			if ( skelfile )
        -: 5302:				/* Skeleton file reads include final
        -: 5303:				 * newline, skel[] array does not.
        -: 5304:				 */
    #####: 5305:				out( buf );
        -: 5306:			else
     1302: 5307:				outn( buf );
        -: 5308:			}
        -: 5309:		}
        -: 5310:	}
        -: 5311:
        -: 5312:
        -: 5313:/* transition_struct_out - output a yy_trans_info structure
        -: 5314: *
        -: 5315: * outputs the yy_trans_info structure with the two elements, element_v and
        -: 5316: * element_n.  Formats the output with spaces and carriage returns.
        -: 5317: */
        -: 5318:
    #####: 5319:void transition_struct_out( element_v, element_n )
        -: 5320:int element_v, element_n;
        -: 5321:	{
    #####: 5322:	out_dec2( " {%4d,%4d },", element_v, element_n );
        -: 5323:
    #####: 5324:	datapos += TRANS_STRUCT_PRINT_LENGTH;
        -: 5325:
    #####: 5326:	if ( datapos >= 79 - TRANS_STRUCT_PRINT_LENGTH )
        -: 5327:		{
    #####: 5328:		outc( '\n' );
        -: 5329:
    #####: 5330:		if ( ++dataline % 10 == 0 )
    #####: 5331:			outc( '\n' );
        -: 5332:
    #####: 5333:		datapos = 0;
        -: 5334:		}
    #####: 5335:	}
        -: 5336:
        -: 5337:
        -: 5338:/* The following is only needed when building flex's parser using certain
        -: 5339: * broken versions of bison.
        -: 5340: */
    #####: 5341:void *yy_flex_xmalloc( size )
        -: 5342:int size;
        -: 5343:	{
    #####: 5344:	void *result = flex_alloc( (size_t) size );
        -: 5345:
    #####: 5346:	if ( ! result  )
    #####: 5347:		flexfatal(
        -: 5348:			_( "memory allocation failed in yy_flex_xmalloc()" ) );
        -: 5349:
    #####: 5350:	return result;
        -: 5351:	}
        -: 5352:
        -: 5353:
        -: 5354:/* zero_out - set a region of memory to 0
        -: 5355: *
        -: 5356: * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
        -: 5357: */
        -: 5358:
        1: 5359:void zero_out( region_ptr, size_in_bytes )
        -: 5360:char *region_ptr;
        -: 5361:size_t size_in_bytes;
        -: 5362:	{
        -: 5363:	register char *rp, *rp_end;
        -: 5364:
        1: 5365:	rp = region_ptr;
        1: 5366:	rp_end = region_ptr + size_in_bytes;
        -: 5367:
     8002: 5368:	while ( rp < rp_end )
     8000: 5369:		*rp++ = 0;
        1: 5370:	}
        -: 5371:/* nfa - NFA construction routines */
        -: 5372:
        -: 5373:/*-
        -: 5374: * Copyright (c) 1990 The Regents of the University of California.
        -: 5375: * All rights reserved.
        -: 5376: *
        -: 5377: * This code is derived from software contributed to Berkeley by
        -: 5378: * Vern Paxson.
        -: 5379: * 
        -: 5380: * The United States Government has rights in this work pursuant
        -: 5381: * to contract no. DE-AC03-76SF00098 between the United States
        -: 5382: * Department of Energy and the University of California.
        -: 5383: *
        -: 5384: * Redistribution and use in source and binary forms are permitted provided
        -: 5385: * that: (1) source distributions retain this entire copyright notice and
        -: 5386: * comment, and (2) distributions including binaries display the following
        -: 5387: * acknowledgement:  ``This product includes software developed by the
        -: 5388: * University of California, Berkeley and its contributors'' in the
        -: 5389: * documentation or other materials provided with the distribution and in
        -: 5390: * all advertising materials mentioning features or use of this software.
        -: 5391: * Neither the name of the University nor the names of its contributors may
        -: 5392: * be used to endorse or promote products derived from this software without
        -: 5393: * specific prior written permission.
        -: 5394: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 5395: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 5396: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 5397: */
        -: 5398:
        -: 5399:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 5400:
        -: 5401:
        -: 5402:
        -: 5403:/* declare functions that have forward references */
        -: 5404:
        -: 5405:int dupmachine PROTO((int));
        -: 5406:void mkxtion PROTO((int, int));
        -: 5407:
        -: 5408:
        -: 5409:/* add_accept - add an accepting state to a machine
        -: 5410: *
        -: 5411: * accepting_number becomes mach's accepting number.
        -: 5412: */
        -: 5413:
        7: 5414:void add_accept( mach, accepting_number )
        -: 5415:int mach, accepting_number;
        -: 5416:	{
        -: 5417:	/* Hang the accepting number off an epsilon state.  if it is associated
        -: 5418:	 * with a state that has a non-epsilon out-transition, then the state
        -: 5419:	 * will accept BEFORE it makes that transition, i.e., one character
        -: 5420:	 * too soon.
        -: 5421:	 */
        -: 5422:
        7: 5423:	if ( transchar[finalst[mach]] == SYM_EPSILON )
        2: 5424:		accptnum[finalst[mach]] = accepting_number;
        -: 5425:
        -: 5426:#ifndef F_B38
        -: 5427:	else
        -: 5428:#else
        -: 5429:
        -: 5430:#endif
        -: 5431:		{
        5: 5432:		int astate = mkstate( SYM_EPSILON );
        5: 5433:		accptnum[astate] = accepting_number;
        5: 5434:		(void) link_machines( mach, astate );
        -: 5435:		}
        7: 5436:	}
        -: 5437:
        -: 5438:
        -: 5439:/* copysingl - make a given number of copies of a singleton machine
        -: 5440: *
        -: 5441: * synopsis
        -: 5442: *
        -: 5443: *   newsng = copysingl( singl, num );
        -: 5444: *
        -: 5445: *     newsng - a new singleton composed of num copies of singl
        -: 5446: *     singl  - a singleton machine
        -: 5447: *     num    - the number of copies of singl to be present in newsng
        -: 5448: */
        -: 5449:
    #####: 5450:int copysingl( singl, num )
        -: 5451:int singl, num;
        -: 5452:	{
        -: 5453:	int copy, i;
        -: 5454:
    #####: 5455:	copy = mkstate( SYM_EPSILON );
        -: 5456:
    #####: 5457:	for ( i = 1; i <= num; ++i )
    #####: 5458:		copy = link_machines( copy, dupmachine( singl ) );
        -: 5459:
    #####: 5460:	return copy;
        -: 5461:	}
        -: 5462:
        -: 5463:
        -: 5464:/* dumpnfa - debugging routine to write out an nfa */
        -: 5465:
    #####: 5466:void dumpnfa( state1 )
        -: 5467:int state1;
        -: 5468:
        -: 5469:	{
        -: 5470:	int sym, tsp1, tsp2, anum, ns;
        -: 5471:
    #####: 5472:	fprintf( err,
        -: 5473:	_( "\n\n********** beginning dump of nfa with start state %d\n" ),
        -: 5474:		state1 );
        -: 5475:
        -: 5476:	/* We probably should loop starting at firstst[state1] and going to
        -: 5477:	 * lastst[state1], but they're not maintained properly when we "or"
        -: 5478:	 * all of the rules together.  So we use our knowledge that the machine
        -: 5479:	 * starts at state 1 and ends at lastnfa.
        -: 5480:	 */
        -: 5481:
        -: 5482:	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
    #####: 5483:	for ( ns = 1; ns <= lastnfa; ++ns )
        -: 5484:		{
    #####: 5485:		fprintf( err, _( "state # %4d\t" ), ns );
        -: 5486:
    #####: 5487:		sym = transchar[ns];
    #####: 5488:		tsp1 = trans1[ns];
    #####: 5489:		tsp2 = trans2[ns];
    #####: 5490:		anum = accptnum[ns];
        -: 5491:
    #####: 5492:		fprintf( err, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
        -: 5493:
    #####: 5494:		if ( anum != NIL )
    #####: 5495:			fprintf( err, "  [%d]", anum );
        -: 5496:
    #####: 5497:		fprintf( err, "\n" );
        -: 5498:		}
        -: 5499:
    #####: 5500:	fprintf( err, _( "********** end of dump\n" ) );
    #####: 5501:	}
        -: 5502:
        -: 5503:
        -: 5504:/* dupmachine - make a duplicate of a given machine
        -: 5505: *
        -: 5506: * synopsis
        -: 5507: *
        -: 5508: *   copy = dupmachine( mach );
        -: 5509: *
        -: 5510: *     copy - holds duplicate of mach
        -: 5511: *     mach - machine to be duplicated
        -: 5512: *
        -: 5513: * note that the copy of mach is NOT an exact duplicate; rather, all the
        -: 5514: * transition states values are adjusted so that the copy is self-contained,
        -: 5515: * as the original should have been.
        -: 5516: *
        -: 5517: * also note that the original MUST be contiguous, with its low and high
        -: 5518: * states accessible by the arrays firstst and lastst
        -: 5519: */
        -: 5520:
    #####: 5521:int dupmachine( mach )
        -: 5522:int mach;
        -: 5523:	{
        -: 5524:	int i, init, state_offset;
    #####: 5525:	int state = 0;
    #####: 5526:	int last = lastst[mach];
        -: 5527:
    #####: 5528:	for ( i = firstst[mach]; i <= last; ++i )
        -: 5529:		{
    #####: 5530:		state = mkstate( transchar[i] );
        -: 5531:
    #####: 5532:		if ( trans1[i] != NO_TRANSITION )
        -: 5533:			{
    #####: 5534:			mkxtion( finalst[state], trans1[i] + state - i );
        -: 5535:
    #####: 5536:			if ( transchar[i] == SYM_EPSILON &&
    #####: 5537:			     trans2[i] != NO_TRANSITION )
    #####: 5538:				mkxtion( finalst[state],
    #####: 5539:					trans2[i] + state - i );
        -: 5540:			}
        -: 5541:
    #####: 5542:		accptnum[state] = accptnum[i];
        -: 5543:		}
        -: 5544:
    #####: 5545:	if ( state == 0 )
    #####: 5546:		flexfatal( _( "empty machine in dupmachine()" ) );
        -: 5547:
    #####: 5548:	state_offset = state - i + 1;
        -: 5549:
    #####: 5550:	init = mach + state_offset;
    #####: 5551:	firstst[init] = firstst[mach] + state_offset;
    #####: 5552:	finalst[init] = finalst[mach] + state_offset;
    #####: 5553:	lastst[init] = lastst[mach] + state_offset;
        -: 5554:
    #####: 5555:	return init;
        -: 5556:	}
        -: 5557:
        -: 5558:
        -: 5559:/* finish_rule - finish up the processing for a rule
        -: 5560: *
        -: 5561: * An accepting number is added to the given machine.  If variable_trail_rule
        -: 5562: * is true then the rule has trailing context and both the head and trail
        -: 5563: * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
        -: 5564: * the machine recognizes a pattern with trailing context and headcnt is
        -: 5565: * the number of characters in the matched part of the pattern, or zero
        -: 5566: * if the matched part has variable length.  trailcnt is the number of
        -: 5567: * trailing context characters in the pattern, or zero if the trailing
        -: 5568: * context has variable length.
        -: 5569: */
        -: 5570:
        7: 5571:void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
        -: 5572:int mach, variable_trail_rule, headcnt, trailcnt;
        -: 5573:	{
        -: 5574:	char action_text[MAXLINE];
        -: 5575:
        7: 5576:	add_accept( mach, num_rules );
        -: 5577:
        -: 5578:	/* We did this in new_rule(), but it often gets the wrong
        -: 5579:	 * number because we do it before we start parsing the current rule.
        -: 5580:	 */
        7: 5581:	rule_linenum[num_rules] = linenum;
        -: 5582:
        -: 5583:	/* If this is a continued action, then the line-number has already
        -: 5584:	 * been updated, giving us the wrong number.
        -: 5585:	 */
        7: 5586:	if ( continued_action )
    #####: 5587:		--rule_linenum[num_rules];
        -: 5588:
        7: 5589:	sprintf( action_text, "case %d:\n", num_rules );
        7: 5590:	add_action( action_text );
        -: 5591:
        7: 5592:	if ( variable_trail_rule )
        -: 5593:		{
    #####: 5594:		rule_type[num_rules] = RULE_VARIABLE;
        -: 5595:
    #####: 5596:		if ( performance_report > 0 )
    #####: 5597:			fprintf( err,
        -: 5598:			_( "Variable trailing context rule at line %d\n" ),
    #####: 5599:				rule_linenum[num_rules] );
        -: 5600:
    #####: 5601:		variable_trailing_context_rules = true;
        -: 5602:		}
        -: 5603:
        -: 5604:	else
        -: 5605:		{
        7: 5606:		rule_type[num_rules] = RULE_NORMAL;
        -: 5607:
        7: 5608:		if ( headcnt > 0 || trailcnt > 0 )
        -: 5609:			{
        -: 5610:			/* Do trailing context magic to not match the trailing
        -: 5611:			 * characters.
        -: 5612:			 */
        2: 5613:			char *scanner_cp = "yy_c_buf_p = yy_cp";
        2: 5614:			char *scanner_bp = "yy_bp";
        -: 5615:
        2: 5616:			add_action(
        -: 5617:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
        -: 5618:
        2: 5619:			if ( headcnt > 0 )
        -: 5620:				{
        1: 5621:				sprintf( action_text, "%s = %s + %d;\n",
        -: 5622:				scanner_cp, scanner_bp, headcnt );
        1: 5623:				add_action( action_text );
        -: 5624:				}
        -: 5625:
        -: 5626:			else
        -: 5627:				{
        1: 5628:				sprintf( action_text, "%s -= %d;\n",
        -: 5629:					scanner_cp, trailcnt );
        1: 5630:				add_action( action_text );
        -: 5631:				}
        -: 5632:
        2: 5633:			add_action(
        -: 5634:			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
        -: 5635:			}
        -: 5636:		}
        -: 5637:
        -: 5638:	/* Okay, in the action code at this point yytext and yyleng have
        -: 5639:	 * their proper final values for this rule, so here's the point
        -: 5640:	 * to do any user action.  But don't do it for continued actions,
        -: 5641:	 * as that'll result in multiple YY_RULE_SETUP's.
        -: 5642:	 */
        7: 5643:	if ( ! continued_action )
        7: 5644:		add_action( "YY_RULE_SETUP\n" );
        -: 5645:
        7: 5646:	line_directive_out( (FILE *) 0, 1 );
        7: 5647:	}
        -: 5648:
        -: 5649:
        -: 5650:/* link_machines - connect two machines together
        -: 5651: *
        -: 5652: * synopsis
        -: 5653: *
        -: 5654: *   new = link_machines( first, last );
        -: 5655: *
        -: 5656: *     new    - a machine constructed by connecting first to last
        -: 5657: *     first  - the machine whose successor is to be last
        -: 5658: *     last   - the machine whose predecessor is to be first
        -: 5659: *
        -: 5660: * note: this routine concatenates the machine first with the machine
        -: 5661: *  last to produce a machine new which will pattern-match first first
        -: 5662: *  and then last, and will fail if either of the sub-patterns fails.
        -: 5663: *  FIRST is set to new by the operation.  last is unmolested.
        -: 5664: */
        -: 5665:
       25: 5666:int link_machines( first, last )
        -: 5667:int first, last;
        -: 5668:	{
       25: 5669:	if ( first == NIL )
    #####: 5670:		return last;
        -: 5671:
       25: 5672:	else if ( last == NIL )
    #####: 5673:		return first;
        -: 5674:
        -: 5675:	else
        -: 5676:		{
       25: 5677:		mkxtion( finalst[first], last );
       25: 5678:		finalst[first] = finalst[last];
       25: 5679:		lastst[first] = MAX( lastst[first], lastst[last] );
       25: 5680:		firstst[first] = MIN( firstst[first], firstst[last] );
        -: 5681:
       25: 5682:		return first;
        -: 5683:		}
        -: 5684:	}
        -: 5685:
        -: 5686:
        -: 5687:/* mark_beginning_as_normal - mark each "beginning" state in a machine
        -: 5688: *                            as being a "normal" (i.e., not trailing context-
        -: 5689: *                            associated) states
        -: 5690: *
        -: 5691: * The "beginning" states are the epsilon closure of the first state
        -: 5692: */
        -: 5693:
        1: 5694:void mark_beginning_as_normal( mach )
        -: 5695:register int mach;
        -: 5696:	{
        1: 5697:	switch ( state_type[mach] )
        -: 5698:		{
        -: 5699:		case STATE_NORMAL:
        -: 5700:			/* Oh, we've already visited here. */
    #####: 5701:			return;
        -: 5702:
        -: 5703:		case STATE_TRAILING_CONTEXT:
        1: 5704:			state_type[mach] = STATE_NORMAL;
        -: 5705:
        1: 5706:			if ( transchar[mach] == SYM_EPSILON )
        -: 5707:				{
    #####: 5708:				if ( trans1[mach] != NO_TRANSITION )
    #####: 5709:					mark_beginning_as_normal(
    #####: 5710:						trans1[mach] );
        -: 5711:
    #####: 5712:				if ( trans2[mach] != NO_TRANSITION )
    #####: 5713:					mark_beginning_as_normal(
    #####: 5714:						trans2[mach] );
        -: 5715:				}
        1: 5716:			break;
        -: 5717:
        -: 5718:		default:
    #####: 5719:			flexerror(
        -: 5720:			_( "bad state type in mark_beginning_as_normal()" ) );
    #####: 5721:			break;
        -: 5722:		}
        -: 5723:	}
        -: 5724:
        -: 5725:
        -: 5726:/* mkbranch - make a machine that branches to two machines
        -: 5727: *
        -: 5728: * synopsis
        -: 5729: *
        -: 5730: *   branch = mkbranch( first, second );
        -: 5731: *
        -: 5732: *     branch - a machine which matches either first's pattern or second's
        -: 5733: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5734: *
        -: 5735: * Note that first and second are NEITHER destroyed by the operation.  Also,
        -: 5736: * the resulting machine CANNOT be used with any other "mk" operation except
        -: 5737: * more mkbranch's.  Compare with mkor()
        -: 5738: */
        -: 5739:
        8: 5740:int mkbranch( first, second )
        -: 5741:int first, second;
        -: 5742:	{
        -: 5743:	int eps;
        -: 5744:
        8: 5745:	if ( first == NO_TRANSITION )
    #####: 5746:		return second;
        -: 5747:
        8: 5748:	else if ( second == NO_TRANSITION )
    #####: 5749:		return first;
        -: 5750:
        8: 5751:	eps = mkstate( SYM_EPSILON );
        -: 5752:
        8: 5753:	mkxtion( eps, first );
        8: 5754:	mkxtion( eps, second );
        -: 5755:
        8: 5756:	return eps;
        -: 5757:	}
        -: 5758:
        -: 5759:
        -: 5760:/* mkclos - convert a machine into a closure
        -: 5761: *
        -: 5762: * synopsis
        -: 5763: *   new = mkclos( state );
        -: 5764: *
        -: 5765: * new - a new state which matches the closure of "state"
        -: 5766: */
        -: 5767:
        1: 5768:int mkclos( state )
        -: 5769:int state;
        -: 5770:	{
        1: 5771:	return mkopt( mkposcl( state ) );
        -: 5772:	}
        -: 5773:
        -: 5774:
        -: 5775:/* mkopt - make a machine optional
        -: 5776: *
        -: 5777: * synopsis
        -: 5778: *
        -: 5779: *   new = mkopt( mach );
        -: 5780: *
        -: 5781: *     new  - a machine which optionally matches whatever mach matched
        -: 5782: *     mach - the machine to make optional
        -: 5783: *
        -: 5784: * notes:
        -: 5785: *     1. mach must be the last machine created
        -: 5786: *     2. mach is destroyed by the call
        -: 5787: */
        -: 5788:
        1: 5789:int mkopt( mach )
        -: 5790:int mach;
        -: 5791:	{
        -: 5792:	int eps;
        -: 5793:
        1: 5794:	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
        -: 5795:		{
        1: 5796:		eps = mkstate( SYM_EPSILON );
        1: 5797:		mach = link_machines( mach, eps );
        -: 5798:		}
        -: 5799:
        -: 5800:	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
        -: 5801:	 * some state interior to "mach" might point back to the beginning
        -: 5802:	 * for a closure.
        -: 5803:	 */
        1: 5804:	eps = mkstate( SYM_EPSILON );
        1: 5805:	mach = link_machines( eps, mach );
        -: 5806:
        1: 5807:	mkxtion( mach, finalst[mach] );
        -: 5808:
        1: 5809:	return mach;
        -: 5810:	}
        -: 5811:
        -: 5812:
        -: 5813:/* mkor - make a machine that matches either one of two machines
        -: 5814: *
        -: 5815: * synopsis
        -: 5816: *
        -: 5817: *   new = mkor( first, second );
        -: 5818: *
        -: 5819: *     new - a machine which matches either first's pattern or second's
        -: 5820: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5821: *
        -: 5822: * note that first and second are both destroyed by the operation
        -: 5823: * the code is rather convoluted because an attempt is made to minimize
        -: 5824: * the number of epsilon states needed
        -: 5825: */
        -: 5826:
        1: 5827:int mkor( first, second )
        -: 5828:int first, second;
        -: 5829:	{
        -: 5830:	int eps, orend;
        -: 5831:
        1: 5832:	if ( first == NIL )
    #####: 5833:		return second;
        -: 5834:
        1: 5835:	else if ( second == NIL )
    #####: 5836:		return first;
        -: 5837:
        -: 5838:	else
        -: 5839:		{
        -: 5840:		/* See comment in mkopt() about why we can't use the first
        -: 5841:		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
        -: 5842:		 */
        1: 5843:		eps = mkstate( SYM_EPSILON );
        -: 5844:
        1: 5845:		first = link_machines( eps, first );
        -: 5846:
        -: 5847:#ifndef F_B36
        1: 5848:		mkxtion( first, second );
        -: 5849:#else
        -: 5850:		mkxtion (!  first, second );
        -: 5851:#endif
        -: 5852:
        1: 5853:		if ( SUPER_FREE_EPSILON(finalst[first]) &&
    #####: 5854:		     accptnum[finalst[first]] == NIL )
        -: 5855:			{
    #####: 5856:			orend = finalst[first];
    #####: 5857:			mkxtion( finalst[second], orend );
        -: 5858:			}
        -: 5859:
        1: 5860:		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
    #####: 5861:			  accptnum[finalst[second]] == NIL )
        -: 5862:			{
    #####: 5863:			orend = finalst[second];
    #####: 5864:			mkxtion( finalst[first], orend );
        -: 5865:			}
        -: 5866:
        -: 5867:		else
        -: 5868:			{
        -: 5869:#ifndef F_B19
        1: 5870:			eps = mkstate( SYM_EPSILON );
        -: 5871:#else
        -: 5872:			eps = mkstate (!  SYM_EPSILON );
        -: 5873:#endif
        -: 5874:
        1: 5875:			first = link_machines( first, eps );
        1: 5876:			orend = finalst[first];
        -: 5877:
        1: 5878:			mkxtion( finalst[second], orend );
        -: 5879:			}
        -: 5880:		}
        -: 5881:
        1: 5882:	finalst[first] = orend;
        1: 5883:	return first;
        -: 5884:	}
        -: 5885:
        -: 5886:
        -: 5887:/* mkposcl - convert a machine into a positive closure
        -: 5888: *
        -: 5889: * synopsis
        -: 5890: *   new = mkposcl( state );
        -: 5891: *
        -: 5892: *    new - a machine matching the positive closure of "state"
        -: 5893: */
        -: 5894:
        1: 5895:int mkposcl( state )
        -: 5896:int state;
        -: 5897:	{
        -: 5898:	int eps;
        -: 5899:
        1: 5900:	if ( SUPER_FREE_EPSILON(finalst[state]) )
        -: 5901:		{
    #####: 5902:		mkxtion( finalst[state], state );
    #####: 5903:		return state;
        -: 5904:		}
        -: 5905:
        -: 5906:	else
        -: 5907:		{
        1: 5908:		eps = mkstate( SYM_EPSILON );
        1: 5909:		mkxtion( eps, state );
        1: 5910:		return link_machines( state, eps );
        -: 5911:		}
        -: 5912:	}
        -: 5913:
        -: 5914:
        -: 5915:/* mkrep - make a replicated machine
        -: 5916: *
        -: 5917: * synopsis
        -: 5918: *   new = mkrep( mach, lb, ub );
        -: 5919: *
        -: 5920: *    new - a machine that matches whatever "mach" matched from "lb"
        -: 5921: *          number of times to "ub" number of times
        -: 5922: *
        -: 5923: * note
        -: 5924: *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
        -: 5925: */
        -: 5926:
    #####: 5927:int mkrep( mach, lb, ub )
        -: 5928:int mach, lb, ub;
        -: 5929:	{
        -: 5930:	int base_mach, tail, copy, i;
        -: 5931:
    #####: 5932:	base_mach = copysingl( mach, lb - 1 );
        -: 5933:
    #####: 5934:	if ( ub == INFINITY )
        -: 5935:		{
    #####: 5936:		copy = dupmachine( mach );
    #####: 5937:		mach = link_machines( mach,
        -: 5938:		link_machines( base_mach, mkclos( copy ) ) );
        -: 5939:		}
        -: 5940:
        -: 5941:	else
        -: 5942:		{
    #####: 5943:		tail = mkstate( SYM_EPSILON );
        -: 5944:
    #####: 5945:		for ( i = lb; i < ub; ++i )
        -: 5946:			{
        -: 5947:#ifndef F_B02
    #####: 5948:			copy = dupmachine( mach );
        -: 5949:#else
        -: 5950:			copy = dupmachine (!  mach );
        -: 5951:#endif
    #####: 5952:			tail = mkopt( link_machines( copy, tail ) );
        -: 5953:			}
        -: 5954:
    #####: 5955:		mach = link_machines( mach, link_machines( base_mach, tail ) );
        -: 5956:		}
        -: 5957:
    #####: 5958:	return mach;
        -: 5959:	}
        -: 5960:
        -: 5961:
        -: 5962:/* mkstate - create a state with a transition on a given symbol
        -: 5963: *
        -: 5964: * synopsis
        -: 5965: *
        -: 5966: *   state = mkstate( sym );
        -: 5967: *
        -: 5968: *     state - a new state matching sym
        -: 5969: *     sym   - the symbol the new state is to have an out-transition on
        -: 5970: *
        -: 5971: * note that this routine makes new states in ascending order through the
        -: 5972: * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
        -: 5973: * relies on machines being made in ascending order and that they are
        -: 5974: * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
        -: 5975: * that it admittedly is)
        -: 5976: */
        -: 5977:
       43: 5978:int mkstate( sym )
        -: 5979:int sym;
        -: 5980:	{
       43: 5981:	if ( ++lastnfa >= current_mns )
        -: 5982:		{
    #####: 5983:		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
    #####: 5984:			lerrif(
        -: 5985:		_( "input rules are too complicated (>= %d NFA states)" ),
        -: 5986:				current_mns );
        -: 5987:
    #####: 5988:		++num_reallocs;
        -: 5989:
    #####: 5990:		firstst = reallocate_integer_array( firstst, current_mns );
    #####: 5991:		lastst = reallocate_integer_array( lastst, current_mns );
    #####: 5992:		finalst = reallocate_integer_array( finalst, current_mns );
    #####: 5993:		transchar = reallocate_integer_array( transchar, current_mns );
    #####: 5994:		trans1 = reallocate_integer_array( trans1, current_mns );
    #####: 5995:		trans2 = reallocate_integer_array( trans2, current_mns );
    #####: 5996:		accptnum = reallocate_integer_array( accptnum, current_mns );
    #####: 5997:		assoc_rule =
    #####: 5998:			reallocate_integer_array( assoc_rule, current_mns );
    #####: 5999:		state_type =
    #####: 6000:			reallocate_integer_array( state_type, current_mns );
        -: 6001:		}
        -: 6002:
       43: 6003:	firstst[lastnfa] = lastnfa;
       43: 6004:	finalst[lastnfa] = lastnfa;
       43: 6005:	lastst[lastnfa] = lastnfa;
       43: 6006:	transchar[lastnfa] = sym;
       43: 6007:	trans1[lastnfa] = NO_TRANSITION;
       43: 6008:	trans2[lastnfa] = NO_TRANSITION;
       43: 6009:	accptnum[lastnfa] = NIL;
       43: 6010:	assoc_rule[lastnfa] = num_rules;
       43: 6011:	state_type[lastnfa] = current_state_type;
        -: 6012:
        -: 6013:	/* Fix up equivalence classes base on this transition.  Note that any
        -: 6014:	 * character which has its own transition gets its own equivalence
        -: 6015:	 * class.  Thus only characters which are only in character classes
        -: 6016:	 * have a chance at being in the same equivalence class.  E.g. "a|b"
        -: 6017:	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
        -: 6018:	 * puts them in the same equivalence class (barring other differences
        -: 6019:	 * elsewhere in the input).
        -: 6020:	 */
        -: 6021:
       43: 6022:	if ( sym < 0 )
        -: 6023:		{
        -: 6024:		/* We don't have to update the equivalence classes since
        -: 6025:		 * that was already done when the ccl was created for the
        -: 6026:		 * first time.
        -: 6027:		 */
        -: 6028:		}
        -: 6029:
       41: 6030:	else if ( sym == SYM_EPSILON )
       22: 6031:		++numeps;
        -: 6032:
        -: 6033:	else
        -: 6034:		{
       19: 6035:		check_char( sym );
        -: 6036:
       19: 6037:		if ( useecs )
        -: 6038:			/* Map NUL's to csize. */
       19: 6039:			mkechar( sym ? sym : csize, nextecm, ecgroup );
        -: 6040:		}
        -: 6041:
       43: 6042:	return lastnfa;
        -: 6043:	}
        -: 6044:
        -: 6045:
        -: 6046:/* mkxtion - make a transition from one state to another
        -: 6047: *
        -: 6048: * synopsis
        -: 6049: *
        -: 6050: *   mkxtion( statefrom, stateto );
        -: 6051: *
        -: 6052: *     statefrom - the state from which the transition is to be made
        -: 6053: *     stateto   - the state to which the transition is to be made
        -: 6054: */
        -: 6055:
       45: 6056:void mkxtion( statefrom, stateto )
        -: 6057:int statefrom, stateto;
        -: 6058:	{
       45: 6059:	if ( trans1[statefrom] == NO_TRANSITION )
       34: 6060:		trans1[statefrom] = stateto;
        -: 6061:
       22: 6062:	else if ( (transchar[statefrom] != SYM_EPSILON) ||
       11: 6063:		  (trans2[statefrom] != NO_TRANSITION) )
    #####: 6064:		flexfatal( _( "found too many transitions in mkxtion()" ) );
        -: 6065:
        -: 6066:	else
        -: 6067:		{ /* second out-transition for an epsilon state */
       11: 6068:		++eps2;
       11: 6069:		trans2[statefrom] = stateto;
        -: 6070:		}
       45: 6071:	}
        -: 6072:
        -: 6073:/* new_rule - initialize for a new rule */
        -: 6074:
        7: 6075:void new_rule()
        -: 6076:	{
        7: 6077:	if ( ++num_rules >= current_max_rules )
        -: 6078:		{
    #####: 6079:		++num_reallocs;
    #####: 6080:		current_max_rules += MAX_RULES_INCREMENT;
    #####: 6081:		rule_type = reallocate_integer_array( rule_type,
        -: 6082:							current_max_rules );
    #####: 6083:		rule_linenum = reallocate_integer_array( rule_linenum,
        -: 6084:							current_max_rules );
    #####: 6085:		rule_useful = reallocate_integer_array( rule_useful,
        -: 6086:							current_max_rules );
        -: 6087:		}
        -: 6088:
        7: 6089:	if ( num_rules > MAX_RULE )
    #####: 6090:		lerrif( _( "too many rules (> %d)!" ), MAX_RULE );
        -: 6091:
        7: 6092:	rule_linenum[num_rules] = linenum;
        7: 6093:	rule_useful[num_rules] = false;
        7: 6094:	}
        -: 6095:/* File created from flex.skl via mkskel.sh */
        -: 6096:
        -: 6097:
        -: 6098:const char *skel[] = {
        -: 6099:  "/* A lexical scanner generated by flex */",
        -: 6100:  "",
        -: 6101:  "/* Scanner skeleton version:",
        -: 6102:  " * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $",
        -: 6103:  " */",
        -: 6104:  "",
        -: 6105:  "#define FLEX_SCANNER",
        -: 6106:  "#define YY_FLEX_MAJOR_VERSION 2",
        -: 6107:  "#define YY_FLEX_MINOR_VERSION 5",
        -: 6108:  "",
        -: 6109:  "%-",
        -: 6110:  "#include <stdio.h>",
        -: 6111:  "%*",
        -: 6112:  "",
        -: 6113:  "",
        -: 6114:  "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
        -: 6115:  "#ifdef c_plusplus",
        -: 6116:  "#ifndef __cplusplus",
        -: 6117:  "#define __cplusplus",
        -: 6118:  "#endif",
        -: 6119:  "#endif",
        -: 6120:  "",
        -: 6121:  "",
        -: 6122:  "#ifdef __cplusplus",
        -: 6123:  "",
        -: 6124:  "#include <stdlib.h>",
        -: 6125:  "%+",
        -: 6126:  "class istream;",
        -: 6127:  "%*",
        -: 6128:  "#include <unistd.h>",
        -: 6129:  "",
        -: 6130:  "/* Use prototypes in function declarations. */",
        -: 6131:  "#define YY_USE_PROTOS",
        -: 6132:  "",
        -: 6133:  "/* The \"const\" storage-class-modifier is valid. */",
        -: 6134:  "#define YY_USE_CONST",
        -: 6135:  "",
        -: 6136:  "#else	/* ! __cplusplus */",
        -: 6137:  "",
        -: 6138:  "#if __STDC__",
        -: 6139:  "",
        -: 6140:  "#define YY_USE_PROTOS",
        -: 6141:  "#define YY_USE_CONST",
        -: 6142:  "",
        -: 6143:  "#endif	/* __STDC__ */",
        -: 6144:  "#endif	/* ! __cplusplus */",
        -: 6145:  "",
        -: 6146:  "#ifdef __TURBOC__",
        -: 6147:  " #pragma warn -rch",
        -: 6148:  " #pragma warn -use",
        -: 6149:  "#include <io.h>",
        -: 6150:  "#include <stdlib.h>",
        -: 6151:  "#define YY_USE_CONST",
        -: 6152:  "#define YY_USE_PROTOS",
        -: 6153:  "#endif",
        -: 6154:  "",
        -: 6155:  "#ifdef YY_USE_CONST",
        -: 6156:  "#define yyconst const",
        -: 6157:  "#else",
        -: 6158:  "#define yyconst",
        -: 6159:  "#endif",
        -: 6160:  "",
        -: 6161:  "",
        -: 6162:  "#ifdef YY_USE_PROTOS",
        -: 6163:  "#define YY_PROTO(proto) proto",
        -: 6164:  "#else",
        -: 6165:  "#define YY_PROTO(proto) ()",
        -: 6166:  "#endif",
        -: 6167:  "",
        -: 6168:  "/* Returned upon end-of-file. */",
        -: 6169:  "#define YY_NULL 0",
        -: 6170:  "",
        -: 6171:  "/* Promotes a possibly negative, possibly signed char to an unsigned",
        -: 6172:  " * integer for use as an array index.  If the signed char is negative,",
        -: 6173:  " * we want to instead treat it as an 8-bit unsigned char, hence the",
        -: 6174:  " * double cast.",
        -: 6175:  " */",
        -: 6176:  "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
        -: 6177:  "",
        -: 6178:  "/* Enter a start condition.  This macro really ought to take a parameter,",
        -: 6179:  " * but we do it the disgusting crufty way forced on us by the ()-less",
        -: 6180:  " * definition of BEGIN.",
        -: 6181:  " */",
        -: 6182:  "#define BEGIN yy_start = 1 + 2 *",
        -: 6183:  "",
        -: 6184:  "/* Translate the current start state into a value that can be later handed",
        -: 6185:  " * to BEGIN to return to the state.  The YYSTATE alias is for lex",
        -: 6186:  " * compatibility.",
        -: 6187:  " */",
        -: 6188:  "#define YY_START ((yy_start - 1) / 2)",
        -: 6189:  "#define YYSTATE YY_START",
        -: 6190:  "",
        -: 6191:  "/* Action number for EOF rule of a given start state. */",
        -: 6192:  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
        -: 6193:  "",
        -: 6194:  "/* Special action meaning \"start processing a new file\". */",
        -: 6195:  "#define YY_NEW_FILE yyrestart( yyin )",
        -: 6196:  "",
        -: 6197:  "#define YY_END_OF_BUFFER_CHAR 0",
        -: 6198:  "",
        -: 6199:  "/* Size of default input buffer. */",
        -: 6200:  "#define YY_BUF_SIZE 16384",
        -: 6201:  "",
        -: 6202:  "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
        -: 6203:  "",
        -: 6204:  "extern int yyleng;",
        -: 6205:  "%-",
        -: 6206:  "extern FILE *yyin, *yyout;",
        -: 6207:  "%*",
        -: 6208:  "",
        -: 6209:  "#define EOB_ACT_CONTINUE_SCAN 0",
        -: 6210:  "#define EOB_ACT_END_OF_FILE 1",
        -: 6211:  "#define EOB_ACT_LAST_MATCH 2",
        -: 6212:  "",
        -: 6213:  "/* The funky do-while in the following #define is used to turn the definition",
        -: 6214:  " * int a single C statement (which needs a semi-colon terminator).  This",
        -: 6215:  " * avoids problems with code like:",
        -: 6216:  " *",
        -: 6217:  " * 	if ( condition_holds )",
        -: 6218:  " *		yyless( 5 );",
        -: 6219:  " *	else",
        -: 6220:  " *		do_something_else();",
        -: 6221:  " *",
        -: 6222:  " * Prior to using the do-while the compiler would get upset at the",
        -: 6223:  " * \"else\" because it interpreted the \"if\" statement as being all",
        -: 6224:  " * done when it reached the ';' after the yyless() call.",
        -: 6225:  " */",
        -: 6226:  "",
        -: 6227:  "/* Return all but the first 'n' matched characters back to the input stream. */",
        -: 6228:  "",
        -: 6229:  "#define yyless(n) \\",
        -: 6230:  "	do \\",
        -: 6231:  "		{ \\",
        -: 6232:  "		/* Undo effects of setting up yytext. */ \\",
        -: 6233:  "		*yy_cp = yy_hold_char; \\",
        -: 6234:  "		YY_RESTORE_YY_MORE_OFFSET \\",
        -: 6235:  "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
        -: 6236:  "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
        -: 6237:  "		} \\",
        -: 6238:  "	while ( 0 )",
        -: 6239:  "",
        -: 6240:  "#define unput(c) yyunput( c, yytext_ptr )",
        -: 6241:  "",
        -: 6242:  "/* The following is because we cannot portably get our hands on size_t",
        -: 6243:  " * (without autoconf's help, which isn't available because we want",
        -: 6244:  " * flex-generated scanners to compile on their own).",
        -: 6245:  " */",
        -: 6246:  "typedef unsigned int yy_size_t;",
        -: 6247:  "",
        -: 6248:  "",
        -: 6249:  "struct yy_buffer_state",
        -: 6250:  "	{",
        -: 6251:  "%-",
        -: 6252:  "	FILE *yy_input_file;",
        -: 6253:  "%+",
        -: 6254:  "	istream* yy_input_file;",
        -: 6255:  "%*",
        -: 6256:  "",
        -: 6257:  "	char *yy_ch_buf;		/* input buffer */",
        -: 6258:  "	char *yy_buf_pos;		/* current position in input buffer */",
        -: 6259:  "",
        -: 6260:  "	/* Size of input buffer in bytes, not including room for EOB",
        -: 6261:  "	 * characters.",
        -: 6262:  "	 */",
        -: 6263:  "	yy_size_t yy_buf_size;",
        -: 6264:  "",
        -: 6265:  "	/* Number of characters read into yy_ch_buf, not including EOB",
        -: 6266:  "	 * characters.",
        -: 6267:  "	 */",
        -: 6268:  "	int yy_n_chars;",
        -: 6269:  "",
        -: 6270:  "	/* Whether we \"own\" the buffer - i.e., we know we created it,",
        -: 6271:  "	 * and can realloc() it to grow it, and should free() it to",
        -: 6272:  "	 * delete it.",
        -: 6273:  "	 */",
        -: 6274:  "	int yy_is_our_buffer;",
        -: 6275:  "",
        -: 6276:  "	/* Whether this is an \"interactive\" input source; if so, and",
        -: 6277:  "	 * if we're using stdio for input, then we want to use getc()",
        -: 6278:  "	 * instead of fread(), to make sure we stop fetching input after",
        -: 6279:  "	 * each newline.",
        -: 6280:  "	 */",
        -: 6281:  "	int yy_is_interactive;",
        -: 6282:  "",
        -: 6283:  "	/* Whether we're considered to be at the beginning of a line.",
        -: 6284:  "	 * If so, '^' rules will be active on the next match, otherwise",
        -: 6285:  "	 * not.",
        -: 6286:  "	 */",
        -: 6287:  "	int yy_at_bol;",
        -: 6288:  "",
        -: 6289:  "	/* Whether to try to fill the input buffer when we reach the",
        -: 6290:  "	 * end of it.",
        -: 6291:  "	 */",
        -: 6292:  "	int yy_fill_buffer;",
        -: 6293:  "",
        -: 6294:  "	int yy_buffer_status;",
        -: 6295:  "#define YY_BUFFER_NEW 0",
        -: 6296:  "#define YY_BUFFER_NORMAL 1",
        -: 6297:  "	/* When an EOF's been seen but there's still some text to process",
        -: 6298:  "	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
        -: 6299:  "	 * shouldn't try reading from the input source any more.  We might",
        -: 6300:  "	 * still have a bunch of tokens to match, though, because of",
        -: 6301:  "	 * possible backing-up.",
        -: 6302:  "	 *",
        -: 6303:  "	 * When we actually see the EOF, we change the status to \"new\"",
        -: 6304:  "	 * (via yyrestart()), so that the user can continue scanning by",
        -: 6305:  "	 * just pointing yyin at a new input file.",
        -: 6306:  "	 */",
        -: 6307:  "#define YY_BUFFER_EOF_PENDING 2",
        -: 6308:  "	};",
        -: 6309:  "",
        -: 6310:  "%- Standard (non-C++) definition",
        -: 6311:  "static YY_BUFFER_STATE yy_current_buffer = 0;",
        -: 6312:  "%*",
        -: 6313:  "",
        -: 6314:  "/* We provide macros for accessing buffer states in case in the",
        -: 6315:  " * future we want to put the buffer states in a more general",
        -: 6316:  " * \"scanner state\".",
        -: 6317:  " */",
        -: 6318:  "#define YY_CURRENT_BUFFER yy_current_buffer",
        -: 6319:  "",
        -: 6320:  "",
        -: 6321:  "%- Standard (non-C++) definition",
        -: 6322:  "/* yy_hold_char holds the character lost when yytext is formed. */",
        -: 6323:  "static char yy_hold_char;",
        -: 6324:  "",
        -: 6325:  "static int yy_n_chars;		/* number of characters read into yy_ch_buf */",
        -: 6326:  "",
        -: 6327:  "",
        -: 6328:  "int yyleng;",
        -: 6329:  "",
        -: 6330:  "/* Points to current character in buffer. */",
        -: 6331:  "static char *yy_c_buf_p = (char *) 0;",
        -: 6332:  "static int yy_init = 1;		/* whether we need to initialize */",
        -: 6333:  "static int yy_start = 0;	/* start state number */",
        -: 6334:  "",
        -: 6335:  "/* Flag which is used to allow yywrap()'s to do buffer switches",
        -: 6336:  " * instead of setting up a fresh yyin.  A bit of a hack ...",
        -: 6337:  " */",
        -: 6338:  "static int yy_did_buffer_switch_on_eof;",
        -: 6339:  "",
        -: 6340:  "void yyrestart YY_PROTO(( FILE *input_file ));",
        -: 6341:  "",
        -: 6342:  "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));",
        -: 6343:  "void yy_load_buffer_state YY_PROTO(( void ));",
        -: 6344:  "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));",
        -: 6345:  "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 6346:  "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));",
        -: 6347:  "void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 6348:  "#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )",
        -: 6349:  "",
        -: 6350:  "YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));",
        -: 6351:  "YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));",
        -: 6352:  "YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));",
        -: 6353:  "%*",
        -: 6354:  "",
        -: 6355:  "static void *yy_flex_alloc YY_PROTO(( yy_size_t ));",
        -: 6356:  "static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));",
        -: 6357:  "static void yy_flex_free YY_PROTO(( void * ));",
        -: 6358:  "",
        -: 6359:  "#define yy_new_buffer yy_create_buffer",
        -: 6360:  "",
        -: 6361:  "#define yy_set_interactive(is_interactive) \\",
        -: 6362:  "	{ \\",
        -: 6363:  "	if ( ! yy_current_buffer ) \\",
        -: 6364:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\",
        -: 6365:  "	yy_current_buffer->yy_is_interactive = is_interactive; \\",
        -: 6366:  "	}",
        -: 6367:  "",
        -: 6368:  "#define yy_set_bol(at_bol) \\",
        -: 6369:  "	{ \\",
        -: 6370:  "	if ( ! yy_current_buffer ) \\",
        -: 6371:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\",
        -: 6372:  "	yy_current_buffer->yy_at_bol = at_bol; \\",
        -: 6373:  "	}",
        -: 6374:  "",
        -: 6375:  "#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)",
        -: 6376:  "",
        -: 6377:  "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
        -: 6378:  "",
        -: 6379:  "%- Standard (non-C++) definition",
        -: 6380:  "static yy_state_type yy_get_previous_state YY_PROTO(( void ));",
        -: 6381:  "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));",
        -: 6382:  "static int yy_get_next_buffer YY_PROTO(( void ));",
        -: 6383:  "static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));",
        -: 6384:  "%*",
        -: 6385:  "",
        -: 6386:  "/* Done after the current pattern has been matched and before the",
        -: 6387:  " * corresponding action - sets up yytext.",
        -: 6388:  " */",
        -: 6389:  "#define YY_DO_BEFORE_ACTION \\",
        -: 6390:  "	yytext_ptr = yy_bp; \\",
        -: 6391:  "%% code to fiddle yytext and yyleng for yymore() goes here",
        -: 6392:  "	yy_hold_char = *yy_cp; \\",
        -: 6393:  "	*yy_cp = '\\0'; \\",
        -: 6394:  "%% code to copy yytext_ptr to yytext[] goes here, if %array",
        -: 6395:  "	yy_c_buf_p = yy_cp;",
        -: 6396:  "",
        -: 6397:  "%% data tables for the DFA and the user's section 1 definitions go here",
        -: 6398:  "",
        -: 6399:  "/* Macros after this point can all be overridden by user definitions in",
        -: 6400:  " * section 1.",
        -: 6401:  " */",
        -: 6402:  "",
        -: 6403:  "#ifndef YY_SKIP_YYWRAP",
        -: 6404:  "#ifdef __cplusplus",
        -: 6405:  "extern \"C\" int yywrap YY_PROTO(( void ));",
        -: 6406:  "#else",
        -: 6407:  "extern int yywrap YY_PROTO(( void ));",
        -: 6408:  "#endif",
        -: 6409:  "#endif",
        -: 6410:  "",
        -: 6411:  "%-",
        -: 6412:  "#ifndef YY_NO_UNPUT",
        -: 6413:  "static void yyunput YY_PROTO(( int c, char *buf_ptr ));",
        -: 6414:  "#endif",
        -: 6415:  "%*",
        -: 6416:  "",
        -: 6417:  "#ifndef yytext_ptr",
        -: 6418:  "static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));",
        -: 6419:  "#endif",
        -: 6420:  "",
        -: 6421:  "#ifdef YY_NEED_STRLEN",
        -: 6422:  "static int yy_flex_strlen YY_PROTO(( yyconst char * ));",
        -: 6423:  "#endif",
        -: 6424:  "",
        -: 6425:  "#ifndef YY_NO_INPUT",
        -: 6426:  "%- Standard (non-C++) definition",
        -: 6427:  "#ifdef __cplusplus",
        -: 6428:  "static int yyinput YY_PROTO(( void ));",
        -: 6429:  "#else",
        -: 6430:  "static int input YY_PROTO(( void ));",
        -: 6431:  "#endif",
        -: 6432:  "%*",
        -: 6433:  "#endif",
        -: 6434:  "",
        -: 6435:  "#if YY_STACK_USED",
        -: 6436:  "static int yy_start_stack_ptr = 0;",
        -: 6437:  "static int yy_start_stack_depth = 0;",
        -: 6438:  "static int *yy_start_stack = 0;",
        -: 6439:  "#ifndef YY_NO_PUSH_STATE",
        -: 6440:  "static void yy_push_state YY_PROTO(( int new_state ));",
        -: 6441:  "#endif",
        -: 6442:  "#ifndef YY_NO_POP_STATE",
        -: 6443:  "static void yy_pop_state YY_PROTO(( void ));",
        -: 6444:  "#endif",
        -: 6445:  "#ifndef YY_NO_TOP_STATE",
        -: 6446:  "static int yy_top_state YY_PROTO(( void ));",
        -: 6447:  "#endif",
        -: 6448:  "",
        -: 6449:  "#else",
        -: 6450:  "#define YY_NO_PUSH_STATE 1",
        -: 6451:  "#define YY_NO_POP_STATE 1",
        -: 6452:  "#define YY_NO_TOP_STATE 1",
        -: 6453:  "#endif",
        -: 6454:  "",
        -: 6455:  "#ifdef YY_MALLOC_DECL",
        -: 6456:  "YY_MALLOC_DECL",
        -: 6457:  "#else",
        -: 6458:  "#if __STDC__",
        -: 6459:  "#ifndef __cplusplus",
        -: 6460:  "#include <stdlib.h>",
        -: 6461:  "#endif",
        -: 6462:  "#else",
        -: 6463:  "/* Just try to get by without declaring the routines.  This will fail",
        -: 6464:  " * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)",
        -: 6465:  " * or sizeof(void*) != sizeof(int).",
        -: 6466:  " */",
        -: 6467:  "#endif",
        -: 6468:  "#endif",
        -: 6469:  "",
        -: 6470:  "/* Amount of stuff to slurp up with each read. */",
        -: 6471:  "#ifndef YY_READ_BUF_SIZE",
        -: 6472:  "#define YY_READ_BUF_SIZE 8192",
        -: 6473:  "#endif",
        -: 6474:  "",
        -: 6475:  "/* Copy whatever the last rule matched to the standard output. */",
        -: 6476:  "",
        -: 6477:  "#ifndef ECHO",
        -: 6478:  "%- Standard (non-C++) definition",
        -: 6479:  "/* This used to be an fputs(), but since the string might contain NUL's,",
        -: 6480:  " * we now use fwrite().",
        -: 6481:  " */",
        -: 6482:  "#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )",
        -: 6483:  "%+ C++ definition",
        -: 6484:  "#define ECHO LexerOutput( yytext, yyleng )",
        -: 6485:  "%*",
        -: 6486:  "#endif",
        -: 6487:  "",
        -: 6488:  "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
        -: 6489:  " * is returned in \"result\".",
        -: 6490:  " */",
        -: 6491:  "#ifndef YY_INPUT",
        -: 6492:  "#define YY_INPUT(buf,result,max_size) \\",
        -: 6493:  "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
        -: 6494:  "%+ C++ definition",
        -: 6495:  "	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\",
        -: 6496:  "		YY_FATAL_ERROR( \"input in flex scanner failed\" );",
        -: 6497:  "%*",
        -: 6498:  "#endif",
        -: 6499:  "",
        -: 6500:  "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
        -: 6501:  " * we don't want an extra ';' after the \"return\" because that will cause",
        -: 6502:  " * some compilers to complain about unreachable statements.",
        -: 6503:  " */",
        -: 6504:  "#ifndef yyterminate",
        -: 6505:  "#define yyterminate() return YY_NULL",
        -: 6506:  "#endif",
        -: 6507:  "",
        -: 6508:  "/* Number of entries by which start-condition stack grows. */",
        -: 6509:  "#ifndef YY_START_STACK_INCR",
        -: 6510:  "#define YY_START_STACK_INCR 25",
        -: 6511:  "#endif",
        -: 6512:  "",
        -: 6513:  "/* Report a fatal error. */",
        -: 6514:  "#ifndef YY_FATAL_ERROR",
        -: 6515:  "%-",
        -: 6516:  "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )",
        -: 6517:  "%+",
        -: 6518:  "#define YY_FATAL_ERROR(msg) LexerError( msg )",
        -: 6519:  "%*",
        -: 6520:  "#endif",
        -: 6521:  "",
        -: 6522:  "/* Default declaration of generated scanner - a define so the user can",
        -: 6523:  " * easily add parameters.",
        -: 6524:  " */",
        -: 6525:  "#ifndef YY_DECL",
        -: 6526:  "%- Standard (non-C++) definition",
        -: 6527:  "#define YY_DECL int yylex YY_PROTO(( void ))",
        -: 6528:  "%+ C++ definition",
        -: 6529:  "#define YY_DECL int yyFlexLexer::yylex()",
        -: 6530:  "%*",
        -: 6531:  "#endif",
        -: 6532:  "",
        -: 6533:  "/* Code executed at the beginning of each rule, after yytext and yyleng",
        -: 6534:  " * have been set up.",
        -: 6535:  " */",
        -: 6536:  "#ifndef YY_USER_ACTION",
        -: 6537:  "#define YY_USER_ACTION",
        -: 6538:  "#endif",
        -: 6539:  "",
        -: 6540:  "/* Code executed at the end of each rule. */",
        -: 6541:  "#ifndef YY_BREAK",
        -: 6542:  "#define YY_BREAK break;",
        -: 6543:  "#endif",
        -: 6544:  "",
        -: 6545:  "%% YY_RULE_SETUP definition goes here",
        -: 6546:  "",
        -: 6547:  "YY_DECL",
        -: 6548:  "	{",
        -: 6549:  "	register yy_state_type yy_current_state;",
        -: 6550:  "	register char *yy_cp, *yy_bp;",
        -: 6551:  "	register int yy_act;",
        -: 6552:  "",
        -: 6553:  "%% user's declarations go here",
        -: 6554:  "",
        -: 6555:  "	if ( yy_init )",
        -: 6556:  "		{",
        -: 6557:  "		yy_init = 0;",
        -: 6558:  "",
        -: 6559:  "#ifdef YY_USER_INIT",
        -: 6560:  "		YY_USER_INIT;",
        -: 6561:  "#endif",
        -: 6562:  "",
        -: 6563:  "		if ( ! yy_start )",
        -: 6564:  "			yy_start = 1;	/* first start state */",
        -: 6565:  "",
        -: 6566:  "		if ( ! yyin )",
        -: 6567:  "%-",
        -: 6568:  "			yyin = stdin;",
        -: 6569:  "%+",
        -: 6570:  "			yyin = &cin;",
        -: 6571:  "%*",
        -: 6572:  "",
        -: 6573:  "		if ( ! yyout )",
        -: 6574:  "%-",
        -: 6575:  "			yyout = stdout;",
        -: 6576:  "%+",
        -: 6577:  "			yyout = &cout;",
        -: 6578:  "%*",
        -: 6579:  "",
        -: 6580:  "		if ( ! yy_current_buffer )",
        -: 6581:  "			yy_current_buffer =",
        -: 6582:  "				yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6583:  "",
        -: 6584:  "		yy_load_buffer_state();",
        -: 6585:  "		}",
        -: 6586:  "",
        -: 6587:  "	while ( 1 )		/* loops until end-of-file is reached */",
        -: 6588:  "		{",
        -: 6589:  "%% yymore()-related code goes here",
        -: 6590:  "		yy_cp = yy_c_buf_p;",
        -: 6591:  "",
        -: 6592:  "		/* Support of yytext. */",
        -: 6593:  "		*yy_cp = yy_hold_char;",
        -: 6594:  "",
        -: 6595:  "		/* yy_bp points to the position in yy_ch_buf of the start of",
        -: 6596:  "		 * the current run.",
        -: 6597:  "		 */",
        -: 6598:  "		yy_bp = yy_cp;",
        -: 6599:  "",
        -: 6600:  "%% code to set up and find next match goes here",
        -: 6601:  "",
        -: 6602:  "yy_find_action:",
        -: 6603:  "%% code to find the action number goes here",
        -: 6604:  "",
        -: 6605:  "		YY_DO_BEFORE_ACTION;",
        -: 6606:  "",
        -: 6607:  "%% code for yylineno update goes here",
        -: 6608:  "",
        -: 6609:  "do_action:	/* This label is used only to access EOF actions. */",
        -: 6610:  "",
        -: 6611:  "%% debug code goes here",
        -: 6612:  "",
        -: 6613:  "		switch ( yy_act )",
        -: 6614:  "	{ /* beginning of action switch */",
        -: 6615:  "%% actions go here",
        -: 6616:  "",
        -: 6617:  "	case YY_END_OF_BUFFER:",
        -: 6618:  "		{",
        -: 6619:  "		/* Amount of text matched not including the EOB char. */",
        -: 6620:  "		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;",
        -: 6621:  "",
        -: 6622:  "		/* Undo the effects of YY_DO_BEFORE_ACTION. */",
        -: 6623:  "		*yy_cp = yy_hold_char;",
        -: 6624:  "		YY_RESTORE_YY_MORE_OFFSET",
        -: 6625:  "",
        -: 6626:  "		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )",
        -: 6627:  "			{",
        -: 6628:  "			/* We're scanning a new file or input source.  It's",
        -: 6629:  "			 * possible that this happened because the user",
        -: 6630:  "			 * just pointed yyin at a new source and called",
        -: 6631:  "			 * yylex().  If so, then we have to assure",
        -: 6632:  "			 * consistency between yy_current_buffer and our",
        -: 6633:  "			 * globals.  Here is the right place to do so, because",
        -: 6634:  "			 * this is the first action (other than possibly a",
        -: 6635:  "			 * back-up) that will match for the new input source.",
        -: 6636:  "			 */",
        -: 6637:  "			yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 6638:  "			yy_current_buffer->yy_input_file = yyin;",
        -: 6639:  "			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
        -: 6640:  "			}",
        -: 6641:  "",
        -: 6642:  "		/* Note that here we test for yy_c_buf_p \"<=\" to the position",
        -: 6643:  "		 * of the first EOB in the buffer, since yy_c_buf_p will",
        -: 6644:  "		 * already have been incremented past the NUL character",
        -: 6645:  "		 * (since all states make transitions on EOB to the",
        -: 6646:  "		 * end-of-buffer state).  Contrast this with the test",
        -: 6647:  "		 * in input().",
        -: 6648:  "		 */",
        -: 6649:  "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6650:  "			{ /* This was really a NUL. */",
        -: 6651:  "			yy_state_type yy_next_state;",
        -: 6652:  "",
        -: 6653:  "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
        -: 6654:  "",
        -: 6655:  "			yy_current_state = yy_get_previous_state();",
        -: 6656:  "",
        -: 6657:  "			/* Okay, we're now positioned to make the NUL",
        -: 6658:  "			 * transition.  We couldn't have",
        -: 6659:  "			 * yy_get_previous_state() go ahead and do it",
        -: 6660:  "			 * for us because it doesn't know how to deal",
        -: 6661:  "			 * with the possibility of jamming (and we don't",
        -: 6662:  "			 * want to build jamming into it because then it",
        -: 6663:  "			 * will run more slowly).",
        -: 6664:  "			 */",
        -: 6665:  "",
        -: 6666:  "			yy_next_state = yy_try_NUL_trans( yy_current_state );",
        -: 6667:  "",
        -: 6668:  "			yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6669:  "",
        -: 6670:  "			if ( yy_next_state )",
        -: 6671:  "				{",
        -: 6672:  "				/* Consume the NUL. */",
        -: 6673:  "				yy_cp = ++yy_c_buf_p;",
        -: 6674:  "				yy_current_state = yy_next_state;",
        -: 6675:  "				goto yy_match;",
        -: 6676:  "				}",
        -: 6677:  "",
        -: 6678:  "			else",
        -: 6679:  "				{",
        -: 6680:  "%% code to do back-up for compressed tables and set up yy_cp goes here",
        -: 6681:  "				goto yy_find_action;",
        -: 6682:  "				}",
        -: 6683:  "			}",
        -: 6684:  "",
        -: 6685:  "		else switch ( yy_get_next_buffer() )",
        -: 6686:  "			{",
        -: 6687:  "			case EOB_ACT_END_OF_FILE:",
        -: 6688:  "				{",
        -: 6689:  "				yy_did_buffer_switch_on_eof = 0;",
        -: 6690:  "",
        -: 6691:  "				if ( yywrap() )",
        -: 6692:  "					{",
        -: 6693:  "					/* Note: because we've taken care in",
        -: 6694:  "					 * yy_get_next_buffer() to have set up",
        -: 6695:  "					 * yytext, we can now set up",
        -: 6696:  "					 * yy_c_buf_p so that if some total",
        -: 6697:  "					 * hoser (like flex itself) wants to",
        -: 6698:  "					 * call the scanner after we return the",
        -: 6699:  "					 * YY_NULL, it'll still work - another",
        -: 6700:  "					 * YY_NULL will get returned.",
        -: 6701:  "					 */",
        -: 6702:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6703:  "",
        -: 6704:  "					yy_act = YY_STATE_EOF(YY_START);",
        -: 6705:  "					goto do_action;",
        -: 6706:  "					}",
        -: 6707:  "",
        -: 6708:  "				else",
        -: 6709:  "					{",
        -: 6710:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 6711:  "						YY_NEW_FILE;",
        -: 6712:  "					}",
        -: 6713:  "				break;",
        -: 6714:  "				}",
        -: 6715:  "",
        -: 6716:  "			case EOB_ACT_CONTINUE_SCAN:",
        -: 6717:  "				yy_c_buf_p =",
        -: 6718:  "					yytext_ptr + yy_amount_of_matched_text;",
        -: 6719:  "",
        -: 6720:  "				yy_current_state = yy_get_previous_state();",
        -: 6721:  "",
        -: 6722:  "				yy_cp = yy_c_buf_p;",
        -: 6723:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6724:  "				goto yy_match;",
        -: 6725:  "",
        -: 6726:  "			case EOB_ACT_LAST_MATCH:",
        -: 6727:  "				yy_c_buf_p =",
        -: 6728:  "				&yy_current_buffer->yy_ch_buf[yy_n_chars];",
        -: 6729:  "",
        -: 6730:  "				yy_current_state = yy_get_previous_state();",
        -: 6731:  "",
        -: 6732:  "				yy_cp = yy_c_buf_p;",
        -: 6733:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6734:  "				goto yy_find_action;",
        -: 6735:  "			}",
        -: 6736:  "		break;",
        -: 6737:  "		}",
        -: 6738:  "",
        -: 6739:  "	default:",
        -: 6740:  "		YY_FATAL_ERROR(",
        -: 6741:  "			\"fatal flex scanner internal error--no action found\" );",
        -: 6742:  "	} /* end of action switch */",
        -: 6743:  "		} /* end of scanning one token */",
        -: 6744:  "	} /* end of yylex */",
        -: 6745:  "",
        -: 6746:  "%+",
        -: 6747:  "yyFlexLexer::yyFlexLexer( istream* arg_yyin, ostream* arg_yyout )",
        -: 6748:  "	{",
        -: 6749:  "	yyin = arg_yyin;",
        -: 6750:  "	yyout = arg_yyout;",
        -: 6751:  "	yy_c_buf_p = 0;",
        -: 6752:  "	yy_init = 1;",
        -: 6753:  "	yy_start = 0;",
        -: 6754:  "	yy_flex_debug = 0;",
        -: 6755:  "	yylineno = 1;	// this will only get updated if %option yylineno",
        -: 6756:  "",
        -: 6757:  "	yy_did_buffer_switch_on_eof = 0;",
        -: 6758:  "",
        -: 6759:  "	yy_looking_for_trail_begin = 0;",
        -: 6760:  "	yy_more_flag = 0;",
        -: 6761:  "	yy_more_len = 0;",
        -: 6762:  "	yy_more_offset = yy_prev_more_offset = 0;",
        -: 6763:  "",
        -: 6764:  "	yy_start_stack_ptr = yy_start_stack_depth = 0;",
        -: 6765:  "	yy_start_stack = 0;",
        -: 6766:  "",
        -: 6767:  "	yy_current_buffer = 0;",
        -: 6768:  "",
        -: 6769:  "#ifdef YY_USES_REJECT",
        -: 6770:  "	yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];",
        -: 6771:  "#else",
        -: 6772:  "	yy_state_buf = 0;",
        -: 6773:  "#endif",
        -: 6774:  "	}",
        -: 6775:  "",
        -: 6776:  "yyFlexLexer::~yyFlexLexer()",
        -: 6777:  "	{",
        -: 6778:  "	delete yy_state_buf;",
        -: 6779:  "	yy_delete_buffer( yy_current_buffer );",
        -: 6780:  "	}",
        -: 6781:  "",
        -: 6782:  "void yyFlexLexer::switch_streams( istream* new_in, ostream* new_out )",
        -: 6783:  "	{",
        -: 6784:  "	if ( new_in )",
        -: 6785:  "		{",
        -: 6786:  "		yy_delete_buffer( yy_current_buffer );",
        -: 6787:  "		yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE ) );",
        -: 6788:  "		}",
        -: 6789:  "",
        -: 6790:  "	if ( new_out )",
        -: 6791:  "		yyout = new_out;",
        -: 6792:  "	}",
        -: 6793:  "",
        -: 6794:  "#ifdef YY_INTERACTIVE",
        -: 6795:  "int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )",
        -: 6796:  "#else",
        -: 6797:  "int yyFlexLexer::LexerInput( char* buf, int max_size )",
        -: 6798:  "#endif",
        -: 6799:  "	{",
        -: 6800:  "	if ( yyin->eof() || yyin->fail() )",
        -: 6801:  "		return 0;",
        -: 6802:  "",
        -: 6803:  "#ifdef YY_INTERACTIVE",
        -: 6804:  "	yyin->get( buf[0] );",
        -: 6805:  "",
        -: 6806:  "	if ( yyin->eof() )",
        -: 6807:  "		return 0;",
        -: 6808:  "",
        -: 6809:  "	if ( yyin->bad() )",
        -: 6810:  "		return -1;",
        -: 6811:  "",
        -: 6812:  "	return 1;",
        -: 6813:  "",
        -: 6814:  "#else",
        -: 6815:  "	(void) yyin->read( buf, max_size );",
        -: 6816:  "",
        -: 6817:  "	if ( yyin->bad() )",
        -: 6818:  "		return -1;",
        -: 6819:  "	else",
        -: 6820:  "		return yyin->gcount();",
        -: 6821:  "#endif",
        -: 6822:  "	}",
        -: 6823:  "",
        -: 6824:  "void yyFlexLexer::LexerOutput( const char* buf, int size )",
        -: 6825:  "	{",
        -: 6826:  "	(void) yyout->write( buf, size );",
        -: 6827:  "	}",
        -: 6828:  "%*",
        -: 6829:  "",
        -: 6830:  "/* yy_get_next_buffer - try to read in a new buffer",
        -: 6831:  " *",
        -: 6832:  " * Returns a code representing an action:",
        -: 6833:  " *	EOB_ACT_LAST_MATCH -",
        -: 6834:  " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
        -: 6835:  " *	EOB_ACT_END_OF_FILE - end of file",
        -: 6836:  " */",
        -: 6837:  "",
        -: 6838:  "%-",
        -: 6839:  "static int yy_get_next_buffer()",
        -: 6840:  "%+",
        -: 6841:  "int yyFlexLexer::yy_get_next_buffer()",
        -: 6842:  "%*",
        -: 6843:  "	{",
        -: 6844:  "	register char *dest = yy_current_buffer->yy_ch_buf;",
        -: 6845:  "	register char *source = yytext_ptr;",
        -: 6846:  "	register int number_to_move, i;",
        -: 6847:  "	int ret_val;",
        -: 6848:  "",
        -: 6849:  "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )",
        -: 6850:  "		YY_FATAL_ERROR(",
        -: 6851:  "		\"fatal flex scanner internal error--end of buffer missed\" );",
        -: 6852:  "",
        -: 6853:  "	if ( yy_current_buffer->yy_fill_buffer == 0 )",
        -: 6854:  "		{ /* Don't try to fill the buffer, so this is an EOF. */",
        -: 6855:  "		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )",
        -: 6856:  "			{",
        -: 6857:  "			/* We matched a single character, the EOB, so",
        -: 6858:  "			 * treat this as a final EOF.",
        -: 6859:  "			 */",
        -: 6860:  "			return EOB_ACT_END_OF_FILE;",
        -: 6861:  "			}",
        -: 6862:  "",
        -: 6863:  "		else",
        -: 6864:  "			{",
        -: 6865:  "			/* We matched some text prior to the EOB, first",
        -: 6866:  "			 * process it.",
        -: 6867:  "			 */",
        -: 6868:  "			return EOB_ACT_LAST_MATCH;",
        -: 6869:  "			}",
        -: 6870:  "		}",
        -: 6871:  "",
        -: 6872:  "	/* Try to read more data. */",
        -: 6873:  "",
        -: 6874:  "	/* First move last chars to start of buffer. */",
        -: 6875:  "	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;",
        -: 6876:  "",
        -: 6877:  "	for ( i = 0; i < number_to_move; ++i )",
        -: 6878:  "		*(dest++) = *(source++);",
        -: 6879:  "",
        -: 6880:  "	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )",
        -: 6881:  "		/* don't do the read, it's not guaranteed to return an EOF,",
        -: 6882:  "		 * just force an EOF",
        -: 6883:  "		 */",
        -: 6884:  "		yy_n_chars = 0;",
        -: 6885:  "",
        -: 6886:  "	else",
        -: 6887:  "		{",
        -: 6888:  "		int num_to_read =",
        -: 6889:  "			yy_current_buffer->yy_buf_size - number_to_move - 1;",
        -: 6890:  "",
        -: 6891:  "		while ( num_to_read <= 0 )",
        -: 6892:  "			{ /* Not enough room in the buffer - grow it. */",
        -: 6893:  "#ifdef YY_USES_REJECT",
        -: 6894:  "			YY_FATAL_ERROR(",
        -: 6895:  "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );",
        -: 6896:  "#else",
        -: 6897:  "",
        -: 6898:  "			/* just a shorter name for the current buffer */",
        -: 6899:  "			YY_BUFFER_STATE b = yy_current_buffer;",
        -: 6900:  "",
        -: 6901:  "			int yy_c_buf_p_offset =",
        -: 6902:  "				(int) (yy_c_buf_p - b->yy_ch_buf);",
        -: 6903:  "",
        -: 6904:  "			if ( b->yy_is_our_buffer )",
        -: 6905:  "				{",
        -: 6906:  "				int new_size = b->yy_buf_size * 2;",
        -: 6907:  "",
        -: 6908:  "				if ( new_size <= 0 )",
        -: 6909:  "					b->yy_buf_size += b->yy_buf_size / 8;",
        -: 6910:  "				else",
        -: 6911:  "					b->yy_buf_size *= 2;",
        -: 6912:  "",
        -: 6913:  "				b->yy_ch_buf = (char *)",
        -: 6914:  "					/* Include room in for 2 EOB chars. */",
        -: 6915:  "					yy_flex_realloc( (void *) b->yy_ch_buf,",
        -: 6916:  "							 b->yy_buf_size + 2 );",
        -: 6917:  "				}",
        -: 6918:  "			else",
        -: 6919:  "				/* Can't grow it, we don't own it. */",
        -: 6920:  "				b->yy_ch_buf = 0;",
        -: 6921:  "",
        -: 6922:  "			if ( ! b->yy_ch_buf )",
        -: 6923:  "				YY_FATAL_ERROR(",
        -: 6924:  "				\"fatal error - scanner input buffer overflow\" );",
        -: 6925:  "",
        -: 6926:  "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
        -: 6927:  "",
        -: 6928:  "			num_to_read = yy_current_buffer->yy_buf_size -",
        -: 6929:  "						number_to_move - 1;",
        -: 6930:  "#endif",
        -: 6931:  "			}",
        -: 6932:  "",
        -: 6933:  "		if ( num_to_read > YY_READ_BUF_SIZE )",
        -: 6934:  "			num_to_read = YY_READ_BUF_SIZE;",
        -: 6935:  "",
        -: 6936:  "		/* Read in more data. */",
        -: 6937:  "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),",
        -: 6938:  "			yy_n_chars, num_to_read );",
        -: 6939:  "		}",
        -: 6940:  "",
        -: 6941:  "	if ( yy_n_chars == 0 )",
        -: 6942:  "		{",
        -: 6943:  "		if ( number_to_move == YY_MORE_ADJ )",
        -: 6944:  "			{",
        -: 6945:  "			ret_val = EOB_ACT_END_OF_FILE;",
        -: 6946:  "			yyrestart( yyin );",
        -: 6947:  "			}",
        -: 6948:  "",
        -: 6949:  "		else",
        -: 6950:  "			{",
        -: 6951:  "			ret_val = EOB_ACT_LAST_MATCH;",
        -: 6952:  "			yy_current_buffer->yy_buffer_status =",
        -: 6953:  "				YY_BUFFER_EOF_PENDING;",
        -: 6954:  "			}",
        -: 6955:  "		}",
        -: 6956:  "",
        -: 6957:  "	else",
        -: 6958:  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
        -: 6959:  "",
        -: 6960:  "	yy_n_chars += number_to_move;",
        -: 6961:  "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
        -: 6962:  "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
        -: 6963:  "",
        -: 6964:  "	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];",
        -: 6965:  "",
        -: 6966:  "	return ret_val;",
        -: 6967:  "	}",
        -: 6968:  "",
        -: 6969:  "",
        -: 6970:  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
        -: 6971:  "",
        -: 6972:  "%-",
        -: 6973:  "static yy_state_type yy_get_previous_state()",
        -: 6974:  "%+",
        -: 6975:  "yy_state_type yyFlexLexer::yy_get_previous_state()",
        -: 6976:  "%*",
        -: 6977:  "	{",
        -: 6978:  "	register yy_state_type yy_current_state;",
        -: 6979:  "	register char *yy_cp;",
        -: 6980:  "",
        -: 6981:  "%% code to get the start state into yy_current_state goes here",
        -: 6982:  "",
        -: 6983:  "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )",
        -: 6984:  "		{",
        -: 6985:  "%% code to find the next state goes here",
        -: 6986:  "		}",
        -: 6987:  "",
        -: 6988:  "	return yy_current_state;",
        -: 6989:  "	}",
        -: 6990:  "",
        -: 6991:  "",
        -: 6992:  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
        -: 6993:  " *",
        -: 6994:  " * synopsis",
        -: 6995:  " *	next_state = yy_try_NUL_trans( current_state );",
        -: 6996:  " */",
        -: 6997:  "",
        -: 6998:  "%-",
        -: 6999:  "#ifdef YY_USE_PROTOS",
        -: 7000:  "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 7001:  "#else",
        -: 7002:  "static yy_state_type yy_try_NUL_trans( yy_current_state )",
        -: 7003:  "yy_state_type yy_current_state;",
        -: 7004:  "#endif",
        -: 7005:  "%+",
        -: 7006:  "yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 7007:  "%*",
        -: 7008:  "	{",
        -: 7009:  "	register int yy_is_jam;",
        -: 7010:  "%% code to find the next state, and perhaps do backing up, goes here",
        -: 7011:  "",
        -: 7012:  "	return yy_is_jam ? 0 : yy_current_state;",
        -: 7013:  "	}",
        -: 7014:  "",
        -: 7015:  "",
        -: 7016:  "%-",
        -: 7017:  "#ifndef YY_NO_UNPUT",
        -: 7018:  "#ifdef YY_USE_PROTOS",
        -: 7019:  "static void yyunput( int c, register char *yy_bp )",
        -: 7020:  "#else",
        -: 7021:  "static void yyunput( c, yy_bp )",
        -: 7022:  "int c;",
        -: 7023:  "register char *yy_bp;",
        -: 7024:  "#endif",
        -: 7025:  "%+",
        -: 7026:  "void yyFlexLexer::yyunput( int c, register char* yy_bp )",
        -: 7027:  "%*",
        -: 7028:  "	{",
        -: 7029:  "	register char *yy_cp = yy_c_buf_p;",
        -: 7030:  "",
        -: 7031:  "	/* undo effects of setting up yytext */",
        -: 7032:  "	*yy_cp = yy_hold_char;",
        -: 7033:  "",
        -: 7034:  "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 7035:  "		{ /* need to shift things up to make room */",
        -: 7036:  "		/* +2 for EOB chars. */",
        -: 7037:  "		register int number_to_move = yy_n_chars + 2;",
        -: 7038:  "		register char *dest = &yy_current_buffer->yy_ch_buf[",
        -: 7039:  "					yy_current_buffer->yy_buf_size + 2];",
        -: 7040:  "		register char *source =",
        -: 7041:  "				&yy_current_buffer->yy_ch_buf[number_to_move];",
        -: 7042:  "",
        -: 7043:  "		while ( source > yy_current_buffer->yy_ch_buf )",
        -: 7044:  "			*--dest = *--source;",
        -: 7045:  "",
        -: 7046:  "		yy_cp += (int) (dest - source);",
        -: 7047:  "		yy_bp += (int) (dest - source);",
        -: 7048:  "		yy_n_chars = yy_current_buffer->yy_buf_size;",
        -: 7049:  "",
        -: 7050:  "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 7051:  "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );",
        -: 7052:  "		}",
        -: 7053:  "",
        -: 7054:  "	*--yy_cp = (char) c;",
        -: 7055:  "",
        -: 7056:  "%% update yylineno here",
        -: 7057:  "",
        -: 7058:  "	yytext_ptr = yy_bp;",
        -: 7059:  "	yy_hold_char = *yy_cp;",
        -: 7060:  "	yy_c_buf_p = yy_cp;",
        -: 7061:  "	}",
        -: 7062:  "%-",
        -: 7063:  "#endif	/* ifndef YY_NO_UNPUT */",
        -: 7064:  "%*",
        -: 7065:  "",
        -: 7066:  "",
        -: 7067:  "%-",
        -: 7068:  "#ifdef __cplusplus",
        -: 7069:  "static int yyinput()",
        -: 7070:  "#else",
        -: 7071:  "static int input()",
        -: 7072:  "#endif",
        -: 7073:  "%+",
        -: 7074:  "int yyFlexLexer::yyinput()",
        -: 7075:  "%*",
        -: 7076:  "	{",
        -: 7077:  "	int c;",
        -: 7078:  "",
        -: 7079:  "	*yy_c_buf_p = yy_hold_char;",
        -: 7080:  "",
        -: 7081:  "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )",
        -: 7082:  "		{",
        -: 7083:  "		/* yy_c_buf_p now points to the character we want to return.",
        -: 7084:  "		 * If this occurs *before* the EOB characters, then it's a",
        -: 7085:  "		 * valid NUL; if not, then we've hit the end of the buffer.",
        -: 7086:  "		 */",
        -: 7087:  "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 7088:  "			/* This was really a NUL. */",
        -: 7089:  "			*yy_c_buf_p = '\\0';",
        -: 7090:  "",
        -: 7091:  "		else",
        -: 7092:  "			{ /* need more input */",
        -: 7093:  "			int offset = yy_c_buf_p - yytext_ptr;",
        -: 7094:  "			++yy_c_buf_p;",
        -: 7095:  "",
        -: 7096:  "			switch ( yy_get_next_buffer() )",
        -: 7097:  "				{",
        -: 7098:  "				case EOB_ACT_END_OF_FILE:",
        -: 7099:  "					{",
        -: 7100:  "					if ( yywrap() )",
        -: 7101:  "						{",
        -: 7102:  "						yy_c_buf_p = yytext_ptr + offset;",
        -: 7103:  "						return EOF;",
        -: 7104:  "						}",
        -: 7105:  "",
        -: 7106:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 7107:  "						YY_NEW_FILE;",
        -: 7108:  "#ifdef __cplusplus",
        -: 7109:  "					return yyinput();",
        -: 7110:  "#else",
        -: 7111:  "					return input();",
        -: 7112:  "#endif",
        -: 7113:  "					}",
        -: 7114:  "",
        -: 7115:  "				case EOB_ACT_CONTINUE_SCAN:",
        -: 7116:  "					yy_c_buf_p = yytext_ptr + offset;",
        -: 7117:  "					break;",
        -: 7118:  "",
        -: 7119:  "				case EOB_ACT_LAST_MATCH:",
        -: 7120:  "#ifdef __cplusplus",
        -: 7121:  "					YY_FATAL_ERROR(",
        -: 7122:  "					\"unexpected last match in yyinput()\" );",
        -: 7123:  "#else",
        -: 7124:  "					YY_FATAL_ERROR(",
        -: 7125:  "					\"unexpected last match in input()\" );",
        -: 7126:  "#endif",
        -: 7127:  "				}",
        -: 7128:  "			}",
        -: 7129:  "		}",
        -: 7130:  "",
        -: 7131:  "	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */",
        -: 7132:  "	*yy_c_buf_p = '\\0';	/* preserve yytext */",
        -: 7133:  "	yy_hold_char = *++yy_c_buf_p;",
        -: 7134:  "",
        -: 7135:  "%% update BOL and yylineno",
        -: 7136:  "",
        -: 7137:  "	return c;",
        -: 7138:  "	}",
        -: 7139:  "",
        -: 7140:  "",
        -: 7141:  "%-",
        -: 7142:  "#ifdef YY_USE_PROTOS",
        -: 7143:  "void yyrestart( FILE *input_file )",
        -: 7144:  "#else",
        -: 7145:  "void yyrestart( input_file )",
        -: 7146:  "FILE *input_file;",
        -: 7147:  "#endif",
        -: 7148:  "%+",
        -: 7149:  "void yyFlexLexer::yyrestart( istream* input_file )",
        -: 7150:  "%*",
        -: 7151:  "	{",
        -: 7152:  "	if ( ! yy_current_buffer )",
        -: 7153:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 7154:  "",
        -: 7155:  "	yy_init_buffer( yy_current_buffer, input_file );",
        -: 7156:  "	yy_load_buffer_state();",
        -: 7157:  "	}",
        -: 7158:  "",
        -: 7159:  "",
        -: 7160:  "%-",
        -: 7161:  "#ifdef YY_USE_PROTOS",
        -: 7162:  "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 7163:  "#else",
        -: 7164:  "void yy_switch_to_buffer( new_buffer )",
        -: 7165:  "YY_BUFFER_STATE new_buffer;",
        -: 7166:  "#endif",
        -: 7167:  "%+",
        -: 7168:  "void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 7169:  "%*",
        -: 7170:  "	{",
        -: 7171:  "	if ( yy_current_buffer == new_buffer )",
        -: 7172:  "		return;",
        -: 7173:  "",
        -: 7174:  "	if ( yy_current_buffer )",
        -: 7175:  "		{",
        -: 7176:  "		/* Flush out information for old buffer. */",
        -: 7177:  "		*yy_c_buf_p = yy_hold_char;",
        -: 7178:  "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;",
        -: 7179:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 7180:  "		}",
        -: 7181:  "",
        -: 7182:  "	yy_current_buffer = new_buffer;",
        -: 7183:  "	yy_load_buffer_state();",
        -: 7184:  "",
        -: 7185:  "	/* We don't actually know whether we did this switch during",
        -: 7186:  "	 * EOF (yywrap()) processing, but the only time this flag",
        -: 7187:  "	 * is looked at is after yywrap() is called, so it's safe",
        -: 7188:  "	 * to go ahead and always set it.",
        -: 7189:  "	 */",
        -: 7190:  "	yy_did_buffer_switch_on_eof = 1;",
        -: 7191:  "	}",
        -: 7192:  "",
        -: 7193:  "",
        -: 7194:  "%-",
        -: 7195:  "#ifdef YY_USE_PROTOS",
        -: 7196:  "void yy_load_buffer_state( void )",
        -: 7197:  "#else",
        -: 7198:  "void yy_load_buffer_state()",
        -: 7199:  "#endif",
        -: 7200:  "%+",
        -: 7201:  "void yyFlexLexer::yy_load_buffer_state()",
        -: 7202:  "%*",
        -: 7203:  "	{",
        -: 7204:  "	yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 7205:  "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
        -: 7206:  "	yyin = yy_current_buffer->yy_input_file;",
        -: 7207:  "	yy_hold_char = *yy_c_buf_p;",
        -: 7208:  "	}",
        -: 7209:  "",
        -: 7210:  "",
        -: 7211:  "%-",
        -: 7212:  "#ifdef YY_USE_PROTOS",
        -: 7213:  "YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )",
        -: 7214:  "#else",
        -: 7215:  "YY_BUFFER_STATE yy_create_buffer( file, size )",
        -: 7216:  "FILE *file;",
        -: 7217:  "int size;",
        -: 7218:  "#endif",
        -: 7219:  "%+",
        -: 7220:  "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )",
        -: 7221:  "%*",
        -: 7222:  "	{",
        -: 7223:  "	YY_BUFFER_STATE b;",
        -: 7224:  "",
        -: 7225:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 7226:  "	if ( ! b )",
        -: 7227:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 7228:  "",
        -: 7229:  "	b->yy_buf_size = size;",
        -: 7230:  "",
        -: 7231:  "	/* yy_ch_buf has to be 2 characters longer than the size given because",
        -: 7232:  "	 * we need to put in 2 end-of-buffer characters.",
        -: 7233:  "	 */",
        -: 7234:  "	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );",
        -: 7235:  "	if ( ! b->yy_ch_buf )",
        -: 7236:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 7237:  "",
        -: 7238:  "	b->yy_is_our_buffer = 1;",
        -: 7239:  "",
        -: 7240:  "	yy_init_buffer( b, file );",
        -: 7241:  "",
        -: 7242:  "	return b;",
        -: 7243:  "	}",
        -: 7244:  "",
        -: 7245:  "",
        -: 7246:  "%-",
        -: 7247:  "#ifdef YY_USE_PROTOS",
        -: 7248:  "void yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 7249:  "#else",
        -: 7250:  "void yy_delete_buffer( b )",
        -: 7251:  "YY_BUFFER_STATE b;",
        -: 7252:  "#endif",
        -: 7253:  "%+",
        -: 7254:  "void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 7255:  "%*",
        -: 7256:  "	{",
        -: 7257:  "	if ( ! b )",
        -: 7258:  "		return;",
        -: 7259:  "",
        -: 7260:  "	if ( b == yy_current_buffer )",
        -: 7261:  "		yy_current_buffer = (YY_BUFFER_STATE) 0;",
        -: 7262:  "",
        -: 7263:  "	if ( b->yy_is_our_buffer )",
        -: 7264:  "		yy_flex_free( (void *) b->yy_ch_buf );",
        -: 7265:  "",
        -: 7266:  "	yy_flex_free( (void *) b );",
        -: 7267:  "	}",
        -: 7268:  "",
        -: 7269:  "",
        -: 7270:  "%-",
        -: 7271:  "#ifndef YY_ALWAYS_INTERACTIVE",
        -: 7272:  "#ifndef YY_NEVER_INTERACTIVE",
        -: 7273:  "extern int isatty YY_PROTO(( int ));",
        -: 7274:  "#endif",
        -: 7275:  "#endif",
        -: 7276:  "",
        -: 7277:  "#ifdef YY_USE_PROTOS",
        -: 7278:  "void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )",
        -: 7279:  "#else",
        -: 7280:  "void yy_init_buffer( b, file )",
        -: 7281:  "YY_BUFFER_STATE b;",
        -: 7282:  "FILE *file;",
        -: 7283:  "#endif",
        -: 7284:  "",
        -: 7285:  "%+",
        -: 7286:  "extern \"C\" int isatty YY_PROTO(( int ));",
        -: 7287:  "void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )",
        -: 7288:  "%*",
        -: 7289:  "",
        -: 7290:  "	{",
        -: 7291:  "	yy_flush_buffer( b );",
        -: 7292:  "",
        -: 7293:  "	b->yy_input_file = file;",
        -: 7294:  "	b->yy_fill_buffer = 1;",
        -: 7295:  "",
        -: 7296:  "%-",
        -: 7297:  "#if YY_ALWAYS_INTERACTIVE",
        -: 7298:  "	b->yy_is_interactive = 1;",
        -: 7299:  "#else",
        -: 7300:  "#if YY_NEVER_INTERACTIVE",
        -: 7301:  "	b->yy_is_interactive = 0;",
        -: 7302:  "#else",
        -: 7303:  "	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;",
        -: 7304:  "#endif",
        -: 7305:  "#endif",
        -: 7306:  "%+",
        -: 7307:  "	b->yy_is_interactive = 0;",
        -: 7308:  "%*",
        -: 7309:  "	}",
        -: 7310:  "",
        -: 7311:  "",
        -: 7312:  "%-",
        -: 7313:  "#ifdef YY_USE_PROTOS",
        -: 7314:  "void yy_flush_buffer( YY_BUFFER_STATE b )",
        -: 7315:  "#else",
        -: 7316:  "void yy_flush_buffer( b )",
        -: 7317:  "YY_BUFFER_STATE b;",
        -: 7318:  "#endif",
        -: 7319:  "",
        -: 7320:  "%+",
        -: 7321:  "void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )",
        -: 7322:  "%*",
        -: 7323:  "	{",
        -: 7324:  "	b->yy_n_chars = 0;",
        -: 7325:  "",
        -: 7326:  "	/* We always need two end-of-buffer characters.  The first causes",
        -: 7327:  "	 * a transition to the end-of-buffer state.  The second causes",
        -: 7328:  "	 * a jam in that state.",
        -: 7329:  "	 */",
        -: 7330:  "	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
        -: 7331:  "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
        -: 7332:  "",
        -: 7333:  "	b->yy_buf_pos = &b->yy_ch_buf[0];",
        -: 7334:  "",
        -: 7335:  "	b->yy_at_bol = 1;",
        -: 7336:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 7337:  "",
        -: 7338:  "	if ( b == yy_current_buffer )",
        -: 7339:  "		yy_load_buffer_state();",
        -: 7340:  "	}",
        -: 7341:  "%*",
        -: 7342:  "",
        -: 7343:  "",
        -: 7344:  "#ifndef YY_NO_SCAN_BUFFER",
        -: 7345:  "%-",
        -: 7346:  "#ifdef YY_USE_PROTOS",
        -: 7347:  "YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )",
        -: 7348:  "#else",
        -: 7349:  "YY_BUFFER_STATE yy_scan_buffer( base, size )",
        -: 7350:  "char *base;",
        -: 7351:  "yy_size_t size;",
        -: 7352:  "#endif",
        -: 7353:  "	{",
        -: 7354:  "	YY_BUFFER_STATE b;",
        -: 7355:  "",
        -: 7356:  "	if ( size < 2 ||",
        -: 7357:  "	     base[size-2] != YY_END_OF_BUFFER_CHAR ||",
        -: 7358:  "	     base[size-1] != YY_END_OF_BUFFER_CHAR )",
        -: 7359:  "		/* They forgot to leave room for the EOB's. */",
        -: 7360:  "		return 0;",
        -: 7361:  "",
        -: 7362:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 7363:  "	if ( ! b )",
        -: 7364:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );",
        -: 7365:  "",
        -: 7366:  "	b->yy_buf_size = size - 2;	/* \"- 2\" to take care of EOB's */",
        -: 7367:  "	b->yy_buf_pos = b->yy_ch_buf = base;",
        -: 7368:  "	b->yy_is_our_buffer = 0;",
        -: 7369:  "	b->yy_input_file = 0;",
        -: 7370:  "	b->yy_n_chars = b->yy_buf_size;",
        -: 7371:  "	b->yy_is_interactive = 0;",
        -: 7372:  "	b->yy_at_bol = 1;",
        -: 7373:  "	b->yy_fill_buffer = 0;",
        -: 7374:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 7375:  "",
        -: 7376:  "	yy_switch_to_buffer( b );",
        -: 7377:  "",
        -: 7378:  "	return b;",
        -: 7379:  "	}",
        -: 7380:  "%*",
        -: 7381:  "#endif",
        -: 7382:  "",
        -: 7383:  "",
        -: 7384:  "#ifndef YY_NO_SCAN_STRING",
        -: 7385:  "%-",
        -: 7386:  "#ifdef YY_USE_PROTOS",
        -: 7387:  "YY_BUFFER_STATE yy_scan_string( yyconst char *str )",
        -: 7388:  "#else",
        -: 7389:  "YY_BUFFER_STATE yy_scan_string( str )",
        -: 7390:  "yyconst char *str;",
        -: 7391:  "#endif",
        -: 7392:  "	{",
        -: 7393:  "	int len;",
        -: 7394:  "	for ( len = 0; str[len]; ++len )",
        -: 7395:  "		;",
        -: 7396:  "",
        -: 7397:  "	return yy_scan_bytes( str, len );",
        -: 7398:  "	}",
        -: 7399:  "%*",
        -: 7400:  "#endif",
        -: 7401:  "",
        -: 7402:  "",
        -: 7403:  "#ifndef YY_NO_SCAN_BYTES",
        -: 7404:  "%-",
        -: 7405:  "#ifdef YY_USE_PROTOS",
        -: 7406:  "YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )",
        -: 7407:  "#else",
        -: 7408:  "YY_BUFFER_STATE yy_scan_bytes( bytes, len )",
        -: 7409:  "yyconst char *bytes;",
        -: 7410:  "int len;",
        -: 7411:  "#endif",
        -: 7412:  "	{",
        -: 7413:  "	YY_BUFFER_STATE b;",
        -: 7414:  "	char *buf;",
        -: 7415:  "	yy_size_t n;",
        -: 7416:  "	int i;",
        -: 7417:  "",
        -: 7418:  "	/* Get memory for full buffer, including space for trailing EOB's. */",
        -: 7419:  "	n = len + 2;",
        -: 7420:  "	buf = (char *) yy_flex_alloc( n );",
        -: 7421:  "	if ( ! buf )",
        -: 7422:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );",
        -: 7423:  "",
        -: 7424:  "	for ( i = 0; i < len; ++i )",
        -: 7425:  "		buf[i] = bytes[i];",
        -: 7426:  "",
        -: 7427:  "	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;",
        -: 7428:  "",
        -: 7429:  "	b = yy_scan_buffer( buf, n );",
        -: 7430:  "	if ( ! b )",
        -: 7431:  "		YY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );",
        -: 7432:  "",
        -: 7433:  "	/* It's okay to grow etc. this buffer, and we should throw it",
        -: 7434:  "	 * away when we're done.",
        -: 7435:  "	 */",
        -: 7436:  "	b->yy_is_our_buffer = 1;",
        -: 7437:  "",
        -: 7438:  "	return b;",
        -: 7439:  "	}",
        -: 7440:  "%*",
        -: 7441:  "#endif",
        -: 7442:  "",
        -: 7443:  "",
        -: 7444:  "#ifndef YY_NO_PUSH_STATE",
        -: 7445:  "%-",
        -: 7446:  "#ifdef YY_USE_PROTOS",
        -: 7447:  "static void yy_push_state( int new_state )",
        -: 7448:  "#else",
        -: 7449:  "static void yy_push_state( new_state )",
        -: 7450:  "int new_state;",
        -: 7451:  "#endif",
        -: 7452:  "%+",
        -: 7453:  "void yyFlexLexer::yy_push_state( int new_state )",
        -: 7454:  "%*",
        -: 7455:  "	{",
        -: 7456:  "	if ( yy_start_stack_ptr >= yy_start_stack_depth )",
        -: 7457:  "		{",
        -: 7458:  "		yy_size_t new_size;",
        -: 7459:  "",
        -: 7460:  "		yy_start_stack_depth += YY_START_STACK_INCR;",
        -: 7461:  "		new_size = yy_start_stack_depth * sizeof( int );",
        -: 7462:  "",
        -: 7463:  "		if ( ! yy_start_stack )",
        -: 7464:  "			yy_start_stack = (int *) yy_flex_alloc( new_size );",
        -: 7465:  "",
        -: 7466:  "		else",
        -: 7467:  "			yy_start_stack = (int *) yy_flex_realloc(",
        -: 7468:  "					(void *) yy_start_stack, new_size );",
        -: 7469:  "",
        -: 7470:  "		if ( ! yy_start_stack )",
        -: 7471:  "			YY_FATAL_ERROR(",
        -: 7472:  "			\"out of memory expanding start-condition stack\" );",
        -: 7473:  "		}",
        -: 7474:  "",
        -: 7475:  "	yy_start_stack[yy_start_stack_ptr++] = YY_START;",
        -: 7476:  "",
        -: 7477:  "	BEGIN(new_state);",
        -: 7478:  "	}",
        -: 7479:  "#endif",
        -: 7480:  "",
        -: 7481:  "",
        -: 7482:  "#ifndef YY_NO_POP_STATE",
        -: 7483:  "%-",
        -: 7484:  "static void yy_pop_state()",
        -: 7485:  "%+",
        -: 7486:  "void yyFlexLexer::yy_pop_state()",
        -: 7487:  "%*",
        -: 7488:  "	{",
        -: 7489:  "	if ( --yy_start_stack_ptr < 0 )",
        -: 7490:  "		YY_FATAL_ERROR( \"start-condition stack underflow\" );",
        -: 7491:  "",
        -: 7492:  "	BEGIN(yy_start_stack[yy_start_stack_ptr]);",
        -: 7493:  "	}",
        -: 7494:  "#endif",
        -: 7495:  "",
        -: 7496:  "",
        -: 7497:  "#ifndef YY_NO_TOP_STATE",
        -: 7498:  "%-",
        -: 7499:  "static int yy_top_state()",
        -: 7500:  "%+",
        -: 7501:  "int yyFlexLexer::yy_top_state()",
        -: 7502:  "%*",
        -: 7503:  "	{",
        -: 7504:  "	return yy_start_stack[yy_start_stack_ptr - 1];",
        -: 7505:  "	}",
        -: 7506:  "#endif",
        -: 7507:  "",
        -: 7508:  "#ifndef YY_EXIT_FAILURE",
        -: 7509:  "#define YY_EXIT_FAILURE 2",
        -: 7510:  "#endif",
        -: 7511:  "",
        -: 7512:  "%-",
        -: 7513:  "#ifdef YY_USE_PROTOS",
        -: 7514:  "static void yy_fatal_error( yyconst char msg[] )",
        -: 7515:  "#else",
        -: 7516:  "static void yy_fatal_error( msg )",
        -: 7517:  "char msg[];",
        -: 7518:  "#endif",
        -: 7519:  "	{",
        -: 7520:  "FILE *err;",  /* ### modified(Jan.24.2001) ### */
        -: 7521:  "	(void) fprintf( err, \"%s\\n\", msg );",
        -: 7522:  "	exit( YY_EXIT_FAILURE );",
        -: 7523:  "	}",
        -: 7524:  "",
        -: 7525:  "%+",
        -: 7526:  "",
        -: 7527:  "void yyFlexLexer::LexerError( yyconst char msg[] )",
        -: 7528:  "	{",
        -: 7529:  "	cerr << msg << '\\n';",
        -: 7530:  "	exit( YY_EXIT_FAILURE );",
        -: 7531:  "	}",
        -: 7532:  "%*",
        -: 7533:  "",
        -: 7534:  "",
        -: 7535:  "/* Redefine yyless() so it works in section 3 code. */",
        -: 7536:  "",
        -: 7537:  "#undef yyless",
        -: 7538:  "#define yyless(n) \\",
        -: 7539:  "	do \\",
        -: 7540:  "		{ \\",
        -: 7541:  "		/* Undo effects of setting up yytext. */ \\",
        -: 7542:  "		yytext[yyleng] = yy_hold_char; \\",
        -: 7543:  "		yy_c_buf_p = yytext + n; \\",
        -: 7544:  "		yy_hold_char = *yy_c_buf_p; \\",
        -: 7545:  "		*yy_c_buf_p = '\\0'; \\",
        -: 7546:  "		yyleng = n; \\",
        -: 7547:  "		} \\",
        -: 7548:  "	while ( 0 )",
        -: 7549:  "",
        -: 7550:  "",
        -: 7551:  "/* Internal utility routines. */",
        -: 7552:  "",
        -: 7553:  "#ifndef yytext_ptr",
        -: 7554:  "#ifdef YY_USE_PROTOS",
        -: 7555:  "static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )",
        -: 7556:  "#else",
        -: 7557:  "static void yy_flex_strncpy( s1, s2, n )",
        -: 7558:  "char *s1;",
        -: 7559:  "yyconst char *s2;",
        -: 7560:  "int n;",
        -: 7561:  "#endif",
        -: 7562:  "	{",
        -: 7563:  "	register int i;",
        -: 7564:  "	for ( i = 0; i < n; ++i )",
        -: 7565:  "		s1[i] = s2[i];",
        -: 7566:  "	}",
        -: 7567:  "#endif",
        -: 7568:  "",
        -: 7569:  "#ifdef YY_NEED_STRLEN",
        -: 7570:  "#ifdef YY_USE_PROTOS",
        -: 7571:  "static int yy_flex_strlen( yyconst char *s )",
        -: 7572:  "#else",
        -: 7573:  "static int yy_flex_strlen( s )",
        -: 7574:  "yyconst char *s;",
        -: 7575:  "#endif",
        -: 7576:  "	{",
        -: 7577:  "	register int n;",
        -: 7578:  "	for ( n = 0; s[n]; ++n )",
        -: 7579:  "		;",
        -: 7580:  "",
        -: 7581:  "	return n;",
        -: 7582:  "	}",
        -: 7583:  "#endif",
        -: 7584:  "",
        -: 7585:  "",
        -: 7586:  "#ifdef YY_USE_PROTOS",
        -: 7587:  "static void *yy_flex_alloc( yy_size_t size )",
        -: 7588:  "#else",
        -: 7589:  "static void *yy_flex_alloc( size )",
        -: 7590:  "yy_size_t size;",
        -: 7591:  "#endif",
        -: 7592:  "	{",
        -: 7593:  "	return (void *) malloc( size );",
        -: 7594:  "	}",
        -: 7595:  "",
        -: 7596:  "#ifdef YY_USE_PROTOS",
        -: 7597:  "static void *yy_flex_realloc( void *ptr, yy_size_t size )",
        -: 7598:  "#else",
        -: 7599:  "static void *yy_flex_realloc( ptr, size )",
        -: 7600:  "void *ptr;",
        -: 7601:  "yy_size_t size;",
        -: 7602:  "#endif",
        -: 7603:  "	{",
        -: 7604:  "	/* The cast to (char *) in the following accommodates both",
        -: 7605:  "	 * implementations that use char* generic pointers, and those",
        -: 7606:  "	 * that use void* generic pointers.  It works with the latter",
        -: 7607:  "	 * because both ANSI C and C++ allow castless assignment from",
        -: 7608:  "	 * any pointer type to void*, and deal with argument conversions",
        -: 7609:  "	 * as though doing an assignment.",
        -: 7610:  "	 */",
        -: 7611:  "	return (void *) realloc( (char *) ptr, size );",
        -: 7612:  "	}",
        -: 7613:  "",
        -: 7614:  "#ifdef YY_USE_PROTOS",
        -: 7615:  "static void yy_flex_free( void *ptr )",
        -: 7616:  "#else",
        -: 7617:  "static void yy_flex_free( ptr )",
        -: 7618:  "void *ptr;",
        -: 7619:  "#endif",
        -: 7620:  "	{",
        -: 7621:  "	free( ptr );",
        -: 7622:  "	}",
        -: 7623:  "",
        -: 7624:  "#if YY_MAIN",
        -: 7625:  "int main()",
        -: 7626:  "	{",
        -: 7627:  "	yylex();",
        -: 7628:  "	return 0;",
        -: 7629:  "	}",
        -: 7630:  "#endif",
        -: 7631:  0
        -: 7632:};
        -: 7633:/* sym - symbol table routines */
        -: 7634:
        -: 7635:/*-
        -: 7636: * Copyright (c) 1990 The Regents of the University of California.
        -: 7637: * All rights reserved.
        -: 7638: *
        -: 7639: * This code is derived from software contributed to Berkeley by
        -: 7640: * Vern Paxson.
        -: 7641: * 
        -: 7642: * The United States Government has rights in this work pursuant
        -: 7643: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7644: * Department of Energy and the University of California.
        -: 7645: *
        -: 7646: * Redistribution and use in source and binary forms are permitted provided
        -: 7647: * that: (1) source distributions retain this entire copyright notice and
        -: 7648: * comment, and (2) distributions including binaries display the following
        -: 7649: * acknowledgement:  ``This product includes software developed by the
        -: 7650: * University of California, Berkeley and its contributors'' in the
        -: 7651: * documentation or other materials provided with the distribution and in
        -: 7652: * all advertising materials mentioning features or use of this software.
        -: 7653: * Neither the name of the University nor the names of its contributors may
        -: 7654: * be used to endorse or promote products derived from this software without
        -: 7655: * specific prior written permission.
        -: 7656: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7657: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7658: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7659: */
        -: 7660:
        -: 7661:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 7662:
        -: 7663:
        -: 7664:
        -: 7665:/* declare functions that have forward references */
        -: 7666:
        -: 7667:int hashfunct PROTO((register char[], int));
        -: 7668:
        -: 7669:
        -: 7670:struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
        -: 7671:struct hash_entry *sctbl[START_COND_HASH_SIZE];
        -: 7672:struct hash_entry *ccltab[CCL_HASH_SIZE];
        -: 7673:
        -: 7674:struct hash_entry *findsym();
        -: 7675:
        -: 7676:
        -: 7677:/* addsym - add symbol and definitions to symbol table
        -: 7678: *
        -: 7679: * -1 is returned if the symbol already exists, and the change not made.
        -: 7680: */
        -: 7681:
        2: 7682:int addsym( sym, str_def, int_def, table, table_size )
        -: 7683:register char sym[];
        -: 7684:char *str_def;
        -: 7685:int int_def;
        -: 7686:hash_table table;
        -: 7687:int table_size;
        -: 7688:	{
        2: 7689:	int hash_val = hashfunct( sym, table_size );
        2: 7690:	register struct hash_entry *sym_entry = table[hash_val];
        -: 7691:	register struct hash_entry *new_entry;
        -: 7692:	register struct hash_entry *successor;
        -: 7693:
        4: 7694:	while ( sym_entry )
        -: 7695:		{
    #####: 7696:		if ( ! strcmp( sym, sym_entry->name ) )
        -: 7697:			{ /* entry already exists */
    #####: 7698:			return -1;
        -: 7699:			}
        -: 7700:
    #####: 7701:		sym_entry = sym_entry->next;
        -: 7702:		}
        -: 7703:
        -: 7704:	/* create new entry */
        2: 7705:	new_entry = (struct hash_entry *)
        -: 7706:		flex_alloc( sizeof( struct hash_entry ) );
        -: 7707:
        2: 7708:	if ( new_entry == NULL )
    #####: 7709:		flexfatal( _( "symbol table memory allocation failed" ) );
        -: 7710:
        2: 7711:	if ( (successor = table[hash_val]) != 0 )
        -: 7712:		{
    #####: 7713:		new_entry->next = successor;
    #####: 7714:		successor->prev = new_entry;
        -: 7715:		}
        -: 7716:	else
        2: 7717:		new_entry->next = NULL;
        -: 7718:
        2: 7719:	new_entry->prev = NULL;
        2: 7720:	new_entry->name = sym;
        2: 7721:	new_entry->str_val = str_def;
        2: 7722:	new_entry->int_val = int_def;
        -: 7723:
        2: 7724:	table[hash_val] = new_entry;
        -: 7725:
        2: 7726:	return 0;
        -: 7727:	}
        -: 7728:
        -: 7729:
        -: 7730:/* cclinstal - save the text of a character class */
        -: 7731:
        1: 7732:void cclinstal( ccltxt, cclnum )
        -: 7733:Char ccltxt[];
        -: 7734:int cclnum;
        -: 7735:	{
        -: 7736:	/* We don't bother checking the return status because we are not
        -: 7737:	 * called unless the symbol is new.
        -: 7738:	 */
        -: 7739:	Char *copy_unsigned_string();
        -: 7740:
        1: 7741:	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
        -: 7742:			(char *) 0, cclnum,
        -: 7743:			ccltab, CCL_HASH_SIZE );
        1: 7744:	}
        -: 7745:
        -: 7746:
        -: 7747:/* ccllookup - lookup the number associated with character class text
        -: 7748: *
        -: 7749: * Returns 0 if there's no CCL associated with the text.
        -: 7750: */
        -: 7751:
        1: 7752:int ccllookup( ccltxt )
        -: 7753:Char ccltxt[];
        -: 7754:	{
        1: 7755:	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
        -: 7756:	}
        -: 7757:
        -: 7758:
        -: 7759:/* findsym - find symbol in symbol table */
        -: 7760:
        1: 7761:struct hash_entry *findsym( sym, table, table_size )
        -: 7762:register char sym[];
        -: 7763:hash_table table;
        -: 7764:int table_size;
        -: 7765:	{
        -: 7766:	static struct hash_entry empty_entry =
        -: 7767:		{
        -: 7768:		(struct hash_entry *) 0, (struct hash_entry *) 0,
        -: 7769:		(char *) 0, (char *) 0, 0,
        -: 7770:		} ;
        1: 7771:	register struct hash_entry *sym_entry =
        1: 7772:		table[hashfunct( sym, table_size )];
        -: 7773:
        2: 7774:	while ( sym_entry )
        -: 7775:		{
    #####: 7776:		if ( ! strcmp( sym, sym_entry->name ) )
    #####: 7777:			return sym_entry;
    #####: 7778:		sym_entry = sym_entry->next;
        -: 7779:		}
        -: 7780:
        1: 7781:	return &empty_entry;
        -: 7782:	}
        -: 7783:
        -: 7784:
        -: 7785:/* hashfunct - compute the hash value for "str" and hash size "hash_size" */
        -: 7786:
        3: 7787:int hashfunct( str, hash_size )
        -: 7788:register char str[];
        -: 7789:int hash_size;
        -: 7790:	{
        -: 7791:	register int hashval;
        -: 7792:	register int locstr;
        -: 7793:
        3: 7794:	hashval = 0;
        3: 7795:	locstr = 0;
        -: 7796:
       21: 7797:	while ( str[locstr] )
        -: 7798:		{
       15: 7799:		hashval = (hashval << 1) + (unsigned char) str[locstr++];
       15: 7800:		hashval %= hash_size;
        -: 7801:		}
        -: 7802:
        3: 7803:	return hashval;
        -: 7804:	}
        -: 7805:
        -: 7806:
        -: 7807:/* ndinstal - install a name definition */
        -: 7808:
    #####: 7809:void ndinstal( name, definition )
        -: 7810:char name[];
        -: 7811:Char definition[];
        -: 7812:	{
        -: 7813:	char *copy_string();
        -: 7814:	Char *copy_unsigned_string();
        -: 7815:
    #####: 7816:	if ( addsym( copy_string( name ),
    #####: 7817:			(char *) copy_unsigned_string( definition ), 0,
        -: 7818:			ndtbl, NAME_TABLE_HASH_SIZE ) )
    #####: 7819:		synerr( _( "name defined twice" ) );
    #####: 7820:	}
        -: 7821:
        -: 7822:
        -: 7823:/* ndlookup - lookup a name definition
        -: 7824: *
        -: 7825: * Returns a nil pointer if the name definition does not exist.
        -: 7826: */
        -: 7827:
    #####: 7828:Char *ndlookup( nd )
        -: 7829:char nd[];
        -: 7830:	{
    #####: 7831:	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
        -: 7832:	}
        -: 7833:
        -: 7834:
        -: 7835:/* scextend - increase the maximum number of start conditions */
        -: 7836:
    #####: 7837:void scextend()
        -: 7838:	{
    #####: 7839:	current_max_scs += MAX_SCS_INCREMENT;
        -: 7840:
    #####: 7841:	++num_reallocs;
        -: 7842:
    #####: 7843:	scset = reallocate_integer_array( scset, current_max_scs );
    #####: 7844:	scbol = reallocate_integer_array( scbol, current_max_scs );
    #####: 7845:	scxclu = reallocate_integer_array( scxclu, current_max_scs );
    #####: 7846:	sceof = reallocate_integer_array( sceof, current_max_scs );
    #####: 7847:	scname = reallocate_char_ptr_array( scname, current_max_scs );
    #####: 7848:	}
        -: 7849:
        -: 7850:
        -: 7851:/* scinstal - make a start condition
        -: 7852: *
        -: 7853: * NOTE
        -: 7854: *    The start condition is "exclusive" if xcluflg is true.
        -: 7855: */
        -: 7856:
        1: 7857:void scinstal( str, xcluflg )
        -: 7858:char str[];
        -: 7859:int xcluflg;
        -: 7860:	{
        -: 7861:	char *copy_string();
        -: 7862:
        -: 7863:	/* Generate start condition definition, for use in BEGIN et al. */
        1: 7864:	action_define( str, lastsc );
        -: 7865:
        1: 7866:	if ( ++lastsc >= current_max_scs )
    #####: 7867:		scextend();
        -: 7868:
        1: 7869:	scname[lastsc] = copy_string( str );
        -: 7870:
        1: 7871:	if ( addsym( scname[lastsc], (char *) 0, lastsc,
        -: 7872:			sctbl, START_COND_HASH_SIZE ) )
    #####: 7873:		format_pinpoint_message(
        -: 7874:				_( "start condition %s declared twice" ),
        -: 7875:					str );
        -: 7876:
        1: 7877:	scset[lastsc] = mkstate( SYM_EPSILON );
        1: 7878:	scbol[lastsc] = mkstate( SYM_EPSILON );
        1: 7879:	scxclu[lastsc] = xcluflg;
        1: 7880:	sceof[lastsc] = false;
        1: 7881:	}
        -: 7882:
        -: 7883:
        -: 7884:/* sclookup - lookup the number associated with a start condition
        -: 7885: *
        -: 7886: * Returns 0 if no such start condition.
        -: 7887: */
        -: 7888:
    #####: 7889:int sclookup( str )
        -: 7890:char str[];
        -: 7891:	{
    #####: 7892:	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
        -: 7893:	}
        -: 7894:/* tblcmp - table compression routines */
        -: 7895:
        -: 7896:/*-
        -: 7897: * Copyright (c) 1990 The Regents of the University of California.
        -: 7898: * All rights reserved.
        -: 7899: *
        -: 7900: * This code is derived from software contributed to Berkeley by
        -: 7901: * Vern Paxson.
        -: 7902: * 
        -: 7903: * The United States Government has rights in this work pursuant
        -: 7904: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7905: * Department of Energy and the University of California.
        -: 7906: *
        -: 7907: * Redistribution and use in source and binary forms are permitted provided
        -: 7908: * that: (1) source distributions retain this entire copyright notice and
        -: 7909: * comment, and (2) distributions including binaries display the following
        -: 7910: * acknowledgement:  ``This product includes software developed by the
        -: 7911: * University of California, Berkeley and its contributors'' in the
        -: 7912: * documentation or other materials provided with the distribution and in
        -: 7913: * all advertising materials mentioning features or use of this software.
        -: 7914: * Neither the name of the University nor the names of its contributors may
        -: 7915: * be used to endorse or promote products derived from this software without
        -: 7916: * specific prior written permission.
        -: 7917: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7918: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7919: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7920: */
        -: 7921:
        -: 7922:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 7923:
        -: 7924:
        -: 7925:
        -: 7926:/* declarations for functions that have forward references */
        -: 7927:
        -: 7928:void mkentry PROTO((register int*, int, int, int, int));
        -: 7929:void mkprot PROTO((int[], int, int));
        -: 7930:void mktemplate PROTO((int[], int, int));
        -: 7931:void mv2front PROTO((int));
        -: 7932:int tbldiff PROTO((int[], int, int[]));
        -: 7933:
        -: 7934:
        -: 7935:/* bldtbl - build table entries for dfa state
        -: 7936: *
        -: 7937: * synopsis
        -: 7938: *   int state[numecs], statenum, totaltrans, comstate, comfreq;
        -: 7939: *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
        -: 7940: *
        -: 7941: * State is the statenum'th dfa state.  It is indexed by equivalence class and
        -: 7942: * gives the number of the state to enter for a given equivalence class.
        -: 7943: * totaltrans is the total number of transitions out of the state.  Comstate
        -: 7944: * is that state which is the destination of the most transitions out of State.
        -: 7945: * Comfreq is how many transitions there are out of State to Comstate.
        -: 7946: *
        -: 7947: * A note on terminology:
        -: 7948: *    "protos" are transition tables which have a high probability of
        -: 7949: * either being redundant (a state processed later will have an identical
        -: 7950: * transition table) or nearly redundant (a state processed later will have
        -: 7951: * many of the same out-transitions).  A "most recently used" queue of
        -: 7952: * protos is kept around with the hope that most states will find a proto
        -: 7953: * which is similar enough to be usable, and therefore compacting the
        -: 7954: * output tables.
        -: 7955: *    "templates" are a special type of proto.  If a transition table is
        -: 7956: * homogeneous or nearly homogeneous (all transitions go to the same
        -: 7957: * destination) then the odds are good that future states will also go
        -: 7958: * to the same destination state on basically the same character set.
        -: 7959: * These homogeneous states are so common when dealing with large rule
        -: 7960: * sets that they merit special attention.  If the transition table were
        -: 7961: * simply made into a proto, then (typically) each subsequent, similar
        -: 7962: * state will differ from the proto for two out-transitions.  One of these
        -: 7963: * out-transitions will be that character on which the proto does not go
        -: 7964: * to the common destination, and one will be that character on which the
        -: 7965: * state does not go to the common destination.  Templates, on the other
        -: 7966: * hand, go to the common state on EVERY transition character, and therefore
        -: 7967: * cost only one difference.
        -: 7968: */
        -: 7969:
       24: 7970:void bldtbl( state, statenum, totaltrans, comstate, comfreq )
        -: 7971:int state[], statenum, totaltrans, comstate, comfreq;
        -: 7972:	{
        -: 7973:	int extptr, extrct[2][CSIZE + 1];
        -: 7974:	int mindiff, minprot, i, d;
        -: 7975:
        -: 7976:	/* If extptr is 0 then the first array of extrct holds the result
        -: 7977:	 * of the "best difference" to date, which is those transitions
        -: 7978:	 * which occur in "state" but not in the proto which, to date,
        -: 7979:	 * has the fewest differences between itself and "state".  If
        -: 7980:	 * extptr is 1 then the second array of extrct hold the best
        -: 7981:	 * difference.  The two arrays are toggled between so that the
        -: 7982:	 * best difference to date can be kept around and also a difference
        -: 7983:	 * just created by checking against a candidate "best" proto.
        -: 7984:	 */
        -: 7985:
       24: 7986:	extptr = 0;
        -: 7987:
        -: 7988:	/* If the state has too few out-transitions, don't bother trying to
        -: 7989:	 * compact its tables.
        -: 7990:	 */
        -: 7991:
        -: 7992:#ifndef F_A09
       24: 7993:	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
        -: 7994:#else
        -: 7995:	if ( (totaltrans * 100) < (numecs + PROTO_SIZE_PERCENTAGE) )
        -: 7996:#endif
       20: 7997:		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
        -: 7998:
        -: 7999:	else
        -: 8000:		{
        -: 8001:		/* "checkcom" is true if we should only check "state" against
        -: 8002:		 * protos which have the same "comstate" value.
        -: 8003:		 */
        4: 8004:		int checkcom =
        4: 8005:			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
        -: 8006:
        4: 8007:		minprot = firstprot;
        4: 8008:		mindiff = totaltrans;
        -: 8009:
        -: 8010:#ifndef F_B42
        4: 8011:		if ( checkcom )
        -: 8012:#else
        -: 8013:		if ( 0 &&  checkcom )
        -: 8014:#endif
        -: 8015:			{
        -: 8016:			/* Find first proto which has the same "comstate". */
        4: 8017:			for ( i = firstprot; i != NIL; i = protnext[i] )
        2: 8018:				if ( protcomst[i] == comstate )
        -: 8019:					{
        1: 8020:					minprot = i;
        1: 8021:					mindiff = tbldiff( state, minprot,
        1: 8022:							extrct[extptr] );
        1: 8023:					break;
        -: 8024:					}
        -: 8025:			}
        -: 8026:
        -: 8027:#ifndef F_B07
        -: 8028:		else
        -: 8029:#else
        -: 8030:
        -: 8031:#endif
        -: 8032:			{
        -: 8033:			/* Since we've decided that the most common destination
        -: 8034:			 * out of "state" does not occur with a high enough
        -: 8035:			 * frequency, we set the "comstate" to zero, assuring
        -: 8036:			 * that if this state is entered into the proto list,
        -: 8037:			 * it will not be considered a template.
        -: 8038:			 */
        1: 8039:			comstate = 0;
        -: 8040:
        1: 8041:			if ( firstprot != NIL )
        -: 8042:				{
        1: 8043:				minprot = firstprot;
        1: 8044:				mindiff = tbldiff( state, minprot,
        1: 8045:						extrct[extptr] );
        -: 8046:				}
        -: 8047:			}
        -: 8048:
        -: 8049:		/* We now have the first interesting proto in "minprot".  If
        -: 8050:		 * it matches within the tolerances set for the first proto,
        -: 8051:		 * we don't want to bother scanning the rest of the proto list
        -: 8052:		 * to see if we have any other reasonable matches.
        -: 8053:		 */
        -: 8054:
        4: 8055:		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
        -: 8056:			{
        -: 8057:			/* Not a good enough match.  Scan the rest of the
        -: 8058:			 * protos.
        -: 8059:			 */
        6: 8060:			for ( i = minprot; i != NIL; i = protnext[i] )
        -: 8061:				{
        3: 8062:				d = tbldiff( state, i, extrct[1 - extptr] );
        3: 8063:				if ( d < mindiff )
        -: 8064:					{
    #####: 8065:					extptr = 1 - extptr;
    #####: 8066:					mindiff = d;
    #####: 8067:					minprot = i;
        -: 8068:					}
        -: 8069:				}
        -: 8070:			}
        -: 8071:
        -: 8072:		/* Check if the proto we've decided on as our best bet is close
        -: 8073:		 * enough to the state we want to match to be usable.
        -: 8074:		 */
        -: 8075:
        4: 8076:		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
        -: 8077:			{
        -: 8078:			/* No good.  If the state is homogeneous enough,
        -: 8079:			 * we make a template out of it.  Otherwise, we
        -: 8080:			 * make a proto.
        -: 8081:			 */
        -: 8082:
        4: 8083:			if ( comfreq * 100 >=
        2: 8084:			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
        -: 8085:#ifndef F_B08
        1: 8086:				mktemplate( state, statenum, comstate );
        -: 8087:#else
        -: 8088:				mktemplate( state, !  statenum, comstate );
        -: 8089:#endif
        -: 8090:
        -: 8091:			else
        -: 8092:				{
        1: 8093:				mkprot( state, statenum, comstate );
        1: 8094:				mkentry( state, numecs, statenum,
        -: 8095:					JAMSTATE, totaltrans );
        -: 8096:				}
        -: 8097:			}
        -: 8098:
        -: 8099:		else
        -: 8100:			{ /* use the proto */
        2: 8101:			mkentry( extrct[extptr], numecs, statenum,
        -: 8102:				prottbl[minprot], mindiff );
        -: 8103:
        -: 8104:			/* If this state was sufficiently different from the
        -: 8105:			 * proto we built it from, make it, too, a proto.
        -: 8106:			 */
        -: 8107:
        4: 8108:			if ( mindiff * 100 >=
        2: 8109:			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
        1: 8110:				mkprot( state, statenum, comstate );
        -: 8111:
        -: 8112:			/* Since mkprot added a new proto to the proto queue,
        -: 8113:			 * it's possible that "minprot" is no longer on the
        -: 8114:			 * proto queue (if it happened to have been the last
        -: 8115:			 * entry, it would have been bumped off).  If it's
        -: 8116:			 * not there, then the new proto took its physical
        -: 8117:			 * place (though logically the new proto is at the
        -: 8118:			 * beginning of the queue), so in that case the
        -: 8119:			 * following call will do nothing.
        -: 8120:			 */
        -: 8121:
        -: 8122:#ifndef F_B32
        2: 8123:			mv2front( minprot );
        -: 8124:#else
        -: 8125:			mv2front (!  minprot );
        -: 8126:#endif
        -: 8127:			}
        -: 8128:		}
       24: 8129:	}
        -: 8130:
        -: 8131:
        -: 8132:/* cmptmps - compress template table entries
        -: 8133: *
        -: 8134: * Template tables are compressed by using the 'template equivalence
        -: 8135: * classes', which are collections of transition character equivalence
        -: 8136: * classes which always appear together in templates - really meta-equivalence
        -: 8137: * classes.
        -: 8138: */
        -: 8139:
        1: 8140:void cmptmps()
        -: 8141:	{
        -: 8142:#ifndef F_A18
        -: 8143:	int tmpstorage[CSIZE + 1];
        -: 8144:#else
        -: 8145:	int tmpstorage[CSIZE % 1];
        -: 8146:#endif
        1: 8147:	register int *tmp = tmpstorage, i, j;
        -: 8148:	int totaltrans, trans;
        -: 8149:
        1: 8150:	peakpairs = numtemps * numecs + tblend;
        -: 8151:
        1: 8152:	if ( usemecs )
        -: 8153:		{
        -: 8154:		/* Create equivalence classes based on data gathered on
        -: 8155:		 * template transitions.
        -: 8156:		 */
        1: 8157:		nummecs = cre8ecs( tecfwd, tecbck, numecs );
        -: 8158:		}
        -: 8159:
        -: 8160:	else
    #####: 8161:		nummecs = numecs;
        -: 8162:
        2: 8163:	while ( lastdfa + numtemps + 1 >= current_max_dfas )
    #####: 8164:		increase_max_dfas();
        -: 8165:
        -: 8166:	/* Loop through each template. */
        -: 8167:
        2: 8168:	for ( i = 1; i <= numtemps; ++i )
        -: 8169:		{
        -: 8170:		/* Number of non-jam transitions out of this template. */
        1: 8171:		totaltrans = 0;
        -: 8172:
       18: 8173:		for ( j = 1; j <= numecs; ++j )
        -: 8174:			{
       17: 8175:			trans = tnxt[numecs * i + j];
        -: 8176:
       17: 8177:			if ( usemecs )
        -: 8178:				{
        -: 8179:				/* The absolute value of tecbck is the
        -: 8180:				 * meta-equivalence class of a given
        -: 8181:				 * equivalence class, as set up by cre8ecs().
        -: 8182:				 */
       17: 8183:				if ( tecbck[j] > 0 )
        -: 8184:					{
        2: 8185:					tmp[tecbck[j]] = trans;
        -: 8186:
        2: 8187:					if ( trans > 0 )
        1: 8188:						++totaltrans;
        -: 8189:					}
        -: 8190:				}
        -: 8191:
        -: 8192:			else
        -: 8193:				{
        -: 8194:#ifndef F_A25
    #####: 8195:				tmp[j] = trans;
        -: 8196:#else
        -: 8197:				tmp[ -1 + j] = trans;
        -: 8198:#endif
        -: 8199:
    #####: 8200:				if ( trans > 0 )
    #####: 8201:					++totaltrans;
        -: 8202:				}
        -: 8203:			}
        -: 8204:
        -: 8205:		/* It is assumed (in a rather subtle way) in the skeleton
        -: 8206:		 * that if we're using meta-equivalence classes, the def[]
        -: 8207:		 * entry for all templates is the jam template, i.e.,
        -: 8208:		 * templates never default to other non-jam table entries
        -: 8209:		 * (e.g., another template)
        -: 8210:		 */
        -: 8211:
        -: 8212:		/* Leave room for the jam-state after the last real state. */
        1: 8213:		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
        -: 8214:		}
        1: 8215:	}
        -: 8216:
        -: 8217:
        -: 8218:
        -: 8219:/* expand_nxt_chk - expand the next check arrays */
        -: 8220:
    #####: 8221:void expand_nxt_chk()
        -: 8222:	{
    #####: 8223:	register int old_max = current_max_xpairs;
        -: 8224:
    #####: 8225:	current_max_xpairs += MAX_XPAIRS_INCREMENT;
        -: 8226:
    #####: 8227:	++num_reallocs;
        -: 8228:
    #####: 8229:	nxt = reallocate_integer_array( nxt, current_max_xpairs );
    #####: 8230:	chk = reallocate_integer_array( chk, current_max_xpairs );
        -: 8231:
    #####: 8232:	zero_out( (char *) (chk + old_max),
        -: 8233:		(size_t) (MAX_XPAIRS_INCREMENT * sizeof( int )) );
    #####: 8234:	}
        -: 8235:
        -: 8236:
        -: 8237:/* find_table_space - finds a space in the table for a state to be placed
        -: 8238: *
        -: 8239: * synopsis
        -: 8240: *     int *state, numtrans, block_start;
        -: 8241: *     int find_table_space();
        -: 8242: *
        -: 8243: *     block_start = find_table_space( state, numtrans );
        -: 8244: *
        -: 8245: * State is the state to be added to the full speed transition table.
        -: 8246: * Numtrans is the number of out-transitions for the state.
        -: 8247: *
        -: 8248: * find_table_space() returns the position of the start of the first block (in
        -: 8249: * chk) able to accommodate the state
        -: 8250: *
        -: 8251: * In determining if a state will or will not fit, find_table_space() must take
        -: 8252: * into account the fact that an end-of-buffer state will be added at [0],
        -: 8253: * and an action number will be added in [-1].
        -: 8254: */
        -: 8255:
    #####: 8256:int find_table_space( state, numtrans )
        -: 8257:int *state, numtrans;
        -: 8258:	{
        -: 8259:	/* Firstfree is the position of the first possible occurrence of two
        -: 8260:	 * consecutive unused records in the chk and nxt arrays.
        -: 8261:	 */
        -: 8262:	register int i;
        -: 8263:	register int *state_ptr, *chk_ptr;
        -: 8264:	register int *ptr_to_last_entry_in_state;
        -: 8265:
        -: 8266:	/* If there are too many out-transitions, put the state at the end of
        -: 8267:	 * nxt and chk.
        -: 8268:	 */
    #####: 8269:	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
        -: 8270:		{
        -: 8271:		/* If table is empty, return the first available spot in
        -: 8272:		 * chk/nxt, which should be 1.
        -: 8273:		 */
    #####: 8274:		if ( tblend < 2 )
    #####: 8275:			return 1;
        -: 8276:
        -: 8277:		/* Start searching for table space near the end of
        -: 8278:		 * chk/nxt arrays.
        -: 8279:		 */
    #####: 8280:		i = tblend - numecs;
        -: 8281:		}
        -: 8282:
        -: 8283:	else
        -: 8284:		/* Start searching for table space from the beginning
        -: 8285:		 * (skipping only the elements which will definitely not
        -: 8286:		 * hold the new state).
        -: 8287:		 */
    #####: 8288:		i = firstfree;
        -: 8289:
        -: 8290:	while ( 1 )	/* loops until a space is found */
        -: 8291:		{
    #####: 8292:		while ( i + numecs >= current_max_xpairs )
    #####: 8293:			expand_nxt_chk();
        -: 8294:
        -: 8295:		/* Loops until space for end-of-buffer and action number
        -: 8296:		 * are found.
        -: 8297:		 */
        -: 8298:#ifndef F_B09
        -: 8299:		while ( 1 )
        -: 8300:#else
        -: 8301:		if (! 1 )
        -: 8302:#endif
        -: 8303:			{
        -: 8304:			/* Check for action number space. */
    #####: 8305:			if ( chk[i - 1] == 0 )
        -: 8306:				{
        -: 8307:				/* Check for end-of-buffer space. */
    #####: 8308:				if ( chk[i] == 0 )
    #####: 8309:					break;
        -: 8310:
        -: 8311:				else
        -: 8312:					/* Since i != 0, there is no use
        -: 8313:					 * checking to see if (++i) - 1 == 0,
        -: 8314:					 * because that's the same as i == 0,
        -: 8315:					 * so we skip a space.
        -: 8316:					 */
    #####: 8317:					i += 2;
        -: 8318:				}
        -: 8319:
        -: 8320:#ifndef F_B34
        -: 8321:			else
        -: 8322:#else
        -: 8323:
        -: 8324:#endif
    #####: 8325:				++i;
        -: 8326:
    #####: 8327:			while ( i + numecs >= current_max_xpairs )
    #####: 8328:				expand_nxt_chk();
    #####: 8329:			}
        -: 8330:
        -: 8331:		/* If we started search from the beginning, store the new
        -: 8332:		 * firstfree for the next call of find_table_space().
        -: 8333:		 */
    #####: 8334:		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
    #####: 8335:			firstfree = i + 1;
        -: 8336:
        -: 8337:		/* Check to see if all elements in chk (and therefore nxt)
        -: 8338:		 * that are needed for the new state have not yet been taken.
        -: 8339:		 */
        -: 8340:
    #####: 8341:		state_ptr = &state[1];
    #####: 8342:		ptr_to_last_entry_in_state = &chk[i + numecs + 1];
        -: 8343:
    #####: 8344:		for ( chk_ptr = &chk[i + 1];
    #####: 8345:		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
    #####: 8346:			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
    #####: 8347:				break;
        -: 8348:
    #####: 8349:		if ( chk_ptr == ptr_to_last_entry_in_state )
    #####: 8350:			return i;
        -: 8351:
        -: 8352:		else
    #####: 8353:		++i;
    #####: 8354:		}
        -: 8355:	}
        -: 8356:
        -: 8357:
        -: 8358:/* inittbl - initialize transition tables
        -: 8359: *
        -: 8360: * Initializes "firstfree" to be one beyond the end of the table.  Initializes
        -: 8361: * all "chk" entries to be zero.
        -: 8362: */
        1: 8363:void inittbl()
        -: 8364:	{
        -: 8365:	register int i;
        -: 8366:
        1: 8367:	zero_out( (char *) chk, (size_t) (current_max_xpairs * sizeof( int )) );
        -: 8368:
        1: 8369:	tblend = 0;
        1: 8370:	firstfree = tblend + 1;
        1: 8371:	numtemps = 0;
        -: 8372:
        1: 8373:	if ( usemecs )
        -: 8374:		{
        -: 8375:		/* Set up doubly-linked meta-equivalence classes; these
        -: 8376:		 * are sets of equivalence classes which all have identical
        -: 8377:		 * transitions out of TEMPLATES.
        -: 8378:		 */
        -: 8379:
        1: 8380:		tecbck[1] = NIL;
        -: 8381:
       17: 8382:		for ( i = 2; i <= numecs; ++i )
        -: 8383:			{
       16: 8384:			tecbck[i] = i - 1;
       16: 8385:			tecfwd[i - 1] = i;
        -: 8386:			}
        -: 8387:
        1: 8388:		tecfwd[numecs] = NIL;
        -: 8389:		}
        1: 8390:	}
        -: 8391:
        -: 8392:
        -: 8393:/* mkdeftbl - make the default, "jam" table entries */
        -: 8394:
        1: 8395:void mkdeftbl()
        -: 8396:	{
        -: 8397:	int i;
        -: 8398:
        1: 8399:	jamstate = lastdfa + 1;
        -: 8400:
        1: 8401:	++tblend; /* room for transition on end-of-buffer character */
        -: 8402:
        2: 8403:	while ( tblend + numecs >= current_max_xpairs )
    #####: 8404:		expand_nxt_chk();
        -: 8405:
        -: 8406:	/* Add in default end-of-buffer transition. */
        1: 8407:	nxt[tblend] = end_of_buffer_state;
        1: 8408:	chk[tblend] = jamstate;
        -: 8409:
       18: 8410:	for ( i = 1; i <= numecs; ++i )
        -: 8411:		{
       17: 8412:		nxt[tblend + i] = 0;
       17: 8413:		chk[tblend + i] = jamstate;
        -: 8414:		}
        -: 8415:
        1: 8416:	jambase = tblend;
        -: 8417:
        1: 8418:	base[jamstate] = jambase;
        1: 8419:	def[jamstate] = 0;
        -: 8420:
        1: 8421:	tblend += numecs;
        1: 8422:	++numtemps;
        1: 8423:	}
        -: 8424:
        -: 8425:
        -: 8426:/* mkentry - create base/def and nxt/chk entries for transition array
        -: 8427: *
        -: 8428: * synopsis
        -: 8429: *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
        -: 8430: *   mkentry( state, numchars, statenum, deflink, totaltrans );
        -: 8431: *
        -: 8432: * "state" is a transition array "numchars" characters in size, "statenum"
        -: 8433: * is the offset to be used into the base/def tables, and "deflink" is the
        -: 8434: * entry to put in the "def" table entry.  If "deflink" is equal to
        -: 8435: * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
        -: 8436: * (i.e., jam entries) into the table.  It is assumed that by linking to
        -: 8437: * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
        -: 8438: * marking transitions to "SAME_TRANS" are treated as though they will be
        -: 8439: * taken care of by whereever "deflink" points.  "totaltrans" is the total
        -: 8440: * number of transitions out of the state.  If it is below a certain threshold,
        -: 8441: * the tables are searched for an interior spot that will accommodate the
        -: 8442: * state array.
        -: 8443: */
        -: 8444:
       25: 8445:void mkentry( state, numchars, statenum, deflink, totaltrans )
        -: 8446:register int *state;
        -: 8447:int numchars, statenum, deflink, totaltrans;
        -: 8448:	{
        -: 8449:	register int minec, maxec, i, baseaddr;
        -: 8450:	int tblbase, tbllast;
        -: 8451:
       25: 8452:	if ( totaltrans == 0 )
        -: 8453:		{ /* there are no out-transitions */
        8: 8454:		if ( deflink == JAMSTATE )
        8: 8455:			base[statenum] = JAMSTATE;
        -: 8456:		else
    #####: 8457:			base[statenum] = 0;
        -: 8458:
        8: 8459:		def[statenum] = deflink;
        8: 8460:		return;
        -: 8461:		}
        -: 8462:
      161: 8463:	for ( minec = 1; minec <= numchars; ++minec )
        -: 8464:		{
        -: 8465:#ifndef F_A13
      161: 8466:		if ( state[minec] != SAME_TRANS )
        -: 8467:#else
        -: 8468:		if ( state[ 0 * minec] != SAME_TRANS )
        -: 8469:#endif
      127: 8470:			if ( state[minec] != 0 || deflink != JAMSTATE )
        -: 8471:				break;
        -: 8472:		}
        -: 8473:
       17: 8474:	if ( totaltrans == 1 )
        -: 8475:		{
        -: 8476:		/* There's only one out-transition.  Save it for later to fill
        -: 8477:		 * in holes in the tables.
        -: 8478:		 */
       16: 8479:		stack1( statenum, minec, state[minec], deflink );
       16: 8480:		return;
        -: 8481:		}
        -: 8482:
        1: 8483:	for ( maxec = numchars; maxec > 0; --maxec )
        -: 8484:		{
        1: 8485:		if ( state[maxec] != SAME_TRANS )
        1: 8486:			if ( state[maxec] != 0 || deflink != JAMSTATE )
        -: 8487:				break;
        -: 8488:		}
        -: 8489:
        -: 8490:	/* Whether we try to fit the state table in the middle of the table
        -: 8491:	 * entries we have already generated, or if we just take the state
        -: 8492:	 * table at the end of the nxt/chk tables, we must make sure that we
        -: 8493:	 * have a valid base address (i.e., non-negative).  Note that
        -: 8494:	 * negative base addresses dangerous at run-time (because indexing
        -: 8495:	 * the nxt array with one and a low-valued character will access
        -: 8496:	 * memory before the start of the array.
        -: 8497:	 */
        -: 8498:
        -: 8499:	/* Find the first transition of state that we need to worry about. */
        1: 8500:	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
        -: 8501:		{
        -: 8502:		/* Attempt to squeeze it into the middle of the tables. */
    #####: 8503:		baseaddr = firstfree;
        -: 8504:
    #####: 8505:		while ( baseaddr < minec )
        -: 8506:			{
        -: 8507:			/* Using baseaddr would result in a negative base
        -: 8508:			 * address below; find the next free slot.
        -: 8509:			 */
    #####: 8510:			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
        -: 8511:				;
        -: 8512:			}
        -: 8513:
    #####: 8514:		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
    #####: 8515:			expand_nxt_chk();
        -: 8516:
        -: 8517:#ifndef F_B35
    #####: 8518:		for ( i = minec; i <= maxec; ++i )
        -: 8519:#else
        -: 8520:		for ( i = minec; i  >=  maxec; ++i )
        -: 8521:#endif
    #####: 8522:			if ( state[i] != SAME_TRANS &&
    #####: 8523:			     (state[i] != 0 || deflink != JAMSTATE) &&
    #####: 8524:			     chk[baseaddr + i - minec] != 0 )
        -: 8525:				{ /* baseaddr unsuitable - find another */
    #####: 8526:				for ( ++baseaddr;
    #####: 8527:				      baseaddr < current_max_xpairs &&
    #####: 8528:				      chk[baseaddr] != 0; ++baseaddr )
        -: 8529:					;
        -: 8530:
    #####: 8531:				while ( baseaddr + maxec - minec + 1 >=
        -: 8532:					current_max_xpairs )
    #####: 8533:					expand_nxt_chk();
        -: 8534:
        -: 8535:				/* Reset the loop counter so we'll start all
        -: 8536:				 * over again next time it's incremented.
        -: 8537:				 */
        -: 8538:
    #####: 8539:				i = minec - 1;
        -: 8540:				}
        -: 8541:		}
        -: 8542:
        -: 8543:	else
        -: 8544:		{
        -: 8545:		/* Ensure that the base address we eventually generate is
        -: 8546:		 * non-negative.
        -: 8547:		 */
        1: 8548:		baseaddr = MAX( tblend + 1, minec );
        -: 8549:		}
        -: 8550:
        1: 8551:	tblbase = baseaddr - minec;
        1: 8552:	tbllast = tblbase + maxec;
        -: 8553:
        2: 8554:	while ( tbllast + 1 >= current_max_xpairs )
    #####: 8555:		expand_nxt_chk();
        -: 8556:
        1: 8557:	base[statenum] = tblbase;
        1: 8558:	def[statenum] = deflink;
        -: 8559:
       18: 8560:	for ( i = minec; i <= maxec; ++i )
        -: 8561:#ifndef F_A06
       17: 8562:		if ( state[i] != SAME_TRANS )
        -: 8563:#else
        -: 8564:		if ( state[ -1 + i] != SAME_TRANS )
        -: 8565:#endif
       17: 8566:			if ( state[i] != 0 || deflink != JAMSTATE )
        -: 8567:				{
       17: 8568:				nxt[tblbase + i] = state[i];
       17: 8569:				chk[tblbase + i] = statenum;
        -: 8570:				}
        -: 8571:
        1: 8572:	if ( baseaddr == firstfree )
        -: 8573:		/* Find next free slot in tables. */
        1: 8574:		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
        -: 8575:			;
        -: 8576:
        1: 8577:	tblend = MAX( tblend, tbllast );
        -: 8578:	}
        -: 8579:
        -: 8580:
        -: 8581:/* mk1tbl - create table entries for a state (or state fragment) which
        -: 8582: *            has only one out-transition
        -: 8583: */
        -: 8584:
       17: 8585:void mk1tbl( state, sym, onenxt, onedef )
        -: 8586:int state, sym, onenxt, onedef;
        -: 8587:	{
       17: 8588:	if ( firstfree < sym )
    #####: 8589:		firstfree = sym;
        -: 8590:
       34: 8591:	while ( chk[firstfree] != 0 )
    #####: 8592:		if ( ++firstfree >= current_max_xpairs )
    #####: 8593:			expand_nxt_chk();
        -: 8594:
        -: 8595:#ifndef F_A30
       17: 8596:	base[state] = firstfree - sym;
        -: 8597:#else
        -: 8598:	base[ 1 + state] = firstfree - sym;
        -: 8599:#endif
       17: 8600:	def[state] = onedef;
       17: 8601:	chk[firstfree] = state;
       17: 8602:	nxt[firstfree] = onenxt;
        -: 8603:
       17: 8604:	if ( firstfree > tblend )
        -: 8605:		{
       17: 8606:		tblend = firstfree++;
        -: 8607:
       17: 8608:		if ( firstfree >= current_max_xpairs )
    #####: 8609:			expand_nxt_chk();
        -: 8610:		}
       17: 8611:	}
        -: 8612:
        -: 8613:
        -: 8614:/* mkprot - create new proto entry */
        -: 8615:
        3: 8616:void mkprot( state, statenum, comstate )
        -: 8617:int state[], statenum, comstate;
        -: 8618:	{
        -: 8619:	int i, slot, tblbase;
        -: 8620:
        3: 8621:	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
        -: 8622:		{
        -: 8623:		/* Gotta make room for the new proto by dropping last entry in
        -: 8624:		 * the queue.
        -: 8625:		 */
    #####: 8626:		slot = lastprot;
    #####: 8627:		lastprot = protprev[lastprot];
    #####: 8628:		protnext[lastprot] = NIL;
        -: 8629:		}
        -: 8630:
        -: 8631:	else
        3: 8632:		slot = numprots;
        -: 8633:
        3: 8634:	protnext[slot] = firstprot;
        -: 8635:
        3: 8636:	if ( firstprot != NIL )
        2: 8637:		protprev[firstprot] = slot;
        -: 8638:
        3: 8639:	firstprot = slot;
        3: 8640:	prottbl[slot] = statenum;
        3: 8641:	protcomst[slot] = comstate;
        -: 8642:
        -: 8643:	/* Copy state into save area so it can be compared with rapidly. */
        3: 8644:	tblbase = numecs * (slot - 1);
        -: 8645:
       54: 8646:	for ( i = 1; i <= numecs; ++i )
       51: 8647:		protsave[tblbase + i] = state[i];
        3: 8648:	}
        -: 8649:
        -: 8650:
        -: 8651:/* mktemplate - create a template entry based on a state, and connect the state
        -: 8652: *              to it
        -: 8653: */
        -: 8654:
        1: 8655:void mktemplate( state, statenum, comstate )
        -: 8656:int state[], statenum, comstate;
        -: 8657:	{
        -: 8658:	int i, numdiff, tmpbase, tmp[CSIZE + 1];
        -: 8659:	Char transset[CSIZE + 1];
        -: 8660:	int tsptr;
        -: 8661:
        1: 8662:	++numtemps;
        -: 8663:
        1: 8664:	tsptr = 0;
        -: 8665:
        -: 8666:	/* Calculate where we will temporarily store the transition table
        -: 8667:	 * of the template in the tnxt[] array.  The final transition table
        -: 8668:	 * gets created by cmptmps().
        -: 8669:	 */
        -: 8670:
        1: 8671:	tmpbase = numtemps * numecs;
        -: 8672:
        1: 8673:	if ( tmpbase + numecs >= current_max_template_xpairs )
        -: 8674:		{
    #####: 8675:		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
        -: 8676:
    #####: 8677:		++num_reallocs;
        -: 8678:
    #####: 8679:		tnxt = reallocate_integer_array( tnxt,
        -: 8680:			current_max_template_xpairs );
        -: 8681:		}
        -: 8682:
        -: 8683:#ifndef F_A23
       18: 8684:	for ( i = 1; i <= numecs; ++i )
        -: 8685:#else
        -: 8686:	for ( i = 1; i <= numecs; --i )
        -: 8687:#endif
       17: 8688:		if ( state[i] == 0 )
       14: 8689:			tnxt[tmpbase + i] = 0;
        -: 8690:		else
        -: 8691:			{
        3: 8692:			transset[tsptr++] = i;
        3: 8693:			tnxt[tmpbase + i] = comstate;
        -: 8694:			}
        -: 8695:
        1: 8696:	if ( usemecs )
        1: 8697:		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
        -: 8698:
        1: 8699:	mkprot( tnxt + tmpbase, -numtemps, comstate );
        -: 8700:
        -: 8701:	/* We rely on the fact that mkprot adds things to the beginning
        -: 8702:	 * of the proto queue.
        -: 8703:	 */
        -: 8704:
        1: 8705:	numdiff = tbldiff( state, firstprot, tmp );
        1: 8706:	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
        1: 8707:	}
        -: 8708:
        -: 8709:
        -: 8710:/* mv2front - move proto queue element to front of queue */
        -: 8711:
        2: 8712:void mv2front( qelm )
        -: 8713:int qelm;
        -: 8714:	{
        2: 8715:	if ( firstprot != qelm )
        -: 8716:		{
        1: 8717:		if ( qelm == lastprot )
    #####: 8718:			lastprot = protprev[lastprot];
        -: 8719:
        1: 8720:		protnext[protprev[qelm]] = protnext[qelm];
        -: 8721:
        1: 8722:		if ( protnext[qelm] != NIL )
        1: 8723:			protprev[protnext[qelm]] = protprev[qelm];
        -: 8724:
        1: 8725:		protprev[qelm] = NIL;
        1: 8726:		protnext[qelm] = firstprot;
        1: 8727:		protprev[firstprot] = qelm;
        1: 8728:		firstprot = qelm;
        -: 8729:		}
        2: 8730:	}
        -: 8731:
        -: 8732:
        -: 8733:/* place_state - place a state into full speed transition table
        -: 8734: *
        -: 8735: * State is the statenum'th state.  It is indexed by equivalence class and
        -: 8736: * gives the number of the state to enter for a given equivalence class.
        -: 8737: * Transnum is the number of out-transitions for the state.
        -: 8738: */
        -: 8739:
    #####: 8740:void place_state( state, statenum, transnum )
        -: 8741:int *state, statenum, transnum;
        -: 8742:	{
        -: 8743:	register int i;
        -: 8744:	register int *state_ptr;
    #####: 8745:	int position = find_table_space( state, transnum );
        -: 8746:
        -: 8747:	/* "base" is the table of start positions. */
    #####: 8748:	base[statenum] = position;
        -: 8749:
        -: 8750:	/* Put in action number marker; this non-zero number makes sure that
        -: 8751:	 * find_table_space() knows that this position in chk/nxt is taken
        -: 8752:	 * and should not be used for another accepting number in another
        -: 8753:	 * state.
        -: 8754:	 */
    #####: 8755:	chk[position - 1] = 1;
        -: 8756:
        -: 8757:	/* Put in end-of-buffer marker; this is for the same purposes as
        -: 8758:	 * above.
        -: 8759:	 */
    #####: 8760:	chk[position] = 1;
        -: 8761:
        -: 8762:	/* Place the state into chk and nxt. */
    #####: 8763:	state_ptr = &state[1];
        -: 8764:
        -: 8765:#ifndef F_B44
    #####: 8766:	for ( i = 1; i <= numecs; ++i, ++state_ptr )
        -: 8767:#else
        -: 8768:	for ( i = 1; i  <  numecs; ++i, ++state_ptr )
        -: 8769:#endif
    #####: 8770:		if ( *state_ptr != 0 )
        -: 8771:			{
        -: 8772:#ifndef F_A05
    #####: 8773:			chk[position + i] = i;
        -: 8774:#else
        -: 8775:			chk[position + i] < i;
        -: 8776:#endif
    #####: 8777:			nxt[position + i] = *state_ptr;
        -: 8778:			}
        -: 8779:
    #####: 8780:	if ( position + numecs > tblend )
    #####: 8781:		tblend = position + numecs;
    #####: 8782:	}
        -: 8783:
        -: 8784:
        -: 8785:/* stack1 - save states with only one out-transition to be processed later
        -: 8786: *
        -: 8787: * If there's room for another state on the "one-transition" stack, the
        -: 8788: * state is pushed onto it, to be processed later by mk1tbl.  If there's
        -: 8789: * no room, we process the sucker right now.
        -: 8790: */
        -: 8791:
       17: 8792:void stack1( statenum, sym, nextstate, deflink )
        -: 8793:int statenum, sym, nextstate, deflink;
        -: 8794:	{
       17: 8795:	if ( onesp >= ONE_STACK_SIZE - 1 )
    #####: 8796:		mk1tbl( statenum, sym, nextstate, deflink );
        -: 8797:
        -: 8798:	else
        -: 8799:		{
       17: 8800:		++onesp;
       17: 8801:		onestate[onesp] = statenum;
       17: 8802:		onesym[onesp] = sym;
       17: 8803:		onenext[onesp] = nextstate;
       17: 8804:		onedef[onesp] = deflink;
        -: 8805:		}
       17: 8806:	}
        -: 8807:
        -: 8808:
        -: 8809:/* tbldiff - compute differences between two state tables
        -: 8810: *
        -: 8811: * "state" is the state array which is to be extracted from the pr'th
        -: 8812: * proto.  "pr" is both the number of the proto we are extracting from
        -: 8813: * and an index into the save area where we can find the proto's complete
        -: 8814: * state table.  Each entry in "state" which differs from the corresponding
        -: 8815: * entry of "pr" will appear in "ext".
        -: 8816: *
        -: 8817: * Entries which are the same in both "state" and "pr" will be marked
        -: 8818: * as transitions to "SAME_TRANS" in "ext".  The total number of differences
        -: 8819: * between "state" and "pr" is returned as function value.  Note that this
        -: 8820: * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
        -: 8821: */
        -: 8822:
        6: 8823:int tbldiff( state, pr, ext )
        -: 8824:int state[], pr, ext[];
        -: 8825:	{
        6: 8826:	register int i, *sp = state, *ep = ext, *protp;
        6: 8827:	register int numdiff = 0;
        -: 8828:
        6: 8829:	protp = &protsave[numecs * (pr - 1)];
        -: 8830:
      108: 8831:	for ( i = numecs; i > 0; --i )
        -: 8832:		{
      102: 8833:		if ( *++protp == *++sp )
        -: 8834:#ifndef F_A26
       64: 8835:			*++ep = SAME_TRANS;
        -: 8836:#else
        -: 8837:			*++ep <= SAME_TRANS;
        -: 8838:#endif
        -: 8839:		else
        -: 8840:			{
       38: 8841:			*++ep = *sp;
       38: 8842:			++numdiff;
        -: 8843:			}
        -: 8844:		}
        -: 8845:
        6: 8846:	return numdiff;
        -: 8847:	}
        -: 8848:/* yylex - scanner front-end for flex */
        -: 8849:
        -: 8850:/*-
        -: 8851: * Copyright (c) 1990 The Regents of the University of California.
        -: 8852: * All rights reserved.
        -: 8853: *
        -: 8854: * This code is derived from software contributed to Berkeley by
        -: 8855: * Vern Paxson.
        -: 8856: * 
        -: 8857: * The United States Government has rights in this work pursuant
        -: 8858: * to contract no. DE-AC03-76SF00098 between the United States
        -: 8859: * Department of Energy and the University of California.
        -: 8860: *
        -: 8861: * Redistribution and use in source and binary forms are permitted provided
        -: 8862: * that: (1) source distributions retain this entire copyright notice and
        -: 8863: * comment, and (2) distributions including binaries display the following
        -: 8864: * acknowledgement:  ``This product includes software developed by the
        -: 8865: * University of California, Berkeley and its contributors'' in the
        -: 8866: * documentation or other materials provided with the distribution and in
        -: 8867: * all advertising materials mentioning features or use of this software.
        -: 8868: * Neither the name of the University nor the names of its contributors may
        -: 8869: * be used to endorse or promote products derived from this software without
        -: 8870: * specific prior written permission.
        -: 8871: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 8872: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 8873: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 8874: */
        -: 8875:
        -: 8876:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 8877:
        -: 8878:
        -: 8879:/* yylex - scan for a regular expression token */
        -: 8880:
       40: 8881:int yylex()
        -: 8882:	{
        -: 8883:	int toktype;
        -: 8884:	static int beglin = false;
        -: 8885:	extern char *yytext;
        -: 8886:
       40: 8887:	if ( eofseen )
    #####: 8888:		toktype = EOF;
        -: 8889:	else
       40: 8890:		toktype = flexscan();
        -: 8891:
       40: 8892:	if ( toktype == EOF || toktype == 0 )
        -: 8893:		{
        1: 8894:		eofseen = 1;
        -: 8895:
        1: 8896:		if ( sectnum == 1 )
        -: 8897:			{
    #####: 8898:			synerr( _( "premature EOF" ) );
    #####: 8899:			sectnum = 2;
    #####: 8900:			toktype = SECTEND;
        -: 8901:			}
        -: 8902:
        -: 8903:		else
        1: 8904:			toktype = 0;
        -: 8905:		}
        -: 8906:
       40: 8907:	if ( trace )
        -: 8908:		{
    #####: 8909:		if ( beglin )
        -: 8910:			{
    #####: 8911:			fprintf( err, "%d\t", num_rules + 1 );
    #####: 8912:			beglin = 0;
        -: 8913:			}
        -: 8914:
    #####: 8915:		switch ( toktype )
        -: 8916:			{
        -: 8917:			case '<':
        -: 8918:			case '>':
        -: 8919:			case '^':
        -: 8920:			case '$':
        -: 8921:			case '"':
        -: 8922:			case '[':
        -: 8923:			case ']':
        -: 8924:			case '{':
        -: 8925:			case '}':
        -: 8926:			case '|':
        -: 8927:			case '(':
        -: 8928:			case ')':
        -: 8929:			case '-':
        -: 8930:			case '/':
        -: 8931:			case '\\':
        -: 8932:			case '?':
        -: 8933:			case '.':
        -: 8934:			case '*':
        -: 8935:			case '+':
        -: 8936:			case ',':
    #####: 8937:				(void) putc( toktype, err );
    #####: 8938:				break;
        -: 8939:
        -: 8940:			case '\n':
    #####: 8941:				(void) putc( '\n', err );
        -: 8942:
    #####: 8943:				if ( sectnum == 2 )
    #####: 8944:				beglin = 1;
        -: 8945:
    #####: 8946:				break;
        -: 8947:
        -: 8948:			case SCDECL:
    #####: 8949:				fputs( "%s", err );
    #####: 8950:				break;
        -: 8951:
        -: 8952:			case XSCDECL:
    #####: 8953:				fputs( "%x", err );
    #####: 8954:				break;
        -: 8955:
        -: 8956:			case SECTEND:
    #####: 8957:				fputs( "%%\n", err );
        -: 8958:
        -: 8959:				/* We set beglin to be true so we'll start
        -: 8960:				 * writing out numbers as we echo rules.
        -: 8961:				 * flexscan() has already assigned sectnum.
        -: 8962:				 */
    #####: 8963:				if ( sectnum == 2 )
    #####: 8964:					beglin = 1;
        -: 8965:
    #####: 8966:				break;
        -: 8967:
        -: 8968:			case NAME:
    #####: 8969:				fprintf( err, "'%s'", nmstr );
    #####: 8970:				break;
        -: 8971:
        -: 8972:			case CHAR:
    #####: 8973:				switch ( yylval )
        -: 8974:					{
        -: 8975:					case '<':
        -: 8976:					case '>':
        -: 8977:					case '^':
        -: 8978:					case '$':
        -: 8979:					case '"':
        -: 8980:					case '[':
        -: 8981:					case ']':
        -: 8982:					case '{':
        -: 8983:					case '}':
        -: 8984:					case '|':
        -: 8985:					case '(':
        -: 8986:					case ')':
        -: 8987:					case '-':
        -: 8988:					case '/':
        -: 8989:					case '\\':
        -: 8990:					case '?':
        -: 8991:					case '.':
        -: 8992:					case '*':
        -: 8993:					case '+':
        -: 8994:					case ',':
    #####: 8995:						fprintf( err, "\\%c",
        -: 8996:							yylval );
    #####: 8997:						break;
        -: 8998:
        -: 8999:					default:
    #####: 9000:						if ( ! isascii( yylval ) ||
    #####: 9001:						     ! isprint( yylval ) )
    #####: 9002:							fprintf( err,
        -: 9003:								"\\%.3o",
        -: 9004:							(unsigned int) yylval );
        -: 9005:						else
    #####: 9006:							(void) putc( yylval,
        -: 9007:								err );
    #####: 9008:					break;
        -: 9009:					}
        -: 9010:
    #####: 9011:				break;
        -: 9012:
        -: 9013:			case NUMBER:
    #####: 9014:				fprintf( err, "%d", yylval );
    #####: 9015:				break;
        -: 9016:
        -: 9017:			case PREVCCL:
    #####: 9018:				fprintf( err, "[%d]", yylval );
    #####: 9019:				break;
        -: 9020:
        -: 9021:			case EOF_OP:
    #####: 9022:				fprintf( err, "<<EOF>>" );
    #####: 9023:				break;
        -: 9024:
        -: 9025:			case OPTION_OP:
    #####: 9026:				fprintf( err, "%s ", yytext );
    #####: 9027:				break;
        -: 9028:
        -: 9029:			case OPT_OUTFILE:
        -: 9030:			case OPT_PREFIX:
        -: 9031:			case CCE_ALNUM:
        -: 9032:			case CCE_ALPHA:
        -: 9033:			case CCE_BLANK:
        -: 9034:			case CCE_CNTRL:
        -: 9035:			case CCE_DIGIT:
        -: 9036:			case CCE_GRAPH:
        -: 9037:			case CCE_LOWER:
        -: 9038:			case CCE_PRINT:
        -: 9039:			case CCE_PUNCT:
        -: 9040:			case CCE_SPACE:
        -: 9041:			case CCE_UPPER:
        -: 9042:			case CCE_XDIGIT:
    #####: 9043:				fprintf( err, "%s", yytext );
    #####: 9044:				break;
        -: 9045:
        -: 9046:			case 0:
    #####: 9047:				fprintf( err, _( "End Marker\n" ) );
    #####: 9048:				break;
        -: 9049:
        -: 9050:			default:
    #####: 9051:				fprintf( err,
        -: 9052:				_( "*Something Weird* - tok: %d val: %d\n" ),
        -: 9053:					toktype, yylval );
    #####: 9054:				break;
        -: 9055:			}
        -: 9056:		}
        -: 9057:
       40: 9058:	return toktype;
        -: 9059:	}
        -: 9060:
        -: 9061:/*  A Bison parser, made from ./parse.y
        -: 9062:    by GNU Bison version 1.28  */
        -: 9063:
        -: 9064:#define YYBISON 1  /* Identify Bison output.  */
        -: 9065:
        -: 9066:#define	CHAR	257
        -: 9067:#define	NUMBER	258
        -: 9068:#define	SECTEND	259
        -: 9069:#define	SCDECL	260
        -: 9070:#define	XSCDECL	261
        -: 9071:#define	NAME	262
        -: 9072:#define	PREVCCL	263
        -: 9073:#define	EOF_OP	264
        -: 9074:#define	OPTION_OP	265
        -: 9075:#define	OPT_OUTFILE	266
        -: 9076:#define	OPT_PREFIX	267
        -: 9077:#define	OPT_YYCLASS	268
        -: 9078:#define	CCE_ALNUM	269
        -: 9079:#define	CCE_ALPHA	270
        -: 9080:#define	CCE_BLANK	271
        -: 9081:#define	CCE_CNTRL	272
        -: 9082:#define	CCE_DIGIT	273
        -: 9083:#define	CCE_GRAPH	274
        -: 9084:#define	CCE_LOWER	275
        -: 9085:#define	CCE_PRINT	276
        -: 9086:#define	CCE_PUNCT	277
        -: 9087:#define	CCE_SPACE	278
        -: 9088:#define	CCE_UPPER	279
        -: 9089:#define	CCE_XDIGIT	280
        -: 9090:
        -: 9091:
        -: 9092:/*-
        -: 9093: * Copyright (c) 1990 The Regents of the University of California.
        -: 9094: * All rights reserved.
        -: 9095: *
        -: 9096: * This code is derived from software contributed to Berkeley by
        -: 9097: * Vern Paxson.
        -: 9098: * 
        -: 9099: * The United States Government has rights in this work pursuant
        -: 9100: * to contract no. DE-AC03-76SF00098 between the United States
        -: 9101: * Department of Energy and the University of California.
        -: 9102: *
        -: 9103: * Redistribution and use in source and binary forms are permitted provided
        -: 9104: * that: (1) source distributions retain this entire copyright notice and
        -: 9105: * comment, and (2) distributions including binaries display the following
        -: 9106: * acknowledgement:  ``This product includes software developed by the
        -: 9107: * University of California, Berkeley and its contributors'' in the
        -: 9108: * documentation or other materials provided with the distribution and in
        -: 9109: * all advertising materials mentioning features or use of this software.
        -: 9110: * Neither the name of the University nor the names of its contributors may
        -: 9111: * be used to endorse or promote products derived from this software without
        -: 9112: * specific prior written permission.
        -: 9113: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 9114: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 9115: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 9116: */
        -: 9117:
        -: 9118:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -: 9119:
        -: 9120:
        -: 9121:/* Some versions of bison are broken in that they use alloca() but don't
        -: 9122: * declare it properly.  The following is the patented (just kidding!)
        -: 9123: * #ifdef chud to fix the problem, courtesy of Francois Pinard.
        -: 9124: */
        -: 9125:#ifdef YYBISON
        -: 9126:/* AIX requires this to be the first thing in the file.  What a piece.  */
        -: 9127:# ifdef _AIX
        -: 9128: #pragma alloca
        -: 9129:# endif
        -: 9130:#endif
        -: 9131:
        -: 9132:
        -: 9133:/* The remainder of the alloca() cruft has to come after including flexdef.h,
        -: 9134: * so HAVE_ALLOCA_H is (possibly) defined.
        -: 9135: */
        -: 9136:#ifdef YYBISON
        -: 9137:# ifdef __GNUC__
        -: 9138:#  ifndef alloca
        -: 9139:#   define alloca __builtin_alloca
        -: 9140:#  endif
        -: 9141:# else
        -: 9142:#  if HAVE_ALLOCA_H
        -: 9143:#   include <alloca.h>
        -: 9144:#  else
        -: 9145:#   ifdef __hpux
        -: 9146:void *alloca ();
        -: 9147:#   else
        -: 9148:#    ifdef __TURBOC__
        -: 9149:#     include <malloc.h>
        -: 9150:#    else
        -: 9151:char *alloca ();
        -: 9152:#    endif
        -: 9153:#   endif
        -: 9154:#  endif
        -: 9155:# endif
        -: 9156:#endif
        -: 9157:
        -: 9158:/* Bletch, ^^^^ that was ugly! */
        -: 9159:
        -: 9160:
        -: 9161:int pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, rulelen;
        -: 9162:int trlcontxt, xcluflg, currccl, cclsorted, varlength, variable_trail_rule;
        -: 9163:
        -: 9164:int *scon_stk;
        -: 9165:int scon_stk_ptr;
        -: 9166:
        -: 9167:static int madeany = false;  /* whether we've made the '.' character class */
        -: 9168:int previous_continued_action;	/* whether the previous rule's action was '|' */
        -: 9169:
        -: 9170:/* Expand a POSIX character class expression. */
        -: 9171:#define CCL_EXPR(func) \
        -: 9172:	{ \
        -: 9173:	int c; \
        -: 9174:	for ( c = 0; c < csize; ++c ) \
        -: 9175:		if ( isascii(c) && func(c) ) \
        -: 9176:			ccladd( currccl, c ); \
        -: 9177:	}
        -: 9178:
        -: 9179:/* While POSIX defines isblank(), it's not ANSI C. */
        -: 9180:#define IS_BLANK(c) ((c) == ' ' || (c) == '\t')
        -: 9181:
        -: 9182:/* On some over-ambitious machines, such as DEC Alpha's, the default
        -: 9183: * token type is "long" instead of "int"; this leads to problems with
        -: 9184: * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen
        -: 9185: * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the
        -: 9186: * following should ensure that the default token type is "int".
        -: 9187: */
        -: 9188:#define YYSTYPE int
        -: 9189:
        -: 9190:#ifndef YYSTYPE
        -: 9191:#define YYSTYPE int
        -: 9192:#endif
        -: 9193:#include <stdio.h>
        -: 9194:
        -: 9195:#ifndef __cplusplus
        -: 9196:#ifndef __STDC__
        -: 9197:#define const
        -: 9198:#endif
        -: 9199:#endif
        -: 9200:
        -: 9201:
        -: 9202:
        -: 9203:#define	YYFINAL		107
        -: 9204:#define	YYFLAG		-32768
        -: 9205:#define	YYNTBASE	48
        -: 9206:
        -: 9207:#define YYTRANSLATE(x) ((unsigned)(x) <= 280 ? yytranslate[x] : 73)
        -: 9208:
        -: 9209:static const char yytranslate[] = {     0,
        -: 9210:     2,     2,     2,     2,     2,     2,     2,     2,     2,    28,
        -: 9211:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9212:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9213:     2,     2,     2,    42,     2,    36,     2,     2,     2,    43,
        -: 9214:    44,    34,    39,    35,    47,    41,    38,     2,     2,     2,
        -: 9215:     2,     2,     2,     2,     2,     2,     2,     2,     2,    32,
        -: 9216:    27,    33,    40,     2,     2,     2,     2,     2,     2,     2,
        -: 9217:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9218:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9219:    45,     2,    46,    31,     2,     2,     2,     2,     2,     2,
        -: 9220:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9221:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9222:     2,     2,    29,    37,    30,     2,     2,     2,     2,     2,
        -: 9223:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9224:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9225:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9226:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9227:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9228:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9229:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9230:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9231:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9232:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9233:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9234:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 9235:     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
        -: 9236:     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
        -: 9237:    17,    18,    19,    20,    21,    22,    23,    24,    25,    26
        -: 9238:};
        -: 9239:
        -: 9240:#if YYDEBUG != 0
        -: 9241:static const short yyprhs[] = {     0,
        -: 9242:     0,     6,     7,    11,    14,    15,    17,    19,    21,    23,
        -: 9243:    26,    28,    30,    33,    36,    37,    41,    45,    49,    55,
        -: 9244:    61,    62,    63,    66,    68,    70,    72,    73,    78,    82,
        -: 9245:    83,    87,    89,    91,    93,    96,   100,   103,   105,   109,
        -: 9246:   111,   114,   117,   119,   122,   125,   128,   135,   141,   146,
        -: 9247:   148,   150,   152,   156,   160,   162,   166,   171,   176,   179,
        -: 9248:   182,   183,   185,   187,   189,   191,   193,   195,   197,   199,
        -: 9249:   201,   203,   205,   207,   210
        -: 9250:};
        -: 9251:
        -: 9252:static const short yyrhs[] = {    49,
        -: 9253:    50,    51,    57,    58,     0,     0,    50,    52,    53,     0,
        -: 9254:    50,    54,     0,     0,     1,     0,     5,     0,     6,     0,
        -: 9255:     7,     0,    53,     8,     0,     8,     0,     1,     0,    11,
        -: 9256:    55,     0,    55,    56,     0,     0,    12,    27,     8,     0,
        -: 9257:    13,    27,     8,     0,    14,    27,     8,     0,    57,    61,
        -: 9258:    58,    59,    28,     0,    57,    61,    29,    57,    30,     0,
        -: 9259:     0,     0,    31,    64,     0,    64,     0,    10,     0,     1,
        -: 9260:     0,     0,    32,    60,    62,    33,     0,    32,    34,    33,
        -: 9261:     0,     0,    62,    35,    63,     0,    63,     0,     1,     0,
        -: 9262:     8,     0,    66,    65,     0,    66,    65,    36,     0,    65,
        -: 9263:    36,     0,    65,     0,    65,    37,    67,     0,    67,     0,
        -: 9264:    65,    38,     0,    67,    68,     0,    68,     0,    68,    34,
        -: 9265:     0,    68,    39,     0,    68,    40,     0,    68,    29,     4,
        -: 9266:    35,     4,    30,     0,    68,    29,     4,    35,    30,     0,
        -: 9267:    68,    29,     4,    30,     0,    41,     0,    69,     0,     9,
        -: 9268:     0,    42,    72,    42,     0,    43,    65,    44,     0,     3,
        -: 9269:     0,    45,    70,    46,     0,    45,    31,    70,    46,     0,
        -: 9270:    70,     3,    47,     3,     0,    70,     3,     0,    70,    71,
        -: 9271:     0,     0,    15,     0,    16,     0,    17,     0,    18,     0,
        -: 9272:    19,     0,    20,     0,    21,     0,    22,     0,    23,     0,
        -: 9273:    24,     0,    25,     0,    26,     0,    72,     3,     0,     0
        -: 9274:};
        -: 9275:
        -: 9276:#endif
        -: 9277:
        -: 9278:#if YYDEBUG != 0
        -: 9279:static const short yyrline[] = { 0,
        -: 9280:   112,   141,   149,   150,   151,   152,   156,   164,   167,   171,
        -: 9281:   174,   177,   181,   184,   185,   188,   193,   195,   199,   201,
        -: 9282:   203,   206,   219,   255,   279,   302,   306,   310,   313,   330,
        -: 9283:   334,   336,   338,   342,   365,   420,   423,   466,   484,   490,
        -: 9284:   495,   522,   530,   534,   541,   547,   553,   581,   595,   614,
        -: 9285:   636,   654,   661,   664,   667,   678,   681,   688,   716,   727,
        -: 9286:   734,   742,   743,   744,   745,   746,   747,   748,   749,   750,
        -: 9287:   751,   752,   758,   761,   771
        -: 9288:};
        -: 9289:#endif
        -: 9290:
        -: 9291:
        -: 9292:#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
        -: 9293:
        -: 9294:static const char * const yytname[] = {   "$","error","$undefined.","CHAR","NUMBER",
        -: 9295:"SECTEND","SCDECL","XSCDECL","NAME","PREVCCL","EOF_OP","OPTION_OP","OPT_OUTFILE",
        -: 9296:"OPT_PREFIX","OPT_YYCLASS","CCE_ALNUM","CCE_ALPHA","CCE_BLANK","CCE_CNTRL","CCE_DIGIT",
        -: 9297:"CCE_GRAPH","CCE_LOWER","CCE_PRINT","CCE_PUNCT","CCE_SPACE","CCE_UPPER","CCE_XDIGIT",
        -: 9298:"'='","'\\n'","'{'","'}'","'^'","'<'","'>'","'*'","','","'$'","'|'","'/'","'+'",
        -: 9299:"'?'","'.'","'\\\"'","'('","')'","'['","']'","'-'","goal","initlex","sect1",
        -: 9300:"sect1end","startconddecl","namelist1","options","optionlist","option","sect2",
        -: 9301:"initforrule","flexrule","scon_stk_ptr","scon","namelist2","sconname","rule",
        -: 9302:"re","re2","series","singleton","fullccl","ccl","ccl_expr","string", NULL
        -: 9303:};
        -: 9304:#endif
        -: 9305:
        -: 9306:static const short yyr1[] = {     0,
        -: 9307:    48,    49,    50,    50,    50,    50,    51,    52,    52,    53,
        -: 9308:    53,    53,    54,    55,    55,    56,    56,    56,    57,    57,
        -: 9309:    57,    58,    59,    59,    59,    59,    60,    61,    61,    61,
        -: 9310:    62,    62,    62,    63,    64,    64,    64,    64,    65,    65,
        -: 9311:    66,    67,    67,    68,    68,    68,    68,    68,    68,    68,
        -: 9312:    68,    68,    68,    68,    68,    69,    69,    70,    70,    70,
        -: 9313:    70,    71,    71,    71,    71,    71,    71,    71,    71,    71,
        -: 9314:    71,    71,    71,    72,    72
        -: 9315:};
        -: 9316:
        -: 9317:static const short yyr2[] = {     0,
        -: 9318:     5,     0,     3,     2,     0,     1,     1,     1,     1,     2,
        -: 9319:     1,     1,     2,     2,     0,     3,     3,     3,     5,     5,
        -: 9320:     0,     0,     2,     1,     1,     1,     0,     4,     3,     0,
        -: 9321:     3,     1,     1,     1,     2,     3,     2,     1,     3,     1,
        -: 9322:     2,     2,     1,     2,     2,     2,     6,     5,     4,     1,
        -: 9323:     1,     1,     3,     3,     1,     3,     4,     4,     2,     2,
        -: 9324:     0,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        -: 9325:     1,     1,     1,     2,     0
        -: 9326:};
        -: 9327:
        -: 9328:static const short yydefact[] = {     2,
        -: 9329:     0,     6,     0,     7,     8,     9,    15,    21,     0,     4,
        -: 9330:    13,    30,    12,    11,     3,     0,     0,     0,    14,    27,
        -: 9331:     1,    22,    10,     0,     0,     0,     0,     0,    21,     0,
        -: 9332:    16,    17,    18,    29,    33,    34,     0,    32,    30,    26,
        -: 9333:    55,    52,    25,     0,    50,    75,     0,    61,     0,    24,
        -: 9334:    38,     0,    40,    43,    51,    28,     0,    20,    23,     0,
        -: 9335:     0,    61,     0,    19,    37,     0,    41,    35,    42,     0,
        -: 9336:    44,    45,    46,    31,    74,    53,    54,     0,    59,    62,
        -: 9337:    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
        -: 9338:    73,    56,    60,    39,    36,     0,    57,     0,    49,     0,
        -: 9339:    58,     0,    48,    47,     0,     0,     0
        -: 9340:};
        -: 9341:
        -: 9342:static const short yydefgoto[] = {   105,
        -: 9343:     1,     3,     8,     9,    15,    10,    11,    19,    12,    21,
        -: 9344:    49,    28,    22,    37,    38,    50,    51,    52,    53,    54,
        -: 9345:    55,    63,    93,    60
        -: 9346:};
        -: 9347:
        -: 9348:static const short yypact[] = {-32768,
        -: 9349:    78,-32768,    81,-32768,-32768,-32768,-32768,-32768,     6,-32768,
        -: 9350:    -2,     5,-32768,-32768,    -7,   -14,     1,     9,-32768,    28,
        -: 9351:-32768,    14,-32768,    55,    65,    74,    57,    30,-32768,    -1,
        -: 9352:-32768,-32768,-32768,-32768,-32768,-32768,    58,-32768,    44,-32768,
        -: 9353:-32768,-32768,-32768,    24,-32768,-32768,    24,    63,    69,-32768,
        -: 9354:    23,    24,    24,    41,-32768,-32768,    90,-32768,-32768,    26,
        -: 9355:    27,-32768,     0,-32768,-32768,    24,-32768,    59,    41,    95,
        -: 9356:-32768,-32768,-32768,-32768,-32768,-32768,-32768,    32,    53,-32768,
        -: 9357:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
        -: 9358:-32768,-32768,-32768,    24,-32768,     4,-32768,    98,-32768,     2,
        -: 9359:-32768,    72,-32768,-32768,   103,   104,-32768
        -: 9360:};
        -: 9361:
        -: 9362:static const short yypgoto[] = {-32768,
        -: 9363:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    76,    84,
        -: 9364:-32768,-32768,-32768,-32768,    50,    64,    25,-32768,    43,   -49,
        -: 9365:-32768,    48,-32768,-32768
        -: 9366:};
        -: 9367:
        -: 9368:
        -: 9369:#define	YYLAST		110
        -: 9370:
        -: 9371:
        -: 9372:static const short yytable[] = {    40,
        -: 9373:    23,    41,    79,    69,   -22,   102,    13,    42,    43,    16,
        -: 9374:    17,    18,    24,    14,    80,    81,    82,    83,    84,    85,
        -: 9375:    86,    87,    88,    89,    90,    91,    41,    25,    75,    44,
        -: 9376:    35,   103,    42,    99,    79,    26,    20,    36,   100,    45,
        -: 9377:    46,    47,    29,    48,    69,    92,    80,    81,    82,    83,
        -: 9378:    84,    85,    86,    87,    88,    89,    90,    91,    65,    66,
        -: 9379:    67,    27,    31,    66,    45,    46,    47,    76,    48,    70,
        -: 9380:    77,    61,    32,    58,    71,    20,    68,    97,     2,    72,
        -: 9381:    73,    33,    -5,    -5,    -5,     4,     5,     6,    -5,    34,
        -: 9382:    56,     7,    57,    62,    95,    66,    64,    36,    96,    98,
        -: 9383:   101,   104,   106,   107,    39,    30,    74,    59,    94,    78
        -: 9384:};
        -: 9385:
        -: 9386:static const short yycheck[] = {     1,
        -: 9387:     8,     3,     3,    53,     0,     4,     1,     9,    10,    12,
        -: 9388:    13,    14,    27,     8,    15,    16,    17,    18,    19,    20,
        -: 9389:    21,    22,    23,    24,    25,    26,     3,    27,     3,    31,
        -: 9390:     1,    30,     9,    30,     3,    27,    32,     8,    35,    41,
        -: 9391:    42,    43,    29,    45,    94,    46,    15,    16,    17,    18,
        -: 9392:    19,    20,    21,    22,    23,    24,    25,    26,    36,    37,
        -: 9393:    38,    34,     8,    37,    41,    42,    43,    42,    45,    29,
        -: 9394:    44,    47,     8,    30,    34,    32,    52,    46,     1,    39,
        -: 9395:    40,     8,     5,     6,     7,     5,     6,     7,    11,    33,
        -: 9396:    33,    11,    35,    31,    36,    37,    28,     8,     4,    47,
        -: 9397:     3,    30,     0,     0,    29,    22,    57,    44,    66,    62
        -: 9398:};
        -: 9399:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
        -: 9400:/* This file comes from bison-1.28.  */
        -: 9401:
        -: 9402:/* Skeleton output parser for bison,
        -: 9403:   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
        -: 9404:
        -: 9405:   This program is free software; you can redistribute it and/or modify
        -: 9406:   it under the terms of the GNU General Public License as published by
        -: 9407:   the Free Software Foundation; either version 2, or (at your option)
        -: 9408:   any later version.
        -: 9409:
        -: 9410:   This program is distributed in the hope that it will be useful,
        -: 9411:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 9412:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 9413:   GNU General Public License for more details.
        -: 9414:
        -: 9415:   You should have received a copy of the GNU General Public License
        -: 9416:   along with this program; if not, write to the Free Software
        -: 9417:   Foundation, Inc., 59 Temple Place - Suite 330,
        -: 9418:   Boston, MA 02111-1307, USA.  */
        -: 9419:
        -: 9420:/* As a special exception, when this file is copied by Bison into a
        -: 9421:   Bison output file, you may use that output file without restriction.
        -: 9422:   This special exception was added by the Free Software Foundation
        -: 9423:   in version 1.24 of Bison.  */
        -: 9424:
        -: 9425:/* This is the parser code that is written into each bison parser
        -: 9426:  when the %semantic_parser declaration is not specified in the grammar.
        -: 9427:  It was written by Richard Stallman by simplifying the hairy parser
        -: 9428:  used when %semantic_parser is specified.  */
        -: 9429:
        -: 9430:#ifndef YYSTACK_USE_ALLOCA
        -: 9431:#ifdef alloca
        -: 9432:#define YYSTACK_USE_ALLOCA
        -: 9433:#else /* alloca not defined */
        -: 9434:#ifdef __GNUC__
        -: 9435:#define YYSTACK_USE_ALLOCA
        -: 9436:#define alloca __builtin_alloca
        -: 9437:#else /* not GNU C.  */
        -: 9438:#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
        -: 9439:#define YYSTACK_USE_ALLOCA
        -: 9440:#include <alloca.h>
        -: 9441:#else /* not sparc */
        -: 9442:/* We think this test detects Watcom and Microsoft C.  */
        -: 9443:/* This used to test MSDOS, but that is a bad idea
        -: 9444:   since that symbol is in the user namespace.  */
        -: 9445:#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
        -: 9446:#if 0 /* No need for malloc.h, which pollutes the namespace;
        -: 9447:	 instead, just don't use alloca.  */
        -: 9448:#include <malloc.h>
        -: 9449:#endif
        -: 9450:#else /* not MSDOS, or __TURBOC__ */
        -: 9451:#if defined(_AIX)
        -: 9452:/* I don't know what this was needed for, but it pollutes the namespace.
        -: 9453:   So I turned it off.   rms, 2 May 1997.  */
        -: 9454:/* #include <malloc.h>  */
        -: 9455: #pragma alloca
        -: 9456:#define YYSTACK_USE_ALLOCA
        -: 9457:#else /* not MSDOS, or __TURBOC__, or _AIX */
        -: 9458:#if 0
        -: 9459:#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
        -: 9460:		 and on HPUX 10.  Eventually we can turn this on.  */
        -: 9461:#define YYSTACK_USE_ALLOCA
        -: 9462:#define alloca __builtin_alloca
        -: 9463:#endif /* __hpux */
        -: 9464:#endif
        -: 9465:#endif /* not _AIX */
        -: 9466:#endif /* not MSDOS, or __TURBOC__ */
        -: 9467:#endif /* not sparc */
        -: 9468:#endif /* not GNU C */
        -: 9469:#endif /* alloca not defined */
        -: 9470:#endif /* YYSTACK_USE_ALLOCA not defined */
        -: 9471:
        -: 9472:#ifdef YYSTACK_USE_ALLOCA
        -: 9473:#define YYSTACK_ALLOC alloca
        -: 9474:#else
        -: 9475:#define YYSTACK_ALLOC malloc
        -: 9476:#endif
        -: 9477:
        -: 9478:/* Note: there must be only one dollar sign in this file.
        -: 9479:   It is replaced by the list of actions, each action
        -: 9480:   as one case of the switch.  */
        -: 9481:
        -: 9482:#define yyerrok		(yyerrstatus = 0)
        -: 9483:#define yyclearin	(yychar = YYEMPTY)
        -: 9484:#define YYEMPTY		-2
        -: 9485:#define YYEOF		0
        -: 9486:#define YYACCEPT	goto yyacceptlab
        -: 9487:#define YYABORT 	goto yyabortlab
        -: 9488:#define YYERROR		goto yyerrlab1
        -: 9489:/* Like YYERROR except do call yyerror.
        -: 9490:   This remains here temporarily to ease the
        -: 9491:   transition to the new meaning of YYERROR, for GCC.
        -: 9492:   Once GCC version 2 has supplanted version 1, this can go.  */
        -: 9493:#define YYFAIL		goto yyerrlab
        -: 9494:#define YYRECOVERING()  (!!yyerrstatus)
        -: 9495:#define YYBACKUP(token, value) \
        -: 9496:do								\
        -: 9497:  if (yychar == YYEMPTY && yylen == 1)				\
        -: 9498:    { yychar = (token), yylval = (value);			\
        -: 9499:      yychar1 = YYTRANSLATE (yychar);				\
        -: 9500:      YYPOPSTACK;						\
        -: 9501:      goto yybackup;						\
        -: 9502:    }								\
        -: 9503:  else								\
        -: 9504:    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
        -: 9505:while (0)
        -: 9506:
        -: 9507:#define YYTERROR	1
        -: 9508:#define YYERRCODE	256
        -: 9509:
        -: 9510:#ifndef YYPURE
        -: 9511:#define YYLEX		yylex()
        -: 9512:#endif
        -: 9513:
        -: 9514:#ifdef YYPURE
        -: 9515:#ifdef YYLSP_NEEDED
        -: 9516:#ifdef YYLEX_PARAM
        -: 9517:#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
        -: 9518:#else
        -: 9519:#define YYLEX		yylex(&yylval, &yylloc)
        -: 9520:#endif
        -: 9521:#else /* not YYLSP_NEEDED */
        -: 9522:#ifdef YYLEX_PARAM
        -: 9523:#define YYLEX		yylex(&yylval, YYLEX_PARAM)
        -: 9524:#else
        -: 9525:#define YYLEX		yylex(&yylval)
        -: 9526:#endif
        -: 9527:#endif /* not YYLSP_NEEDED */
        -: 9528:#endif
        -: 9529:
        -: 9530:/* If nonreentrant, generate the variables here */
        -: 9531:
        -: 9532:#ifndef YYPURE
        -: 9533:
        -: 9534:int	yychar;			/*  the lookahead symbol		*/
        -: 9535:YYSTYPE	yylval;			/*  the semantic value of the		*/
        -: 9536:				/*  lookahead symbol			*/
        -: 9537:
        -: 9538:#ifdef YYLSP_NEEDED
        -: 9539:YYLTYPE yylloc;			/*  location data for the lookahead	*/
        -: 9540:				/*  symbol				*/
        -: 9541:#endif
        -: 9542:
        -: 9543:int yynerrs;			/*  number of parse errors so far       */
        -: 9544:#endif  /* not YYPURE */
        -: 9545:
        -: 9546:#if YYDEBUG != 0
        -: 9547:int yydebug;			/*  nonzero means print parse trace	*/
        -: 9548:/* Since this is uninitialized, it does not stop multiple parsers
        -: 9549:   from coexisting.  */
        -: 9550:#endif
        -: 9551:
        -: 9552:/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
        -: 9553:
        -: 9554:#ifndef	YYINITDEPTH
        -: 9555:#define YYINITDEPTH 200
        -: 9556:#endif
        -: 9557:
        -: 9558:/*  YYMAXDEPTH is the maximum size the stacks can grow to
        -: 9559:    (effective only if the built-in stack extension method is used).  */
        -: 9560:
        -: 9561:#if YYMAXDEPTH == 0
        -: 9562:#undef YYMAXDEPTH
        -: 9563:#endif
        -: 9564:
        -: 9565:#ifndef YYMAXDEPTH
        -: 9566:#define YYMAXDEPTH 10000
        -: 9567:#endif
        -: 9568:/* Define __yy_memcpy.  Note that the size argument
        -: 9569:   should be passed with type unsigned int, because that is what the non-GCC
        -: 9570:   definitions require.  With GCC, __builtin_memcpy takes an arg
        -: 9571:   of type size_t, but it can handle unsigned int.  */
        -: 9572:
        -: 9573:#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
        -: 9574:#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
        -: 9575:#else				/* not GNU C or C++ */
        -: 9576:#ifndef __cplusplus
        -: 9577:
        -: 9578:/* This is the most reliable way to avoid incompatibilities
        -: 9579:   in available built-in functions on various systems.  */
        -: 9580:static void
        -: 9581:__yy_memcpy (to, from, count)
        -: 9582:     char *to;
        -: 9583:     char *from;
        -: 9584:     unsigned int count;
        -: 9585:{
        -: 9586:  register char *f = from;
        -: 9587:  register char *t = to;
        -: 9588:  register int i = count;
        -: 9589:
        -: 9590:  while (i-- > 0)
        -: 9591:    *t++ = *f++;
        -: 9592:}
        -: 9593:
        -: 9594:#else /* __cplusplus */
        -: 9595:
        -: 9596:/* This is the most reliable way to avoid incompatibilities
        -: 9597:   in available built-in functions on various systems.  */
        -: 9598:static void
        -: 9599:__yy_memcpy (char *to, char *from, unsigned int count)
        -: 9600:{
        -: 9601:  register char *t = to;
        -: 9602:  register char *f = from;
        -: 9603:  register int i = count;
        -: 9604:
        -: 9605:  while (i-- > 0)
        -: 9606:    *t++ = *f++;
        -: 9607:}
        -: 9608:
        -: 9609:#endif
        -: 9610:#endif
        -: 9611:
        -: 9612:/* The user can define YYPARSE_PARAM as the name of an argument to be passed
        -: 9613:   into yyparse.  The argument should have type void *.
        -: 9614:   It should actually point to an object.
        -: 9615:   Grammar actions can access the variable by casting it
        -: 9616:   to the proper pointer type.  */
        -: 9617:
        -: 9618:#ifdef YYPARSE_PARAM
        -: 9619:#ifdef __cplusplus
        -: 9620:#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
        -: 9621:#define YYPARSE_PARAM_DECL
        -: 9622:#else /* not __cplusplus */
        -: 9623:#define YYPARSE_PARAM_ARG YYPARSE_PARAM
        -: 9624:#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
        -: 9625:#endif /* not __cplusplus */
        -: 9626:#else /* not YYPARSE_PARAM */
        -: 9627:#define YYPARSE_PARAM_ARG
        -: 9628:#define YYPARSE_PARAM_DECL
        -: 9629:#endif /* not YYPARSE_PARAM */
        -: 9630:
        -: 9631:/* Prevent warning if -Wstrict-prototypes.  */
        -: 9632:#ifdef __GNUC__
        -: 9633:#ifdef YYPARSE_PARAM
        -: 9634:int yyparse (void *);
        -: 9635:#else
        -: 9636:int yyparse (void);
        -: 9637:#endif
        -: 9638:#endif
        -: 9639:
        -: 9640:int
        1: 9641:yyparse(YYPARSE_PARAM_ARG)
        -: 9642:     YYPARSE_PARAM_DECL
        -: 9643:{
        -: 9644:  register int yystate;
        -: 9645:  register int yyn;
        -: 9646:  register short *yyssp;
        -: 9647:  register YYSTYPE *yyvsp;
        -: 9648:  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
        1: 9649:  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
        -: 9650:
        -: 9651:  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
        -: 9652:  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
        -: 9653:
        1: 9654:  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
        1: 9655:  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
        -: 9656:
        -: 9657:#ifdef YYLSP_NEEDED
        -: 9658:  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
        -: 9659:  YYLTYPE *yyls = yylsa;
        -: 9660:  YYLTYPE *yylsp;
        -: 9661:
        -: 9662:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
        -: 9663:#else
        -: 9664:#define YYPOPSTACK   (yyvsp--, yyssp--)
        -: 9665:#endif
        -: 9666:
        1: 9667:  int yystacksize = YYINITDEPTH;
        1: 9668:  int yyfree_stacks = 0;
        -: 9669:
        -: 9670:#ifdef YYPURE
        -: 9671:  int yychar;
        -: 9672:  YYSTYPE yylval;
        -: 9673:  int yynerrs;
        -: 9674:#ifdef YYLSP_NEEDED
        -: 9675:  YYLTYPE yylloc;
        -: 9676:#endif
        -: 9677:#endif
        -: 9678:
        -: 9679:  YYSTYPE yyval;		/*  the variable used to return		*/
        -: 9680:				/*  semantic values from the action	*/
        -: 9681:				/*  routines				*/
        -: 9682:
        -: 9683:  int yylen;
        -: 9684:
        -: 9685:#if YYDEBUG != 0
        -: 9686:  if (yydebug)
        -: 9687:    fprintf(err, "Starting parse\n");
        -: 9688:#endif
        -: 9689:
        1: 9690:  yystate = 0;
        1: 9691:  yyerrstatus = 0;
        1: 9692:  yynerrs = 0;
        1: 9693:  yychar = YYEMPTY;		/* Cause a token to be read.  */
        -: 9694:
        -: 9695:  /* Initialize stack pointers.
        -: 9696:     Waste one element of value and location stack
        -: 9697:     so that they stay on the same level as the state stack.
        -: 9698:     The wasted elements are never initialized.  */
        -: 9699:
        1: 9700:  yyssp = yyss - 1;
        1: 9701:  yyvsp = yyvs;
        -: 9702:#ifdef YYLSP_NEEDED
        -: 9703:  yylsp = yyls;
        -: 9704:#endif
        -: 9705:
        -: 9706:/* Push a new state, which is found in  yystate  .  */
        -: 9707:/* In all cases, when you get here, the value and location stacks
        -: 9708:   have just been pushed. so pushing a state here evens the stacks.  */
        -: 9709:yynewstate:
        -: 9710:
      136: 9711:  *++yyssp = yystate;
        -: 9712:
      136: 9713:  if (yyssp >= yyss + yystacksize - 1)
        -: 9714:    {
        -: 9715:      /* Give user a chance to reallocate the stack */
        -: 9716:      /* Use copies of these so that the &'s don't force the real ones into memory. */
    #####: 9717:      YYSTYPE *yyvs1 = yyvs;
    #####: 9718:      short *yyss1 = yyss;
        -: 9719:#ifdef YYLSP_NEEDED
        -: 9720:      YYLTYPE *yyls1 = yyls;
        -: 9721:#endif
        -: 9722:
        -: 9723:      /* Get the current used size of the three stacks, in elements.  */
    #####: 9724:      int size = yyssp - yyss + 1;
        -: 9725:
        -: 9726:#ifdef yyoverflow
        -: 9727:      /* Each stack pointer address is followed by the size of
        -: 9728:	 the data in use in that stack, in bytes.  */
        -: 9729:#ifdef YYLSP_NEEDED
        -: 9730:      /* This used to be a conditional around just the two extra args,
        -: 9731:	 but that might be undefined if yyoverflow is a macro.  */
        -: 9732:      yyoverflow("parser stack overflow",
        -: 9733:		 &yyss1, size * sizeof (*yyssp),
        -: 9734:		 &yyvs1, size * sizeof (*yyvsp),
        -: 9735:		 &yyls1, size * sizeof (*yylsp),
        -: 9736:		 &yystacksize);
        -: 9737:#else
        -: 9738:      yyoverflow("parser stack overflow",
        -: 9739:		 &yyss1, size * sizeof (*yyssp),
        -: 9740:		 &yyvs1, size * sizeof (*yyvsp),
        -: 9741:		 &yystacksize);
        -: 9742:#endif
        -: 9743:
        -: 9744:      yyss = yyss1; yyvs = yyvs1;
        -: 9745:#ifdef YYLSP_NEEDED
        -: 9746:      yyls = yyls1;
        -: 9747:#endif
        -: 9748:#else /* no yyoverflow */
        -: 9749:      /* Extend the stack our own way.  */
    #####: 9750:      if (yystacksize >= YYMAXDEPTH)
        -: 9751:	{
    #####: 9752:	  yyerror("parser stack overflow");
    #####: 9753:	  if (yyfree_stacks)
        -: 9754:	    {
    #####: 9755:	      free (yyss);
    #####: 9756:	      free (yyvs);
        -: 9757:#ifdef YYLSP_NEEDED
        -: 9758:	      free (yyls);
        -: 9759:#endif
        -: 9760:	    }
    #####: 9761:	  return 2;
        -: 9762:	}
    #####: 9763:      yystacksize *= 2;
    #####: 9764:      if (yystacksize > YYMAXDEPTH)
    #####: 9765:	yystacksize = YYMAXDEPTH;
        -: 9766:#ifndef YYSTACK_USE_ALLOCA
        -: 9767:      yyfree_stacks = 1;
        -: 9768:#endif
    #####: 9769:      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
    #####: 9770:      __yy_memcpy ((char *)yyss, (char *)yyss1,
        -: 9771:		   size * (unsigned int) sizeof (*yyssp));
    #####: 9772:      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
    #####: 9773:      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
        -: 9774:		   size * (unsigned int) sizeof (*yyvsp));
        -: 9775:#ifdef YYLSP_NEEDED
        -: 9776:      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
        -: 9777:      __yy_memcpy ((char *)yyls, (char *)yyls1,
        -: 9778:		   size * (unsigned int) sizeof (*yylsp));
        -: 9779:#endif
        -: 9780:#endif /* no yyoverflow */
        -: 9781:
    #####: 9782:      yyssp = yyss + size - 1;
    #####: 9783:      yyvsp = yyvs + size - 1;
        -: 9784:#ifdef YYLSP_NEEDED
        -: 9785:      yylsp = yyls + size - 1;
        -: 9786:#endif
        -: 9787:
        -: 9788:#if YYDEBUG != 0
        -: 9789:      if (yydebug)
        -: 9790:	fprintf(err, "Stack size increased to %d\n", yystacksize);
        -: 9791:#endif
        -: 9792:
    #####: 9793:      if (yyssp >= yyss + yystacksize - 1)
    #####: 9794:	YYABORT;
        -: 9795:    }
        -: 9796:
        -: 9797:#if YYDEBUG != 0
        -: 9798:  if (yydebug)
        -: 9799:    fprintf(err, "Entering state %d\n", yystate);
        -: 9800:#endif
        -: 9801:
      136: 9802:  goto yybackup;
        -: 9803: yybackup:
        -: 9804:
        -: 9805:/* Do appropriate processing given the current state.  */
        -: 9806:/* Read a lookahead token if we need one and don't already have one.  */
        -: 9807:/* yyresume: */
        -: 9808:
        -: 9809:  /* First try to decide what to do without reference to lookahead token.  */
        -: 9810:
      136: 9811:  yyn = yypact[yystate];
      136: 9812:  if (yyn == YYFLAG)
       41: 9813:    goto yydefault;
        -: 9814:
        -: 9815:  /* Not known => get a lookahead token if don't already have one.  */
        -: 9816:
        -: 9817:  /* yychar is either YYEMPTY or YYEOF
        -: 9818:     or a valid token in external form.  */
        -: 9819:
       95: 9820:  if (yychar == YYEMPTY)
        -: 9821:    {
        -: 9822:#if YYDEBUG != 0
        -: 9823:      if (yydebug)
        -: 9824:	fprintf(err, "Reading a token: ");
        -: 9825:#endif
       40: 9826:      yychar = YYLEX;
        -: 9827:    }
        -: 9828:
        -: 9829:  /* Convert token to internal form (in yychar1) for indexing tables with */
        -: 9830:
       95: 9831:  if (yychar <= 0)		/* This means end of input. */
        -: 9832:    {
        3: 9833:      yychar1 = 0;
        3: 9834:      yychar = YYEOF;		/* Don't call YYLEX any more */
        -: 9835:
        -: 9836:#if YYDEBUG != 0
        -: 9837:      if (yydebug)
        -: 9838:	fprintf(err, "Now at end of input.\n");
        -: 9839:#endif
        -: 9840:    }
        -: 9841:  else
        -: 9842:    {
       92: 9843:      yychar1 = YYTRANSLATE(yychar);
        -: 9844:
        -: 9845:#if YYDEBUG != 0
        -: 9846:      if (yydebug)
        -: 9847:	{
        -: 9848:	  fprintf (err, "Next token is %d (%s", yychar, yytname[yychar1]);
        -: 9849:	  /* Give the individual parser a way to print the precise meaning
        -: 9850:	     of a token, for further debugging info.  */
        -: 9851:#ifdef YYPRINT
        -: 9852:	  YYPRINT (err, yychar, yylval);
        -: 9853:#endif
        -: 9854:	  fprintf (err, ")\n");
        -: 9855:	}
        -: 9856:#endif
        -: 9857:    }
        -: 9858:
       95: 9859:  yyn += yychar1;
       95: 9860:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
        -: 9861:    goto yydefault;
        -: 9862:
       43: 9863:  yyn = yytable[yyn];
        -: 9864:
        -: 9865:  /* yyn is what to do for this token type in this state.
        -: 9866:     Negative => reduce, -yyn is rule number.
        -: 9867:     Positive => shift, yyn is new state.
        -: 9868:       New state is final state => don't bother to shift,
        -: 9869:       just return success.
        -: 9870:     0, or most negative number => error.  */
        -: 9871:
       43: 9872:  if (yyn < 0)
        -: 9873:    {
        2: 9874:      if (yyn == YYFLAG)
    #####: 9875:	goto yyerrlab;
        2: 9876:      yyn = -yyn;
        2: 9877:      goto yyreduce;
        -: 9878:    }
       41: 9879:  else if (yyn == 0)
    #####: 9880:    goto yyerrlab;
        -: 9881:
       41: 9882:  if (yyn == YYFINAL)
        1: 9883:    YYACCEPT;
        -: 9884:
        -: 9885:  /* Shift the lookahead token.  */
        -: 9886:
        -: 9887:#if YYDEBUG != 0
        -: 9888:  if (yydebug)
        -: 9889:    fprintf(err, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
        -: 9890:#endif
        -: 9891:
        -: 9892:  /* Discard the token being shifted unless it is eof.  */
       40: 9893:  if (yychar != YYEOF)
       39: 9894:    yychar = YYEMPTY;
        -: 9895:
       40: 9896:  *++yyvsp = yylval;
        -: 9897:#ifdef YYLSP_NEEDED
        -: 9898:  *++yylsp = yylloc;
        -: 9899:#endif
        -: 9900:
        -: 9901:  /* count tokens shifted since error; after three, turn off error status.  */
       40: 9902:  if (yyerrstatus) yyerrstatus--;
        -: 9903:
       40: 9904:  yystate = yyn;
       40: 9905:  goto yynewstate;
        -: 9906:
        -: 9907:/* Do the default action for the current state.  */
        -: 9908:yydefault:
        -: 9909:
       93: 9910:  yyn = yydefact[yystate];
       93: 9911:  if (yyn == 0)
    #####: 9912:    goto yyerrlab;
        -: 9913:
        -: 9914:/* Do a reduction.  yyn is the number of a rule to reduce with.  */
        -: 9915:yyreduce:
       95: 9916:  yylen = yyr2[yyn];
       95: 9917:  if (yylen > 0)
       78: 9918:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
        -: 9919:
        -: 9920:#if YYDEBUG != 0
        -: 9921:  if (yydebug)
        -: 9922:    {
        -: 9923:      int i;
        -: 9924:
        -: 9925:      fprintf (err, "Reducing via rule %d (line %d), ",
        -: 9926:	       yyn, yyrline[yyn]);
        -: 9927:
        -: 9928:      /* Print the symbols being reduced, and their result.  */
        -: 9929:      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        -: 9930:	fprintf (err, "%s ", yytname[yyrhs[i]]);
        -: 9931:      fprintf (err, " -> %s\n", yytname[yyr1[yyn]]);
        -: 9932:    }
        -: 9933:#endif
        -: 9934:
        -: 9935:
       95: 9936:  switch (yyn) {
        -: 9937:
        -: 9938:case 1:
        -: 9939:{ /* add default rule */
        -: 9940:			int def_rule;
        -: 9941:
        1: 9942:			pat = cclinit();
        1: 9943:			cclnegate( pat );
        -: 9944:
        1: 9945:			def_rule = mkstate( -pat );
        -: 9946:
        -: 9947:			/* Remember the number of the default rule so we
        -: 9948:			 * don't generate "can't match" warnings for it.
        -: 9949:			 */
        1: 9950:			default_rule = num_rules;
        -: 9951:
        1: 9952:			finish_rule( def_rule, false, 0, 0 );
        -: 9953:
        2: 9954:			for ( i = 1; i <= lastsc; ++i )
        1: 9955:				scset[i] = mkbranch( scset[i], def_rule );
        -: 9956:
        1: 9957:			if ( spprdflt )
    #####: 9958:				add_action(
        -: 9959:				"YY_FATAL_ERROR( \"flex scanner jammed\" )" );
        -: 9960:			else
        1: 9961:				add_action( "ECHO" );
        -: 9962:
        1: 9963:			add_action( ";\n\tYY_BREAK\n" );
        -: 9964:			;
        1: 9965:    break;}
        -: 9966:case 2:
        -: 9967:{ /* initialize for processing rules */
        -: 9968:
        -: 9969:			/* Create default DFA start condition. */
        1: 9970:			scinstal( "INITIAL", false );
        -: 9971:			;
        1: 9972:    break;}
        -: 9973:case 6:
    #####: 9974:{ synerr( "unknown error processing section 1" ); ;
    #####: 9975:    break;}
        -: 9976:case 7:
        -: 9977:{
        1: 9978:			check_options();
        1: 9979:			scon_stk = allocate_integer_array( lastsc + 1 );
        1: 9980:			scon_stk_ptr = 0;
        -: 9981:			;
        1: 9982:    break;}
        -: 9983:case 8:
    #####: 9984:{ xcluflg = false; ;
    #####: 9985:    break;}
        -: 9986:case 9:
    #####: 9987:{ xcluflg = true; ;
    #####: 9988:    break;}
        -: 9989:case 10:
    #####: 9990:{ scinstal( nmstr, xcluflg ); ;
    #####: 9991:    break;}
        -: 9992:case 11:
    #####: 9993:{ scinstal( nmstr, xcluflg ); ;
    #####: 9994:    break;}
        -: 9995:case 12:
    #####: 9996:{ synerr( "bad start condition list" ); ;
    #####: 9997:    break;}
        -: 9998:case 16:
        -: 9999:{
    #####:10000:			outfilename = copy_string( nmstr );
    #####:10001:			did_outfilename = 1;
        -:10002:			;
    #####:10003:    break;}
        -:10004:case 17:
    #####:10005:{ prefix = copy_string( nmstr ); ;
    #####:10006:    break;}
        -:10007:case 18:
    #####:10008:{ yyclass = copy_string( nmstr ); ;
    #####:10009:    break;}
        -:10010:case 19:
        6:10011:{ scon_stk_ptr = yyvsp[-3]; ;
        6:10012:    break;}
        -:10013:case 20:
    #####:10014:{ scon_stk_ptr = yyvsp[-3]; ;
    #####:10015:    break;}
        -:10016:case 22:
        -:10017:{
        -:10018:			/* Initialize for a parse of one rule. */
        7:10019:			trlcontxt = variable_trail_rule = varlength = false;
        7:10020:			trailcnt = headcnt = rulelen = 0;
        7:10021:			current_state_type = STATE_NORMAL;
        7:10022:			previous_continued_action = continued_action;
        7:10023:			in_rule = true;
        -:10024:
        7:10025:			new_rule();
        -:10026:			;
        7:10027:    break;}
        -:10028:case 23:
        -:10029:{
        1:10030:			pat = yyvsp[0];
        1:10031:			finish_rule( pat, variable_trail_rule,
        -:10032:				headcnt, trailcnt );
        -:10033:
        1:10034:			if ( scon_stk_ptr > 0 )
        -:10035:				{
    #####:10036:				for ( i = 1; i <= scon_stk_ptr; ++i )
    #####:10037:					scbol[scon_stk[i]] =
    #####:10038:						mkbranch( scbol[scon_stk[i]],
        -:10039:								pat );
        -:10040:				}
        -:10041:
        -:10042:			else
        -:10043:				{
        -:10044:				/* Add to all non-exclusive start conditions,
        -:10045:				 * including the default (0) start condition.
        -:10046:				 */
        -:10047:
        2:10048:				for ( i = 1; i <= lastsc; ++i )
        1:10049:					if ( ! scxclu[i] )
        1:10050:						scbol[i] = mkbranch( scbol[i],
        -:10051:									pat );
        -:10052:				}
        -:10053:
        1:10054:			if ( ! bol_needed )
        -:10055:				{
        1:10056:				bol_needed = true;
        -:10057:
        1:10058:				if ( performance_report > 1 )
    #####:10059:					pinpoint_message(
        -:10060:			"'^' operator results in sub-optimal performance" );
        -:10061:				}
        -:10062:			;
        1:10063:    break;}
        -:10064:case 24:
        -:10065:{
        5:10066:			pat = yyvsp[0];
        5:10067:			finish_rule( pat, variable_trail_rule,
        -:10068:				headcnt, trailcnt );
        -:10069:
        5:10070:			if ( scon_stk_ptr > 0 )
        -:10071:				{
    #####:10072:				for ( i = 1; i <= scon_stk_ptr; ++i )
    #####:10073:					scset[scon_stk[i]] =
    #####:10074:						mkbranch( scset[scon_stk[i]],
        -:10075:								pat );
        -:10076:				}
        -:10077:
        -:10078:			else
        -:10079:				{
       10:10080:				for ( i = 1; i <= lastsc; ++i )
        5:10081:					if ( ! scxclu[i] )
       10:10082:						scset[i] =
        5:10083:							mkbranch( scset[i],
        -:10084:								pat );
        -:10085:				}
        -:10086:			;
        5:10087:    break;}
        -:10088:case 25:
        -:10089:{
    #####:10090:			if ( scon_stk_ptr > 0 )
    #####:10091:				build_eof_action();
        -:10092:	
        -:10093:			else
        -:10094:				{
        -:10095:				/* This EOF applies to all start conditions
        -:10096:				 * which don't already have EOF actions.
        -:10097:				 */
    #####:10098:				for ( i = 1; i <= lastsc; ++i )
    #####:10099:					if ( ! sceof[i] )
    #####:10100:						scon_stk[++scon_stk_ptr] = i;
        -:10101:
    #####:10102:				if ( scon_stk_ptr == 0 )
    #####:10103:					warn(
        -:10104:			"all start conditions already have <<EOF>> rules" );
        -:10105:
        -:10106:				else
    #####:10107:					build_eof_action();
        -:10108:				}
        -:10109:			;
    #####:10110:    break;}
        -:10111:case 26:
    #####:10112:{ synerr( "unrecognized rule" ); ;
    #####:10113:    break;}
        -:10114:case 27:
    #####:10115:{ yyval = scon_stk_ptr; ;
    #####:10116:    break;}
        -:10117:case 28:
    #####:10118:{ yyval = yyvsp[-2]; ;
    #####:10119:    break;}
        -:10120:case 29:
        -:10121:{
    #####:10122:			yyval = scon_stk_ptr;
        -:10123:
    #####:10124:			for ( i = 1; i <= lastsc; ++i )
        -:10125:				{
        -:10126:				int j;
        -:10127:
    #####:10128:				for ( j = 1; j <= scon_stk_ptr; ++j )
    #####:10129:					if ( scon_stk[j] == i )
    #####:10130:						break;
        -:10131:
    #####:10132:				if ( j > scon_stk_ptr )
    #####:10133:					scon_stk[++scon_stk_ptr] = i;
        -:10134:				}
        -:10135:			;
    #####:10136:    break;}
        -:10137:case 30:
        6:10138:{ yyval = scon_stk_ptr; ;
        6:10139:    break;}
        -:10140:case 33:
    #####:10141:{ synerr( "bad start condition list" ); ;
    #####:10142:    break;}
        -:10143:case 34:
        -:10144:{
    #####:10145:			if ( (scnum = sclookup( nmstr )) == 0 )
    #####:10146:				format_pinpoint_message(
        -:10147:					"undeclared start condition %s",
        -:10148:					nmstr );
        -:10149:			else
        -:10150:				{
    #####:10151:				for ( i = 1; i <= scon_stk_ptr; ++i )
    #####:10152:					if ( scon_stk[i] == scnum )
        -:10153:						{
    #####:10154:						format_warn(
        -:10155:							"<%s> specified twice",
    #####:10156:							scname[scnum] );
    #####:10157:						break;
        -:10158:						}
        -:10159:
    #####:10160:				if ( i > scon_stk_ptr )
    #####:10161:					scon_stk[++scon_stk_ptr] = scnum;
        -:10162:				}
        -:10163:			;
    #####:10164:    break;}
        -:10165:case 35:
        -:10166:{
        1:10167:			if ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )
        -:10168:				/* Provide final transition \now/ so it
        -:10169:				 * will be marked as a trailing context
        -:10170:				 * state.
        -:10171:				 */
        1:10172:				yyvsp[0] = link_machines( yyvsp[0],
        -:10173:						mkstate( SYM_EPSILON ) );
        -:10174:
        1:10175:			mark_beginning_as_normal( yyvsp[0] );
        1:10176:			current_state_type = STATE_NORMAL;
        -:10177:
        1:10178:			if ( previous_continued_action )
        -:10179:				{
        -:10180:				/* We need to treat this as variable trailing
        -:10181:				 * context so that the backup does not happen
        -:10182:				 * in the action but before the action switch
        -:10183:				 * statement.  If the backup happens in the
        -:10184:				 * action, then the rules "falling into" this
        -:10185:				 * one's action will *also* do the backup,
        -:10186:				 * erroneously.
        -:10187:				 */
    #####:10188:				if ( ! varlength || headcnt != 0 )
    #####:10189:					warn(
        -:10190:		"trailing context made variable due to preceding '|' action" );
        -:10191:
        -:10192:				/* Mark as variable. */
    #####:10193:				varlength = true;
    #####:10194:				headcnt = 0;
        -:10195:				}
        -:10196:
        1:10197:			if ( lex_compat || (varlength && headcnt == 0) )
        -:10198:				{ /* variable trailing context rule */
        -:10199:				/* Mark the first part of the rule as the
        -:10200:				 * accepting "head" part of a trailing
        -:10201:				 * context rule.
        -:10202:				 *
        -:10203:				 * By the way, we didn't do this at the
        -:10204:				 * beginning of this production because back
        -:10205:				 * then current_state_type was set up for a
        -:10206:				 * trail rule, and add_accept() can create
        -:10207:				 * a new state ...
        -:10208:				 */
    #####:10209:				add_accept( yyvsp[-1],
        -:10210:					num_rules | YY_TRAILING_HEAD_MASK );
    #####:10211:				variable_trail_rule = true;
        -:10212:				}
        -:10213:			
        -:10214:			else
        1:10215:				trailcnt = rulelen;
        -:10216:
        1:10217:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
        -:10218:			;
        1:10219:    break;}
        -:10220:case 36:
    #####:10221:{ synerr( "trailing context used twice" ); ;
    #####:10222:    break;}
        -:10223:case 37:
        -:10224:{
        1:10225:			headcnt = 0;
        1:10226:			trailcnt = 1;
        1:10227:			rulelen = 1;
        1:10228:			varlength = false;
        -:10229:
        1:10230:			current_state_type = STATE_TRAILING_CONTEXT;
        -:10231:
        1:10232:			if ( trlcontxt )
        -:10233:				{
    #####:10234:				synerr( "trailing context used twice" );
    #####:10235:				yyval = mkstate( SYM_EPSILON );
        -:10236:				}
        -:10237:
        1:10238:			else if ( previous_continued_action )
        -:10239:				{
        -:10240:				/* See the comment in the rule for "re2 re"
        -:10241:				 * above.
        -:10242:				 */
    #####:10243:				warn(
        -:10244:		"trailing context made variable due to preceding '|' action" );
        -:10245:
    #####:10246:				varlength = true;
        -:10247:				}
        -:10248:
        1:10249:			if ( lex_compat || varlength )
        -:10250:				{
        -:10251:				/* Again, see the comment in the rule for
        -:10252:				 * "re2 re" above.
        -:10253:				 */
    #####:10254:				add_accept( yyvsp[-1],
        -:10255:					num_rules | YY_TRAILING_HEAD_MASK );
    #####:10256:				variable_trail_rule = true;
        -:10257:				}
        -:10258:
        1:10259:			trlcontxt = true;
        -:10260:
        1:10261:			eps = mkstate( SYM_EPSILON );
        1:10262:			yyval = link_machines( yyvsp[-1],
        -:10263:				link_machines( eps, mkstate( '\n' ) ) );
        -:10264:			;
        1:10265:    break;}
        -:10266:case 38:
        -:10267:{
        4:10268:			yyval = yyvsp[0];
        -:10269:
        4:10270:			if ( trlcontxt )
        -:10271:				{
    #####:10272:				if ( lex_compat || (varlength && headcnt == 0) )
        -:10273:					/* Both head and trail are
        -:10274:					 * variable-length.
        -:10275:					 */
    #####:10276:					variable_trail_rule = true;
        -:10277:				else
    #####:10278:					trailcnt = rulelen;
        -:10279:				}
        -:10280:			;
        4:10281:    break;}
        -:10282:case 39:
        -:10283:{
        1:10284:			varlength = true;
        1:10285:			yyval = mkor( yyvsp[-2], yyvsp[0] );
        -:10286:			;
        1:10287:    break;}
        -:10288:case 40:
        9:10289:{ yyval = yyvsp[0]; ;
        9:10290:    break;}
        -:10291:case 41:
        -:10292:{
        -:10293:			/* This rule is written separately so the
        -:10294:			 * reduction will occur before the trailing
        -:10295:			 * series is parsed.
        -:10296:			 */
        -:10297:
        1:10298:			if ( trlcontxt )
    #####:10299:				synerr( "trailing context used twice" );
        -:10300:			else
        1:10301:				trlcontxt = true;
        -:10302:
        -:10303:#ifndef F_B31
        1:10304:			if ( varlength )
        -:10305:#else
        -:10306:			if  (!  varlength )
        -:10307:#endif
        -:10308:				/* We hope the trailing context is
        -:10309:				 * fixed-length.
        -:10310:				 */
    #####:10311:				varlength = false;
        -:10312:			else
        1:10313:				headcnt = rulelen;
        -:10314:
        1:10315:			rulelen = 0;
        -:10316:
        1:10317:			current_state_type = STATE_TRAILING_CONTEXT;
        1:10318:			yyval = yyvsp[-1];
        -:10319:			;
        1:10320:    break;}
        -:10321:case 42:
        -:10322:{
        -:10323:			/* This is where concatenation of adjacent patterns
        -:10324:			 * gets done.
        -:10325:			 */
       11:10326:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
        -:10327:			;
       11:10328:    break;}
        -:10329:case 43:
       10:10330:{ yyval = yyvsp[0]; ;
       10:10331:    break;}
        -:10332:case 44:
        -:10333:{
        1:10334:			varlength = true;
        -:10335:
        1:10336:			yyval = mkclos( yyvsp[-1] );
        -:10337:			;
        1:10338:    break;}
        -:10339:case 45:
        -:10340:{
    #####:10341:			varlength = true;
    #####:10342:			yyval = mkposcl( yyvsp[-1] );
        -:10343:			;
    #####:10344:    break;}
        -:10345:case 46:
        -:10346:{
    #####:10347:			varlength = true;
    #####:10348:			yyval = mkopt( yyvsp[-1] );
        -:10349:			;
    #####:10350:    break;}
        -:10351:case 47:
        -:10352:{
    #####:10353:			varlength = true;
        -:10354:
    #####:10355:			if ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )
        -:10356:				{
    #####:10357:				synerr( "bad iteration values" );
    #####:10358:				yyval = yyvsp[-5];
        -:10359:				}
        -:10360:			else
        -:10361:				{
    #####:10362:				if ( yyvsp[-3] == 0 )
        -:10363:					{
    #####:10364:					if ( yyvsp[-1] <= 0 )
        -:10365:						{
    #####:10366:						synerr(
        -:10367:						"bad iteration values" );
    #####:10368:						yyval = yyvsp[-5];
        -:10369:						}
        -:10370:					else
    #####:10371:						yyval = mkopt(
    #####:10372:							mkrep( yyvsp[-5], 1, yyvsp[-1] ) );
        -:10373:					}
        -:10374:				else
    #####:10375:					yyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );
        -:10376:				}
        -:10377:			;
    #####:10378:    break;}
        -:10379:case 48:
        -:10380:{
    #####:10381:			varlength = true;
        -:10382:
    #####:10383:			if ( yyvsp[-2] <= 0 )
        -:10384:				{
    #####:10385:				synerr( "iteration value must be positive" );
    #####:10386:				yyval = yyvsp[-4];
        -:10387:				}
        -:10388:
        -:10389:			else
    #####:10390:				yyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );
        -:10391:			;
    #####:10392:    break;}
        -:10393:case 49:
        -:10394:{
        -:10395:			/* The singleton could be something like "(foo)",
        -:10396:			 * in which case we have no idea what its length
        -:10397:			 * is, so we punt here.
        -:10398:			 */
    #####:10399:			varlength = true;
        -:10400:
    #####:10401:			if ( yyvsp[-1] <= 0 )
        -:10402:				{
    #####:10403:				synerr( "iteration value must be positive" );
    #####:10404:				yyval = yyvsp[-3];
        -:10405:				}
        -:10406:
        -:10407:			else
    #####:10408:				yyval = link_machines( yyvsp[-3],
    #####:10409:						copysingl( yyvsp[-3], yyvsp[-1] - 1 ) );
        -:10410:			;
    #####:10411:    break;}
        -:10412:case 50:
        -:10413:{
    #####:10414:			if ( ! madeany )
        -:10415:				{
        -:10416:				/* Create the '.' character class. */
    #####:10417:				anyccl = cclinit();
    #####:10418:				ccladd( anyccl, '\n' );
        -:10419:#ifndef F_B37
    #####:10420:				cclnegate( anyccl );
        -:10421:#else
        -:10422:				cclnegate (!  anyccl );
        -:10423:#endif
        -:10424:
    #####:10425:				if ( useecs )
    #####:10426:					mkeccl( ccltbl + cclmap[anyccl],
    #####:10427:						ccllen[anyccl], nextecm,
        -:10428:						ecgroup, csize, csize );
        -:10429:
    #####:10430:				madeany = true;
        -:10431:				}
        -:10432:
    #####:10433:			++rulelen;
        -:10434:
        -:10435:#ifndef F_B26
    #####:10436:			yyval = mkstate( -anyccl );
        -:10437:#else
        -:10438:			yyval = mkstate (!  -anyccl );
        -:10439:#endif
        -:10440:			;
    #####:10441:    break;}
        -:10442:case 51:
        -:10443:{
        1:10444:			if ( ! cclsorted )
        -:10445:				/* Sort characters for fast searching.  We
        -:10446:				 * use a shell sort since this list could
        -:10447:				 * be large.
        -:10448:				 */
    #####:10449:				cshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );
        -:10450:
        1:10451:			if ( useecs )
        1:10452:				mkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],
        -:10453:					nextecm, ecgroup, csize, csize );
        -:10454:
        1:10455:			++rulelen;
        -:10456:
        1:10457:			yyval = mkstate( -yyvsp[0] );
        -:10458:			;
        1:10459:    break;}
        -:10460:case 52:
        -:10461:{
    #####:10462:			++rulelen;
        -:10463:
    #####:10464:			yyval = mkstate( -yyvsp[0] );
        -:10465:			;
    #####:10466:    break;}
        -:10467:case 53:
    #####:10468:{ yyval = yyvsp[-1]; ;
    #####:10469:    break;}
        -:10470:case 54:
        2:10471:{ yyval = yyvsp[-1]; ;
        2:10472:    break;}
        -:10473:case 55:
        -:10474:{
       18:10475:			++rulelen;
        -:10476:
       18:10477:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####:10478:				yyvsp[0] = clower( yyvsp[0] );
        -:10479:
       18:10480:			yyval = mkstate( yyvsp[0] );
        -:10481:			;
       18:10482:    break;}
        -:10483:case 56:
        1:10484:{ yyval = yyvsp[-1]; ;
        1:10485:    break;}
        -:10486:case 57:
        -:10487:{
        -:10488:#ifndef F_A04
    #####:10489:			cclnegate( yyvsp[-1] );
        -:10490:#else
        -:10491:			cclnegate( yyvsp[-1] *0);
        -:10492:#endif
    #####:10493:			yyval = yyvsp[-1];
        -:10494:			;
    #####:10495:    break;}
        -:10496:case 58:
        -:10497:{
    #####:10498:			if ( caseins )
        -:10499:				{
    #####:10500:				if ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )
    #####:10501:					yyvsp[-2] = clower( yyvsp[-2] );
    #####:10502:				if ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####:10503:					yyvsp[0] = clower( yyvsp[0] );
        -:10504:				}
        -:10505:
    #####:10506:			if ( yyvsp[-2] > yyvsp[0] )
    #####:10507:				synerr( "negative range in character class" );
        -:10508:
        -:10509:			else
        -:10510:				{
    #####:10511:				for ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )
    #####:10512:					ccladd( yyvsp[-3], i );
        -:10513:
        -:10514:				/* Keep track if this ccl is staying in
        -:10515:				 * alphabetical order.
        -:10516:				 */
    #####:10517:				cclsorted = cclsorted && (yyvsp[-2] > lastchar);
    #####:10518:				lastchar = yyvsp[0];
        -:10519:				}
        -:10520:
    #####:10521:			yyval = yyvsp[-3];
        -:10522:			;
    #####:10523:    break;}
        -:10524:case 59:
        -:10525:{
        3:10526:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####:10527:				yyvsp[0] = clower( yyvsp[0] );
        -:10528:
        3:10529:			ccladd( yyvsp[-1], yyvsp[0] );
        3:10530:			cclsorted = cclsorted && (yyvsp[0] > lastchar);
        3:10531:			lastchar = yyvsp[0];
        3:10532:			yyval = yyvsp[-1];
        -:10533:			;
        3:10534:    break;}
        -:10535:case 60:
        -:10536:{
        -:10537:			/* Too hard to properly maintain cclsorted. */
    #####:10538:			cclsorted = false;
    #####:10539:			yyval = yyvsp[-1];
        -:10540:			;
    #####:10541:    break;}
        -:10542:case 61:
        -:10543:{
        1:10544:			cclsorted = true;
        1:10545:			lastchar = 0;
        1:10546:			currccl = yyval = cclinit();
        -:10547:			;
        1:10548:    break;}
        -:10549:case 62:
    #####:10550:{ CCL_EXPR(isalnum) ;
    #####:10551:    break;}
        -:10552:case 63:
    #####:10553:{ CCL_EXPR(isalpha) ;
    #####:10554:    break;}
        -:10555:case 64:
    #####:10556:{ CCL_EXPR(IS_BLANK) ;
    #####:10557:    break;}
        -:10558:case 65:
    #####:10559:{ CCL_EXPR(iscntrl) ;
    #####:10560:    break;}
        -:10561:case 66:
    #####:10562:{ CCL_EXPR(isdigit) ;
    #####:10563:    break;}
        -:10564:case 67:
    #####:10565:{ CCL_EXPR(isgraph) ;
    #####:10566:    break;}
        -:10567:case 68:
    #####:10568:{ CCL_EXPR(islower) ;
    #####:10569:    break;}
        -:10570:case 69:
    #####:10571:{ CCL_EXPR(isprint) ;
    #####:10572:    break;}
        -:10573:case 70:
    #####:10574:{ CCL_EXPR(ispunct) ;
    #####:10575:    break;}
        -:10576:case 71:
    #####:10577:{ CCL_EXPR(isspace) ;
    #####:10578:    break;}
        -:10579:case 72:
        -:10580:{
    #####:10581:				if ( caseins )
    #####:10582:					CCL_EXPR(islower)
        -:10583:				else
    #####:10584:					CCL_EXPR(isupper)
        -:10585:				;
    #####:10586:    break;}
        -:10587:case 73:
    #####:10588:{ CCL_EXPR(isxdigit) ;
    #####:10589:    break;}
        -:10590:case 74:
        -:10591:{
    #####:10592:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####:10593:				yyvsp[0] = clower( yyvsp[0] );
        -:10594:
    #####:10595:			++rulelen;
        -:10596:
    #####:10597:			yyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );
        -:10598:			;
    #####:10599:    break;}
        -:10600:case 75:
    #####:10601:{ yyval = mkstate( SYM_EPSILON ); ;
    #####:10602:    break;}
        -:10603:}
        -:10604:   /* the action file gets copied in in place of this dollarsign */
       95:10605:  yyvsp -= yylen;
       95:10606:  yyssp -= yylen;
        -:10607:#ifdef YYLSP_NEEDED
        -:10608:  yylsp -= yylen;
        -:10609:#endif
        -:10610:
        -:10611:#if YYDEBUG != 0
        -:10612:  if (yydebug)
        -:10613:    {
        -:10614:      short *ssp1 = yyss - 1;
        -:10615:      fprintf (err, "state stack now");
        -:10616:      while (ssp1 != yyssp)
        -:10617:	fprintf (err, " %d", *++ssp1);
        -:10618:      fprintf (err, "\n");
        -:10619:    }
        -:10620:#endif
        -:10621:
       95:10622:  *++yyvsp = yyval;
        -:10623:
        -:10624:#ifdef YYLSP_NEEDED
        -:10625:  yylsp++;
        -:10626:  if (yylen == 0)
        -:10627:    {
        -:10628:      yylsp->first_line = yylloc.first_line;
        -:10629:      yylsp->first_column = yylloc.first_column;
        -:10630:      yylsp->last_line = (yylsp-1)->last_line;
        -:10631:      yylsp->last_column = (yylsp-1)->last_column;
        -:10632:      yylsp->text = 0;
        -:10633:    }
        -:10634:  else
        -:10635:    {
        -:10636:      yylsp->last_line = (yylsp+yylen-1)->last_line;
        -:10637:      yylsp->last_column = (yylsp+yylen-1)->last_column;
        -:10638:    }
        -:10639:#endif
        -:10640:
        -:10641:  /* Now "shift" the result of the reduction.
        -:10642:     Determine what state that goes to,
        -:10643:     based on the state we popped back to
        -:10644:     and the rule number reduced by.  */
        -:10645:
       95:10646:  yyn = yyr1[yyn];
        -:10647:
       95:10648:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
       95:10649:  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
       24:10650:    yystate = yytable[yystate];
        -:10651:  else
       71:10652:    yystate = yydefgoto[yyn - YYNTBASE];
        -:10653:
       95:10654:  goto yynewstate;
        -:10655:
        -:10656:yyerrlab:   /* here on detecting error */
        -:10657:
    #####:10658:  if (! yyerrstatus)
        -:10659:    /* If not already recovering from an error, report this error.  */
        -:10660:    {
    #####:10661:      ++yynerrs;
        -:10662:
        -:10663:#ifdef YYERROR_VERBOSE
        -:10664:      yyn = yypact[yystate];
        -:10665:
        -:10666:      if (yyn > YYFLAG && yyn < YYLAST)
        -:10667:	{
        -:10668:	  int size = 0;
        -:10669:	  char *msg;
        -:10670:	  int x, count;
        -:10671:
        -:10672:	  count = 0;
        -:10673:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
        -:10674:	  for (x = (yyn < 0 ? -yyn : 0);
        -:10675:	       x < (sizeof(yytname) / sizeof(char *)); x++)
        -:10676:	    if (yycheck[x + yyn] == x)
        -:10677:	      size += strlen(yytname[x]) + 15, count++;
        -:10678:	  msg = (char *) malloc(size + 15);
        -:10679:	  if (msg != 0)
        -:10680:	    {
        -:10681:	      strcpy(msg, "parse error");
        -:10682:
        -:10683:	      if (count < 5)
        -:10684:		{
        -:10685:		  count = 0;
        -:10686:		  for (x = (yyn < 0 ? -yyn : 0);
        -:10687:		       x < (sizeof(yytname) / sizeof(char *)); x++)
        -:10688:		    if (yycheck[x + yyn] == x)
        -:10689:		      {
        -:10690:			strcat(msg, count == 0 ? ", expecting `" : " or `");
        -:10691:			strcat(msg, yytname[x]);
        -:10692:			strcat(msg, "'");
        -:10693:			count++;
        -:10694:		      }
        -:10695:		}
        -:10696:	      yyerror(msg);
        -:10697:	      free(msg);
        -:10698:	    }
        -:10699:	  else
        -:10700:	    yyerror ("parse error; also virtual memory exceeded");
        -:10701:	}
        -:10702:      else
        -:10703:#endif /* YYERROR_VERBOSE */
    #####:10704:	yyerror("parse error");
        -:10705:    }
        -:10706:
    #####:10707:  goto yyerrlab1;
        -:10708:yyerrlab1:   /* here on error raised explicitly by an action */
        -:10709:
    #####:10710:  if (yyerrstatus == 3)
        -:10711:    {
        -:10712:      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
        -:10713:
        -:10714:      /* return failure if at end of input */
    #####:10715:      if (yychar == YYEOF)
    #####:10716:	YYABORT;
        -:10717:
        -:10718:#if YYDEBUG != 0
        -:10719:      if (yydebug)
        -:10720:	fprintf(err, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
        -:10721:#endif
        -:10722:
    #####:10723:      yychar = YYEMPTY;
        -:10724:    }
        -:10725:
        -:10726:  /* Else will try to reuse lookahead token
        -:10727:     after shifting the error token.  */
        -:10728:
    #####:10729:  yyerrstatus = 3;		/* Each real token shifted decrements this */
        -:10730:
    #####:10731:  goto yyerrhandle;
        -:10732:
        -:10733:yyerrdefault:  /* current state does not do anything special for the error token. */
        -:10734:
        -:10735:#if 0
        -:10736:  /* This is wrong; only states that explicitly want error tokens
        -:10737:     should shift them.  */
        -:10738:  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
        -:10739:  if (yyn) goto yydefault;
        -:10740:#endif
        -:10741:
        -:10742:yyerrpop:   /* pop the current state because it cannot handle the error token */
        -:10743:
    #####:10744:  if (yyssp == yyss) YYABORT;
    #####:10745:  yyvsp--;
    #####:10746:  yystate = *--yyssp;
        -:10747:#ifdef YYLSP_NEEDED
        -:10748:  yylsp--;
        -:10749:#endif
        -:10750:
        -:10751:#if YYDEBUG != 0
        -:10752:  if (yydebug)
        -:10753:    {
        -:10754:      short *ssp1 = yyss - 1;
        -:10755:      fprintf (err, "Error: state stack now");
        -:10756:      while (ssp1 != yyssp)
        -:10757:	fprintf (err, " %d", *++ssp1);
        -:10758:      fprintf (err, "\n");
        -:10759:    }
        -:10760:#endif
        -:10761:
        -:10762:yyerrhandle:
        -:10763:
    #####:10764:  yyn = yypact[yystate];
    #####:10765:  if (yyn == YYFLAG)
    #####:10766:    goto yyerrdefault;
        -:10767:
    #####:10768:  yyn += YYTERROR;
    #####:10769:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
        -:10770:    goto yyerrdefault;
        -:10771:
    #####:10772:  yyn = yytable[yyn];
    #####:10773:  if (yyn < 0)
        -:10774:    {
    #####:10775:      if (yyn == YYFLAG)
    #####:10776:	goto yyerrpop;
    #####:10777:      yyn = -yyn;
    #####:10778:      goto yyreduce;
        -:10779:    }
    #####:10780:  else if (yyn == 0)
    #####:10781:    goto yyerrpop;
        -:10782:
    #####:10783:  if (yyn == YYFINAL)
    #####:10784:    YYACCEPT;
        -:10785:
        -:10786:#if YYDEBUG != 0
        -:10787:  if (yydebug)
        -:10788:    fprintf(err, "Shifting error token, ");
        -:10789:#endif
        -:10790:
    #####:10791:  *++yyvsp = yylval;
        -:10792:#ifdef YYLSP_NEEDED
        -:10793:  *++yylsp = yylloc;
        -:10794:#endif
        -:10795:
    #####:10796:  yystate = yyn;
    #####:10797:  goto yynewstate;
        -:10798:
        -:10799: yyacceptlab:
        -:10800:  /* YYACCEPT comes here.  */
        1:10801:  if (yyfree_stacks)
        -:10802:    {
    #####:10803:      free (yyss);
    #####:10804:      free (yyvs);
        -:10805:#ifdef YYLSP_NEEDED
        -:10806:      free (yyls);
        -:10807:#endif
        -:10808:    }
        1:10809:  return 0;
        -:10810:
        -:10811: yyabortlab:
        -:10812:  /* YYABORT comes here.  */
    #####:10813:  if (yyfree_stacks)
        -:10814:    {
    #####:10815:      free (yyss);
    #####:10816:      free (yyvs);
        -:10817:#ifdef YYLSP_NEEDED
        -:10818:      free (yyls);
        -:10819:#endif
        -:10820:    }
    #####:10821:  return 1;
        -:10822:}
        -:10823:
        -:10824:
        -:10825:
        -:10826:/* build_eof_action - build the "<<EOF>>" action for the active start
        -:10827: *                    conditions
        -:10828: */
        -:10829:
    #####:10830:void build_eof_action()
        -:10831:	{
        -:10832:	register int i;
        -:10833:	char action_text[MAXLINE];
        -:10834:
    #####:10835:	for ( i = 1; i <= scon_stk_ptr; ++i )
        -:10836:		{
    #####:10837:		if ( sceof[scon_stk[i]] )
    #####:10838:			format_pinpoint_message(
        -:10839:				"multiple <<EOF>> rules for start condition %s",
    #####:10840:				scname[scon_stk[i]] );
        -:10841:
        -:10842:		else
        -:10843:			{
    #####:10844:			sceof[scon_stk[i]] = true;
    #####:10845:			sprintf( action_text, "case YY_STATE_EOF(%s):\n",
    #####:10846:				scname[scon_stk[i]] );
    #####:10847:			add_action( action_text );
        -:10848:			}
        -:10849:		}
        -:10850:
    #####:10851:	line_directive_out( (FILE *) 0, 1 );
        -:10852:
        -:10853:	/* This isn't a normal rule after all - don't count it as
        -:10854:	 * such, so we don't have any holes in the rule numbering
        -:10855:	 * (which make generating "rule can never match" warnings
        -:10856:	 * more difficult.
        -:10857:	 */
    #####:10858:	--num_rules;
    #####:10859:	++num_eof_rules;
    #####:10860:	}
        -:10861:
        -:10862:
        -:10863:/* format_synerr - write out formatted syntax error */
        -:10864:
    #####:10865:void format_synerr( msg, arg )
        -:10866:char msg[], arg[];
        -:10867:	{
        -:10868:	char errmsg[MAXLINE];
        -:10869:
    #####:10870:	(void) sprintf( errmsg, msg, arg );
    #####:10871:	synerr( errmsg );
    #####:10872:	}
        -:10873:
        -:10874:
        -:10875:/* synerr - report a syntax error */
        -:10876:
    #####:10877:void synerr( str )
        -:10878:char str[];
        -:10879:	{
    #####:10880:	syntaxerror = true;
    #####:10881:	pinpoint_message( str );
    #####:10882:	}
        -:10883:
        -:10884:
        -:10885:/* format_warn - write out formatted warning */
        -:10886:
    #####:10887:void format_warn( msg, arg )
        -:10888:char msg[], arg[];
        -:10889:	{
        -:10890:	char warn_msg[MAXLINE];
        -:10891:
    #####:10892:	(void) sprintf( warn_msg, msg, arg );
    #####:10893:	warn( warn_msg );
    #####:10894:	}
        -:10895:
        -:10896:
        -:10897:/* warn - report a warning, unless -w was given */
        -:10898:
    #####:10899:void warn( str )
        -:10900:char str[];
        -:10901:	{
    #####:10902:	line_warning( str, linenum );
    #####:10903:	}
        -:10904:
        -:10905:/* format_pinpoint_message - write out a message formatted with one string,
        -:10906: *			     pinpointing its location
        -:10907: */
        -:10908:
    #####:10909:void format_pinpoint_message( msg, arg )
        -:10910:char msg[], arg[];
        -:10911:	{
        -:10912:	char errmsg[MAXLINE];
        -:10913:
    #####:10914:	(void) sprintf( errmsg, msg, arg );
    #####:10915:	pinpoint_message( errmsg );
    #####:10916:	}
        -:10917:
        -:10918:
        -:10919:/* pinpoint_message - write out a message, pinpointing its location */
        -:10920:
    #####:10921:void pinpoint_message( str )
        -:10922:char str[];
        -:10923:	{
    #####:10924:	line_pinpoint( str, linenum );
    #####:10925:	}
        -:10926:
        -:10927:
        -:10928:/* line_warning - report a warning at a given line, unless -w was given */
        -:10929:
    #####:10930:void line_warning( str, line )
        -:10931:char str[];
        -:10932:int line;
        -:10933:	{
        -:10934:	char warning[MAXLINE];
        -:10935:
    #####:10936:	if ( ! nowarn )
        -:10937:		{
    #####:10938:		sprintf( warning, "warning, %s", str );
    #####:10939:		line_pinpoint( warning, line );
        -:10940:		}
    #####:10941:	}
        -:10942:
        -:10943:
        -:10944:/* line_pinpoint - write out a message, pinpointing it at the given line */
        -:10945:
    #####:10946:void line_pinpoint( str, line )
        -:10947:char str[];
        -:10948:int line;
        -:10949:	{
    #####:10950:	fprintf( err, "\"%s\", line %d: %s\n", infilename, line, str );
    #####:10951:	}
        -:10952:
        -:10953:
        -:10954:/* yyerror - eat up an error message from the parser;
        -:10955: *	     currently, messages are ignore
        -:10956: */
        -:10957:
    #####:10958:void yyerror( msg )
        -:10959:char msg[];
        -:10960:	{
    #####:10961:	}
        -:10962:/* A lexical scanner generated by flex */
        -:10963:
        -:10964:/* Scanner skeleton version:
        -:10965: * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $
        -:10966: */
        -:10967:
        -:10968:#define FLEX_SCANNER
        -:10969:#define YY_FLEX_MAJOR_VERSION 2
        -:10970:#define YY_FLEX_MINOR_VERSION 5
        -:10971:
        -:10972:#include <stdio.h>
        -:10973:
        -:10974:
        -:10975:/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
        -:10976:#ifdef c_plusplus
        -:10977:#ifndef __cplusplus
        -:10978:#define __cplusplus
        -:10979:#endif
        -:10980:#endif
        -:10981:
        -:10982:
        -:10983:#ifdef __cplusplus
        -:10984:
        -:10985:#include <stdlib.h>
        -:10986:#include <unistd.h>
        -:10987:
        -:10988:/* Use prototypes in function declarations. */
        -:10989:#define YY_USE_PROTOS
        -:10990:
        -:10991:/* The "const" storage-class-modifier is valid. */
        -:10992:#define YY_USE_CONST
        -:10993:
        -:10994:#else	/* ! __cplusplus */
        -:10995:
        -:10996:#if __STDC__
        -:10997:
        -:10998:#define YY_USE_PROTOS
        -:10999:#define YY_USE_CONST
        -:11000:
        -:11001:#endif	/* __STDC__ */
        -:11002:#endif	/* ! __cplusplus */
        -:11003:
        -:11004:#ifdef __TURBOC__
        -:11005: #pragma warn -rch
        -:11006: #pragma warn -use
        -:11007:#include <io.h>
        -:11008:#include <stdlib.h>
        -:11009:#define YY_USE_CONST
        -:11010:#define YY_USE_PROTOS
        -:11011:#endif
        -:11012:
        -:11013:#ifdef YY_USE_CONST
        -:11014:#define yyconst const
        -:11015:#else
        -:11016:#define yyconst
        -:11017:#endif
        -:11018:
        -:11019:
        -:11020:#ifdef YY_USE_PROTOS
        -:11021:#define YY_PROTO(proto) proto
        -:11022:#else
        -:11023:#define YY_PROTO(proto) ()
        -:11024:#endif
        -:11025:
        -:11026:/* Returned upon end-of-file. */
        -:11027:#define YY_NULL 0
        -:11028:
        -:11029:/* Promotes a possibly negative, possibly signed char to an unsigned
        -:11030: * integer for use as an array index.  If the signed char is negative,
        -:11031: * we want to instead treat it as an 8-bit unsigned char, hence the
        -:11032: * double cast.
        -:11033: */
        -:11034:#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
        -:11035:
        -:11036:/* Enter a start condition.  This macro really ought to take a parameter,
        -:11037: * but we do it the disgusting crufty way forced on us by the ()-less
        -:11038: * definition of BEGIN.
        -:11039: */
        -:11040:#define BEGIN yy_start = 1 + 2 *
        -:11041:
        -:11042:/* Translate the current start state into a value that can be later handed
        -:11043: * to BEGIN to return to the state.  The YYSTATE alias is for lex
        -:11044: * compatibility.
        -:11045: */
        -:11046:#define YY_START ((yy_start - 1) / 2)
        -:11047:#define YYSTATE YY_START
        -:11048:
        -:11049:/* Action number for EOF rule of a given start state. */
        -:11050:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -:11051:
        -:11052:/* Special action meaning "start processing a new file". */
        -:11053:#define YY_NEW_FILE yyrestart( yyin )
        -:11054:
        -:11055:#define YY_END_OF_BUFFER_CHAR 0
        -:11056:
        -:11057:/* Size of default input buffer. */
        -:11058:#define YY_BUF_SIZE 16384
        -:11059:
        -:11060:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -:11061:
        -:11062:extern int yyleng;
        -:11063:extern FILE *yyin, *yyout;
        -:11064:
        -:11065:#define EOB_ACT_CONTINUE_SCAN 0
        -:11066:#define EOB_ACT_END_OF_FILE 1
        -:11067:#define EOB_ACT_LAST_MATCH 2
        -:11068:
        -:11069:/* The funky do-while in the following #define is used to turn the definition
        -:11070: * int a single C statement (which needs a semi-colon terminator).  This
        -:11071: * avoids problems with code like:
        -:11072: *
        -:11073: * 	if ( condition_holds )
        -:11074: *		yyless( 5 );
        -:11075: *	else
        -:11076: *		do_something_else();
        -:11077: *
        -:11078: * Prior to using the do-while the compiler would get upset at the
        -:11079: * "else" because it interpreted the "if" statement as being all
        -:11080: * done when it reached the ';' after the yyless() call.
        -:11081: */
        -:11082:
        -:11083:/* Return all but the first 'n' matched characters back to the input stream. */
        -:11084:
        -:11085:#define yyless(n) \
        -:11086:	do \
        -:11087:		{ \
        -:11088:		/* Undo effects of setting up yytext. */ \
        -:11089:		*yy_cp = yy_hold_char; \
        -:11090:		YY_RESTORE_YY_MORE_OFFSET \
        -:11091:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        -:11092:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -:11093:		} \
        -:11094:	while ( 0 )
        -:11095:
        -:11096:#define unput(c) yyunput( c, yytext_ptr )
        -:11097:
        -:11098:/* The following is because we cannot portably get our hands on size_t
        -:11099: * (without autoconf's help, which isn't available because we want
        -:11100: * flex-generated scanners to compile on their own).
        -:11101: */
        -:11102:typedef unsigned int yy_size_t;
        -:11103:
        -:11104:
        -:11105:struct yy_buffer_state
        -:11106:	{
        -:11107:	FILE *yy_input_file;
        -:11108:
        -:11109:	char *yy_ch_buf;		/* input buffer */
        -:11110:	char *yy_buf_pos;		/* current position in input buffer */
        -:11111:
        -:11112:	/* Size of input buffer in bytes, not including room for EOB
        -:11113:	 * characters.
        -:11114:	 */
        -:11115:	yy_size_t yy_buf_size;
        -:11116:
        -:11117:	/* Number of characters read into yy_ch_buf, not including EOB
        -:11118:	 * characters.
        -:11119:	 */
        -:11120:	int yy_n_chars;
        -:11121:
        -:11122:	/* Whether we "own" the buffer - i.e., we know we created it,
        -:11123:	 * and can realloc() it to grow it, and should free() it to
        -:11124:	 * delete it.
        -:11125:	 */
        -:11126:	int yy_is_our_buffer;
        -:11127:
        -:11128:	/* Whether this is an "interactive" input source; if so, and
        -:11129:	 * if we're using stdio for input, then we want to use getc()
        -:11130:	 * instead of fread(), to make sure we stop fetching input after
        -:11131:	 * each newline.
        -:11132:	 */
        -:11133:	int yy_is_interactive;
        -:11134:
        -:11135:	/* Whether we're considered to be at the beginning of a line.
        -:11136:	 * If so, '^' rules will be active on the next match, otherwise
        -:11137:	 * not.
        -:11138:	 */
        -:11139:	int yy_at_bol;
        -:11140:
        -:11141:	/* Whether to try to fill the input buffer when we reach the
        -:11142:	 * end of it.
        -:11143:	 */
        -:11144:	int yy_fill_buffer;
        -:11145:
        -:11146:	int yy_buffer_status;
        -:11147:#define YY_BUFFER_NEW 0
        -:11148:#define YY_BUFFER_NORMAL 1
        -:11149:	/* When an EOF's been seen but there's still some text to process
        -:11150:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -:11151:	 * shouldn't try reading from the input source any more.  We might
        -:11152:	 * still have a bunch of tokens to match, though, because of
        -:11153:	 * possible backing-up.
        -:11154:	 *
        -:11155:	 * When we actually see the EOF, we change the status to "new"
        -:11156:	 * (via yyrestart()), so that the user can continue scanning by
        -:11157:	 * just pointing yyin at a new input file.
        -:11158:	 */
        -:11159:#define YY_BUFFER_EOF_PENDING 2
        -:11160:	};
        -:11161:
        -:11162:static YY_BUFFER_STATE yy_current_buffer = 0;
        -:11163:
        -:11164:/* We provide macros for accessing buffer states in case in the
        -:11165: * future we want to put the buffer states in a more general
        -:11166: * "scanner state".
        -:11167: */
        -:11168:#define YY_CURRENT_BUFFER yy_current_buffer
        -:11169:
        -:11170:
        -:11171:/* yy_hold_char holds the character lost when yytext is formed. */
        -:11172:static char yy_hold_char;
        -:11173:
        -:11174:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -:11175:
        -:11176:
        -:11177:int yyleng;
        -:11178:
        -:11179:/* Points to current character in buffer. */
        -:11180:static char *yy_c_buf_p = (char *) 0;
        -:11181:static int yy_init = 1;		/* whether we need to initialize */
        -:11182:static int yy_start = 0;	/* start state number */
        -:11183:
        -:11184:/* Flag which is used to allow yywrap()'s to do buffer switches
        -:11185: * instead of setting up a fresh yyin.  A bit of a hack ...
        -:11186: */
        -:11187:static int yy_did_buffer_switch_on_eof;
        -:11188:
        -:11189:void yyrestart YY_PROTO(( FILE *input_file ));
        -:11190:
        -:11191:void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
        -:11192:void yy_load_buffer_state YY_PROTO(( void ));
        -:11193:YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
        -:11194:void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -:11195:void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
        -:11196:void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -:11197:#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
        -:11198:
        -:11199:YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
        -:11200:YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
        -:11201:YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
        -:11202:
        -:11203:static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
        -:11204:static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
        -:11205:static void yy_flex_free YY_PROTO(( void * ));
        -:11206:
        -:11207:#define yy_new_buffer yy_create_buffer
        -:11208:
        -:11209:#define yy_set_interactive(is_interactive) \
        -:11210:	{ \
        -:11211:	if ( ! yy_current_buffer ) \
        -:11212:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:11213:	yy_current_buffer->yy_is_interactive = is_interactive; \
        -:11214:	}
        -:11215:
        -:11216:#define yy_set_bol(at_bol) \
        -:11217:	{ \
        -:11218:	if ( ! yy_current_buffer ) \
        -:11219:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:11220:	yy_current_buffer->yy_at_bol = at_bol; \
        -:11221:	}
        -:11222:
        -:11223:#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
        -:11224:
        -:11225:typedef unsigned char YY_CHAR;
        -:11226:FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        -:11227:typedef int yy_state_type;
        -:11228:extern char *yytext;
        -:11229:#define yytext_ptr yytext
        -:11230:
        -:11231:static yy_state_type yy_get_previous_state YY_PROTO(( void ));
        -:11232:static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
        -:11233:static int yy_get_next_buffer YY_PROTO(( void ));
        -:11234:static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
        -:11235:
        -:11236:/* Done after the current pattern has been matched and before the
        -:11237: * corresponding action - sets up yytext.
        -:11238: */
        -:11239:#define YY_DO_BEFORE_ACTION \
        -:11240:	yytext_ptr = yy_bp; \
        -:11241:	yyleng = (int) (yy_cp - yy_bp); \
        -:11242:	yy_hold_char = *yy_cp; \
        -:11243:	*yy_cp = '\0'; \
        -:11244:	yy_c_buf_p = yy_cp;
        -:11245:
        -:11246:#define YY_NUM_RULES 165
        -:11247:#define YY_END_OF_BUFFER 166
        -:11248:static yyconst short int yy_accept[769] =
        -:11249:    {   0,
        -:11250:        0,    0,    0,    0,   87,   87,  163,  163,    0,    0,
        -:11251:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11252:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11253:        0,    0,    0,    0,    0,    0,    0,    0,  166,  164,
        -:11254:        7,   18,  164,   16,    1,   17,  164,  164,  164,  164,
        -:11255:       15,  108,  100,  101,  108,   93,  108,  107,  108,  108,
        -:11256:      108,  107,   99,   89,  108,  108,   91,   92,   87,   88,
        -:11257:       87,   86,   85,   86,   86,  163,  163,   28,   29,   28,
        -:11258:       28,   28,   28,   28,   28,   31,   30,   32,   31,  113,
        -:11259:      109,  110,  112,  114,  141,  142,  141,  139,  138,  140,
        -:11260:
        -:11261:      115,  117,  115,  116,  115,  120,  120,  120,  120,  122,
        -:11262:      124,  122,  122,  122,  122,  123,  151,  155,  151,  154,
        -:11263:      156,  156,  152,  152,  152,  149,  150,  164,   82,  164,
        -:11264:       21,   22,   21,   20,  157,  159,  157,  160,  161,  147,
        -:11265:      147,  148,  147,  147,  147,  147,  147,  147,  147,   81,
        -:11266:       34,   33,   81,   81,   81,   81,   35,   81,   81,   81,
        -:11267:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11268:       81,   81,   81,   81,   81,   81,   26,   23,   26,   24,
        -:11269:        7,   18,    0,   16,    1,   17,    0,    0,    0,   14,
        -:11270:        8,    0,    0,    0,    0,    4,    5,    0,    2,   15,
        -:11271:
        -:11272:      100,  101,    0,    0,    0,   95,    0,    0,  105,  105,
        -:11273:        0,  162,  162,  162,   94,    0,   99,   89,    0,    0,
        -:11274:        0,   91,   92,  104,   90,    0,   87,   88,   86,   85,
        -:11275:       85,   83,   84,  163,  163,   28,   29,   28,   28,   28,
        -:11276:       28,   31,   30,   32,  111,  112,  142,  138,  117,    0,
        -:11277:      118,  119,  124,  121,  151,  155,    0,  153,    0,  144,
        -:11278:      152,  152,  152,    0,   82,    0,   21,   22,   21,   19,
        -:11279:      157,  159,  158,  147,  147,  147,  148,  143,  147,  147,
        -:11280:      147,   34,   33,    0,   80,    0,    0,   81,   81,   81,
        -:11281:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11282:
        -:11283:       81,   81,   81,   36,   81,   81,   81,   81,   81,   81,
        -:11284:       81,   81,   81,   81,    0,   25,   24,    0,   14,    8,
        -:11285:        0,   12,    0,    0,    0,    0,    0,    4,    5,    0,
        -:11286:        6,    0,   96,    0,   97,    0,    0,  105,  105,    0,
        -:11287:      105,  105,  105,  162,  162,    0,  106,   90,   98,    0,
        -:11288:      104,    0,   83,   84,   28,   28,   28,   27,   28,    0,
        -:11289:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11290:        0,  152,  152,  143,  143,  147,  147,    0,    0,   81,
        -:11291:       81,   81,   81,   81,   44,   81,   81,   81,   49,   81,
        -:11292:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11293:
        -:11294:       81,   81,   81,   81,   81,   81,   81,   81,    0,   81,
        -:11295:       81,   81,   81,    0,    0,    0,   12,    0,    0,    0,
        -:11296:        0,    0,    0,    4,    5,    0,  105,  105,  105,  105,
        -:11297:      105,  105,  162,    0,    0,   28,   28,    0,    0,    0,
        -:11298:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11299:      152,  152,  147,  147,   37,   38,   81,   81,   81,   81,
        -:11300:       81,   81,   81,   81,   50,   51,   81,   81,   81,   55,
        -:11301:       81,   81,   81,   81,   81,   81,   60,   81,   81,   81,
        -:11302:       81,   81,   81,   67,    0,    0,    0,   81,   81,   81,
        -:11303:       81,    0,   13,    0,    0,    0,    0,    0,    0,  105,
        -:11304:
        -:11305:      105,  105,  105,  105,  105,    0,    0,   28,   28,  137,
        -:11306:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11307:        0,    0,  152,  152,  147,  147,   39,   81,   41,   81,
        -:11308:       43,   81,   81,   81,   47,   81,   52,   81,   81,   81,
        -:11309:       81,   81,   81,   81,   81,   81,   62,   81,   81,   65,
        -:11310:       81,    0,    0,    0,    0,   81,   81,   81,   81,    3,
        -:11311:        0,    0,    0,    0,  105,  105,  105,    0,    0,   28,
        -:11312:       28,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11313:        0,    0,    0,  145,  146,  145,  146,   81,   42,   81,
        -:11314:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11315:
        -:11316:       81,   78,   61,   81,   64,   81,    0,    0,    0,    0,
        -:11317:       81,   81,   69,   70,    0,   10,    0,   11,    0,  103,
        -:11318:        0,  102,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11319:        0,    0,    0,    0,   81,   81,   81,   45,   81,   48,
        -:11320:       81,   81,   81,   81,   77,   81,   59,   63,   66,    0,
        -:11321:        0,    0,    0,   79,   81,    0,  102,    0,    0,    0,
        -:11322:        0,    0,    0,    0,    0,    0,    0,    0,    0,   81,
        -:11323:       81,   81,   46,   81,   81,   56,   81,   81,    0,    0,
        -:11324:        0,    0,   68,    0,    9,    0,  125,  126,  127,  128,
        -:11325:      129,  130,  131,  132,  133,  134,  135,    0,   81,   81,
        -:11326:
        -:11327:       81,   81,   81,   81,   81,    0,    0,    0,    0,    0,
        -:11328:      136,   81,   81,   81,   81,   54,   81,   81,    0,    0,
        -:11329:        0,    0,    0,    0,   81,   81,   81,   53,   81,   58,
        -:11330:        0,    0,    0,    0,    0,    0,   81,   81,   81,   81,
        -:11331:       72,    0,    0,    0,    0,   73,   81,   81,   81,   81,
        -:11332:       71,    0,   75,    0,   81,   81,   81,   74,   76,   81,
        -:11333:       81,   81,   81,   81,   81,   57,   40,    0
        -:11334:    } ;
        -:11335:
        -:11336:static yyconst int yy_ec[256] =
        -:11337:    {   0,
        -:11338:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:11339:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -:11340:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11341:        1,    2,    1,    5,    6,    7,    8,    1,    9,   10,
        -:11342:       10,   11,   12,   13,   14,   10,   15,   16,   16,   16,
        -:11343:       16,   16,   16,   16,   17,   18,   19,   20,    1,   21,
        -:11344:       22,   23,   10,    1,   31,   32,   33,   34,   35,   36,
        -:11345:       37,   38,   39,   40,   41,   42,   43,   44,   45,   46,
        -:11346:       47,   48,   49,   50,   51,   52,   53,   54,   55,   47,
        -:11347:       26,   27,   28,   29,   30,    1,   31,   32,   33,   34,
        -:11348:
        -:11349:       35,   36,   37,   38,   39,   40,   41,   42,   43,   44,
        -:11350:       45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
        -:11351:       55,   47,   56,   57,   58,    1,    1,    1,    1,    1,
        -:11352:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11353:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11354:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11355:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11356:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11357:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11358:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11359:
        -:11360:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11361:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11362:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11363:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11364:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11365:        1,    1,    1,    1,    1
        -:11366:    } ;
        -:11367:
        -:11368:static yyconst int yy_meta[59] =
        -:11369:    {   0,
        -:11370:        1,    1,    2,    1,    3,    1,    1,    1,    4,    1,
        -:11371:        5,    6,    1,    7,    4,    8,    8,    8,    8,    1,
        -:11372:        1,    1,    1,    9,   10,    1,   11,   12,    1,   13,
        -:11373:       14,   14,   14,   14,   14,   14,   15,   15,   15,   15,
        -:11374:       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
        -:11375:       15,   15,   15,   15,   15,    4,    1,   16
        -:11376:    } ;
        -:11377:
        -:11378:static yyconst short int yy_base[858] =
        -:11379:    {   0,
        -:11380:        0,   58,  115,  172,  120,  129, 2712, 2711,  230, 2705,
        -:11381:      136,  141,  288,    0, 2683, 2682,  144,  151,  185,  191,
        -:11382:      178,  188,  344,  347,  375,    0,  125,  131,  147,  216,
        -:11383:      431,  434,  461,    0,  519,    0,  205,  349, 2710, 2716,
        -:11384:      353, 2716, 2706,    0,  360, 2716, 2705,  144,  570, 2696,
        -:11385:        0, 2716,  577, 2716, 2703, 2716,  438, 2716, 2684,  126,
        -:11386:      149,  427,  591, 2716, 2701,  141, 2682, 2716,    0, 2716,
        -:11387:     2699,    0, 2699, 2697,  155, 2696, 2716,    0, 2716, 2695,
        -:11388:     2716,    0, 2662, 2641, 2637,    0, 2692, 2716, 2690, 2716,
        -:11389:     2716, 2663,    0, 2716, 2716, 2716, 2688, 2716,  431, 2716,
        -:11390:
        -:11391:     2716, 2716, 2687, 2716,  567, 2716, 2669,  571,  164, 2716,
        -:11392:     2716, 2685,    0, 2667,  573, 2716,    0, 2716, 2683, 2716,
        -:11393:      573, 2674,    0, 2649, 2628, 2716, 2716,  222, 2716,  356,
        -:11394:      448, 2716,  450, 2667,    0, 2716, 2678, 2716,    0,    0,
        -:11395:      198, 2716, 2677, 2621, 2716, 2667,    0, 2642, 2621, 2716,
        -:11396:     2673, 2716, 2671, 2668, 2640, 2639, 2716,  544, 2639,  579,
        -:11397:     2634, 2635,  318,    0, 2623, 2631,  424,  562, 2614,  587,
        -:11398:     2629, 2613, 2618, 2626, 2629, 2604, 2716, 2716, 2653,  612,
        -:11399:      634, 2716, 2654,    0,  637, 2716, 2653,  600, 2616,    0,
        -:11400:        0,  641,  647,  651,  669,    0,    0,  453, 2716,    0,
        -:11401:
        -:11402:      672, 2716, 2651, 2597,  605, 2716, 2649, 2616,  620,  657,
        -:11403:      645, 2716,  662,    0, 2716, 2592,  688, 2716, 2646, 2592,
        -:11404:     2636, 2625, 2716,    0, 2716, 2610,    0, 2716,    0,    0,
        -:11405:     2642,    0,    0, 2640, 2716,    0, 2716,    0, 2602, 2598,
        -:11406:      745,    0, 2638, 2716, 2716,    0, 2716,  688, 2716,  773,
        -:11407:     2716, 2716, 2716, 2716,    0, 2716,  673, 2716,    0, 2716,
        -:11408:        0, 2599, 2595,  690, 2716,  698,  707, 2716,  709, 2716,
        -:11409:        0, 2716, 2716,    0,  596, 2579, 2716,  827,    0, 2596,
        -:11410:     2592, 2632, 2716, 2628, 2716, 2593, 2592,    0,  642, 2582,
        -:11411:      563, 2617, 2579,  620, 2578, 2577, 2583,  669, 2570, 2584,
        -:11412:
        -:11413:     2572,    0, 2569, 2716, 2570, 2571, 2579, 2582,  685,  125,
        -:11414:     2570, 2567, 2566,  688, 2608, 2716,  716, 2568,    0,    0,
        -:11415:      720, 2716, 2608,  884, 2562, 2559, 2569,    0,    0,  723,
        -:11416:     2716,  739, 2716,  805, 2716,  808, 2562,  787,  869,  876,
        -:11417:      930,  881,  973,  800,    0, 2548, 2716, 2716, 2716, 2570,
        -:11418:        0, 2559,    0,    0, 2568, 2557,    0, 2716,    0, 1009,
        -:11419:     2581,  678,  870,  871,  874,  879,  913,  992,  974, 1013,
        -:11420:      885, 2565, 2554,    0, 1067, 2563, 2552, 2546, 2545, 2557,
        -:11421:     2562, 2561, 2550, 2557,    0, 2554, 2537, 2556,    0, 2536,
        -:11422:     2543, 2533, 2548, 2568, 2537, 2549, 2544, 2542, 2541, 2532,
        -:11423:
        -:11424:     2539, 2540, 2538, 2539,  578, 2520, 2538, 2525,  860, 2526,
        -:11425:     2528, 2521, 2517, 2529,  817, 1044, 2716,  822, 1095,  914,
        -:11426:     2532, 2523, 2517,    0,    0, 2524, 1102, 1025, 1142, 2539,
        -:11427:     1028, 1163, 2716, 2513, 2521, 2523, 2507,    0, 2526, 1058,
        -:11428:      891, 1014, 1019,  894, 1038, 1080, 1072, 1086, 1083, 1081,
        -:11429:     2520, 2504, 2518, 2502, 2716, 2716, 2505, 2493, 2492, 2495,
        -:11430:     2507, 1148, 2507, 2492,    0,    0, 2492, 2493, 2507,    0,
        -:11431:     2525, 2490, 2498, 2522, 2485, 2495,    0, 2500, 2491, 2487,
        -:11432:     2479, 2479, 2483,    0,  875, 2494, 2481, 2494, 2480, 2475,
        -:11433:     2491, 2519, 2716,  920,  999, 2465, 2474, 2468, 2494, 2496,
        -:11434:
        -:11435:     1105, 1184, 1081,  902,  969, 2479, 2491, 2463, 2477, 2716,
        -:11436:      165, 1090, 1144, 1143, 1147, 1163, 1095, 1145, 1037, 1085,
        -:11437:     1150, 1173, 2461, 2475, 2459, 2473,    0, 2458,    0, 2460,
        -:11438:        0, 1165, 2454, 2469,    0, 2461,    0, 2471, 2410, 2414,
        -:11439:     2434, 2400, 2393, 2405, 2385, 2382,    0, 2383, 2335,    0,
        -:11440:     2335, 2330, 2326, 2309, 2278, 2259, 2269, 2268, 2256, 2297,
        -:11441:     1046, 2238, 2242, 2253, 1179, 1142, 1145, 2247, 2246,    0,
        -:11442:        0, 1191, 1192, 1172, 1201, 1202, 1204, 1205, 1206, 1207,
        -:11443:     1209, 1210, 1208,    0,    0,    0,    0, 2254,    0, 2221,
        -:11444:     2229, 2218, 2208, 2200, 2209, 2198, 2195, 2165, 2168, 2149,
        -:11445:
        -:11446:     2132,    0,    0, 2129,    0, 2139, 2143, 2134, 2124, 2137,
        -:11447:     2117, 2116,    0,    0, 1228, 2716, 1232, 2716, 2111, 2716,
        -:11448:     2117, 2716, 2115, 2114, 2108, 2107, 2106, 2103, 2102, 2098,
        -:11449:     2095, 2063, 2047, 1213, 2012, 1986, 1975,    0, 1954,    0,
        -:11450:     1947, 1950, 1941, 1945,    0, 1942,    0,    0,    0, 1938,
        -:11451:     1940, 1934, 1905,    0, 1872, 1234, 2716, 1888, 1882, 1881,
        -:11452:     1864, 1848, 1832, 1828, 1827, 1826, 1823, 1806, 1809, 1784,
        -:11453:     1787, 1772,    0, 1781, 1786,    0, 1766, 1767, 1759, 1744,
        -:11454:     1213, 1736,    0, 1236, 2716, 1245, 2716, 2716, 2716, 2716,
        -:11455:     2716, 2716, 2716, 2716, 2716, 2716, 2716, 1750, 1727, 1720,
        -:11456:
        -:11457:     1701, 1687, 1670, 1681, 1667, 1679, 1659,  689, 1658, 1671,
        -:11458:     2716, 1657, 1627, 1621, 1635,    0, 1603, 1596, 1595, 1608,
        -:11459:     1602, 1587, 1586, 1583, 1581, 1587, 1555,    0, 1547,    0,
        -:11460:     1527, 1507, 1520, 1503, 1483, 1482, 1485, 1443, 1440, 1228,
        -:11461:     2716, 1225, 1224, 1206, 1210, 2716, 1213, 1202, 1018,  948,
        -:11462:     2716,  945, 2716,  884,  780,  771,  779, 2716, 2716,  689,
        -:11463:      673,  581,  408,  318,   86,    0,    0, 2716, 1263, 1279,
        -:11464:     1295, 1311, 1327, 1343, 1359, 1375, 1391, 1407, 1423, 1439,
        -:11465:     1455, 1471, 1481, 1496, 1505, 1520, 1536, 1545, 1560, 1576,
        -:11466:     1592, 1608, 1624, 1634, 1649, 1659, 1674, 1690, 1706, 1718,
        -:11467:
        -:11468:     1728, 1743, 1759, 1775, 1791, 1807, 1817, 1832, 1843, 1236,
        -:11469:     1858, 1874, 1890, 1898, 1905, 1920, 1936, 1952, 1968, 1977,
        -:11470:     1985, 2001, 2017, 2033, 2049, 2065, 2081, 2097, 2113, 2123,
        -:11471:     2138, 2148, 2155, 2170, 2182, 2192, 2207, 2223, 2239, 2255,
        -:11472:     2265, 2280, 2291, 2306, 2322, 2338, 2354, 2364, 2373, 2388,
        -:11473:     2404, 2420, 2429, 2437, 2453, 2469, 2485
        -:11474:    } ;
        -:11475:
        -:11476:static yyconst short int yy_def[858] =
        -:11477:    {   0,
        -:11478:      768,  768,  769,  769,  770,  771,  772,  772,  768,    9,
        -:11479:      773,  773,  768,   13,  774,  774,  775,  775,  776,  776,
        -:11480:      777,  777,  778,  778,  768,   25,  779,  779,  780,  780,
        -:11481:      781,  781,  768,   33,  768,   35,  782,  782,  768,  768,
        -:11482:      768,  768,  768,  783,  768,  768,  768,  768,  784,  768,
        -:11483:      785,  768,  768,  768,  768,  768,  768,  768,  768,  786,
        -:11484:      787,  788,  768,  768,  768,  768,  768,  768,  789,  768,
        -:11485:      789,  790,  791,  790,  790,  792,  768,  793,  768,  793,
        -:11486:      768,  794,  794,  794,  793,  795,  768,  768,  795,  768,
        -:11487:      768,  768,  796,  768,  768,  768,  768,  768,  768,  768,
        -:11488:
        -:11489:      768,  768,  768,  768,  787,  768,  768,  787,  797,  768,
        -:11490:      768,  768,  798,  768,  787,  768,  799,  768,  799,  768,
        -:11491:      800,  768,  801,  801,  801,  768,  768,  802,  768,  802,
        -:11492:      803,  768,  803,  768,  804,  768,  804,  768,  805,  806,
        -:11493:      806,  768,  806,  806,  768,  806,  807,  807,  807,  768,
        -:11494:      768,  768,  768,  808,  768,  768,  768,  809,  809,  809,
        -:11495:      809,  809,  809,  809,  809,  809,  809,  810,  809,  809,
        -:11496:      809,  809,  809,  809,  809,  809,  768,  768,  811,  768,
        -:11497:      768,  768,  768,  783,  768,  768,  768,  768,  768,  812,
        -:11498:      813,  768,  768,  768,  768,  814,  815,  816,  768,  785,
        -:11499:
        -:11500:      768,  768,  768,  768,  817,  768,  768,  768,  818,  818,
        -:11501:      819,  768,  768,  820,  768,  821,  768,  768,  768,  768,
        -:11502:      768,  768,  768,  822,  768,  768,  823,  768,  824,  825,
        -:11503:      825,  826,  827,  828,  768,  829,  768,  830,  830,  830,
        -:11504:      768,  831,  768,  768,  768,  832,  768,  768,  768,  833,
        -:11505:      768,  768,  768,  768,  834,  768,  835,  768,  835,  768,
        -:11506:      836,  836,  836,  837,  768,  837,  838,  768,  838,  768,
        -:11507:      839,  768,  768,  840,  840,  840,  768,  768,  841,  841,
        -:11508:      841,  768,  768,  842,  768,  768,  768,  843,  843,  843,
        -:11509:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11510:
        -:11511:      843,  843,  843,  768,  843,  843,  843,  843,  843,  843,
        -:11512:      843,  843,  843,  843,  844,  768,  768,  768,  845,  846,
        -:11513:      847,  768,  768,  768,  768,  768,  768,  848,  849,  850,
        -:11514:      768,  850,  768,  851,  768,  851,  768,  852,  852,  852,
        -:11515:      768,  852,  852,  768,  853,  854,  768,  768,  768,  768,
        -:11516:      855,  768,  826,  827,  830,  830,  241,  768,  241,  241,
        -:11517:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11518:      833,  836,  836,  278,  278,  841,  841,  768,  768,  843,
        -:11519:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11520:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11521:
        -:11522:      843,  843,  843,  843,  843,  843,  843,  843,  768,  843,
        -:11523:      843,  843,  843,  768,  847,  847,  768,  847,  847,  768,
        -:11524:      768,  768,  768,  848,  849,  768,  341,  852,  343,  341,
        -:11525:      852,  343,  768,  768,  768,  830,  830,  360,  768,  833,
        -:11526:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11527:      836,  836,  841,  841,  768,  768,  843,  843,  843,  843,
        -:11528:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11529:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11530:      843,  843,  843,  843,  768,  768,  768,  843,  843,  843,
        -:11531:      843,  768,  768,  847,  847,  768,  768,  768,  768,  427,
        -:11532:
        -:11533:      852,  343,  852,  852,  852,  768,  768,  830,  830,  768,
        -:11534:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11535:      833,  833,  836,  836,  841,  841,  843,  843,  843,  843,
        -:11536:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11537:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11538:      843,  768,  768,  768,  768,  843,  843,  843,  843,  768,
        -:11539:      856,  768,  768,  768,  852,  852,  852,  768,  768,  830,
        -:11540:      830,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11541:      833,  833,  833,  836,  836,  841,  841,  843,  843,  843,
        -:11542:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11543:
        -:11544:      843,  843,  843,  843,  843,  843,  768,  768,  768,  768,
        -:11545:      843,  843,  843,  843,  856,  768,  856,  768,  768,  768,
        -:11546:      768,  768,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11547:      833,  833,  833,  833,  843,  843,  843,  843,  843,  843,
        -:11548:      843,  843,  843,  843,  843,  843,  843,  843,  843,  768,
        -:11549:      768,  768,  768,  843,  843,  857,  768,  768,  768,  768,
        -:11550:      768,  768,  768,  768,  768,  768,  768,  768,  833,  843,
        -:11551:      843,  843,  843,  843,  843,  843,  843,  843,  768,  768,
        -:11552:      768,  768,  843,  857,  768,  857,  768,  768,  768,  768,
        -:11553:      768,  768,  768,  768,  768,  768,  768,  768,  843,  843,
        -:11554:
        -:11555:      843,  843,  843,  843,  843,  768,  768,  768,  768,  768,
        -:11556:      768,  843,  843,  843,  843,  843,  843,  843,  768,  768,
        -:11557:      768,  768,  768,  768,  843,  843,  843,  843,  843,  843,
        -:11558:      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,
        -:11559:      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,
        -:11560:      768,  768,  768,  768,  843,  843,  843,  768,  768,  843,
        -:11561:      843,  843,  843,  843,  843,  843,  843,    0,  768,  768,
        -:11562:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11563:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11564:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11565:
        -:11566:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11567:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11568:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11569:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11570:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11571:      768,  768,  768,  768,  768,  768,  768
        -:11572:    } ;
        -:11573:
        -:11574:static yyconst short int yy_nxt[2775] =
        -:11575:    {   0,
        -:11576:       40,   41,   42,   43,   40,   40,   40,   40,   40,   40,
        -:11577:       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
        -:11578:       40,   40,   40,   44,   44,   40,   40,   40,   40,   44,
        -:11579:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:11580:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:11581:       44,   44,   44,   44,   44,   40,   40,   40,   40,   45,
        -:11582:       46,   47,   40,   48,   40,   49,   40,   40,   40,   40,
        -:11583:       40,   40,   50,   40,   40,   40,   40,   40,   40,   40,
        -:11584:       40,   51,   51,   40,   40,   40,   40,   51,   51,   51,
        -:11585:       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        -:11586:
        -:11587:       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        -:11588:       51,   51,   51,   40,   40,   40,   53,   54,   55,   56,
        -:11589:      767,   57,   70,   71,   58,   58,   58,  129,  130,   58,
        -:11590:       73,   70,   74,  129,  130,   59,   75,   87,   88,   89,
        -:11591:       60,   61,   87,   88,   89,  188,   96,   97,  224,  132,
        -:11592:      133,  210,  211,   96,   97,  404,   98,  134,  405,   99,
        -:11593:       99,   99,   99,   98,  213,  213,   99,   99,   99,   99,
        -:11594:       62,   58,   58,   63,   64,   65,   56,  252,   57,   66,
        -:11595:       40,   58,   58,   58,  439,  189,   58,  102,  103,  104,
        -:11596:       40,  252,   67,  102,  103,  104,  225,   60,   61,  275,
        -:11597:
        -:11598:       68,  100,  214,  107,  108,  276,  109,  178,  100,  179,
        -:11599:      232,  105,  233,  107,  108,  572,  109,  105,  132,  133,
        -:11600:      180,  180,  180,  180,  265,  266,  134,   62,   58,   58,
        -:11601:       78,   78,   79,   80,   78,   78,   78,   78,   78,   78,
        -:11602:       81,   78,   78,   78,   78,   78,   78,   78,   78,   78,
        -:11603:       78,   78,   78,   82,   82,   78,   78,   78,   78,   82,
        -:11604:       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
        -:11605:       82,   82,   82,   82,   82,   82,   82,   83,   82,   82,
        -:11606:       82,   82,   82,   82,   84,   78,   78,   78,   90,   90,
        -:11607:       40,   90,   90,   90,   90,   90,   90,   90,   91,   90,
        -:11608:
        -:11609:       91,   90,   90,   90,   90,   90,   90,   90,   90,   90,
        -:11610:       92,   93,   93,   90,   90,   90,   90,   93,   93,   93,
        -:11611:       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
        -:11612:       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
        -:11613:       93,   93,   93,   90,   90,   90,  111,  112,  296,  111,
        -:11614:      112,  178,  766,  179,  181,  182,  183,  113,  265,  266,
        -:11615:      113,  185,  186,  187,  180,  180,  180,  180,  297,  114,
        -:11616:      115,  116,  114,  115,  116,  117,  117,  118,  119,  120,
        -:11617:      117,  117,  117,  121,  117,  117,  117,  117,  117,  122,
        -:11618:      117,  117,  117,  117,  117,  117,  117,  117,  123,  123,
        -:11619:
        -:11620:      117,  117,  117,  117,  123,  123,  123,  123,  123,  123,
        -:11621:      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
        -:11622:      123,  123,  124,  123,  123,  123,  123,  123,  123,  125,
        -:11623:      126,  117,  127,  136,  137,  138,  136,  137,  138,  206,
        -:11624:      206,  207,  215,  215,  215,  215,  248,  248,  248,  248,
        -:11625:      268,  269,  268,  269,  300,  331,  332,  139,  301,  765,
        -:11626:      139,  140,  141,  142,  143,  140,  140,  140,  144,  140,
        -:11627:      140,  145,  140,  140,  140,  146,  140,  140,  140,  140,
        -:11628:      140,  140,  140,  140,  147,  147,  140,  140,  140,  140,
        -:11629:      147,  147,  147,  147,  147,  147,  147,  147,  147,  147,
        -:11630:
        -:11631:      147,  147,  147,  147,  147,  147,  147,  147,  148,  147,
        -:11632:      147,  147,  147,  147,  147,  149,  140,  140,  140,  150,
        -:11633:      151,  152,  153,  154,  150,  150,  150,  150,  150,  150,
        -:11634:      150,  150,  150,  150,  150,  155,  156,  150,  150,  150,
        -:11635:      157,  150,  150,  150,  150,  150,  150,  150,  150,  158,
        -:11636:      159,  160,  161,  162,  163,  164,  164,  165,  164,  164,
        -:11637:      166,  167,  168,  169,  170,  164,  171,  172,  164,  173,
        -:11638:      174,  175,  164,  176,  150,  150,  150,  191,  201,  202,
        -:11639:      203,  258,  213,  213,  204,  289,  213,  213,  213,  213,
        -:11640:      292,  290,  217,  218,  219,  383,  303,  275,  220,  259,
        -:11641:
        -:11642:      192,  188,  193,  276,  193,  221,  304,  335,  336,  293,
        -:11643:      193,  222,  384,  193,  194,  195,  480,  193,  196,  223,
        -:11644:      214,  306,  481,  197,  214,  198,  214,  317,  317,  317,
        -:11645:      317,  307,  764,  205,  308,  181,  182,  183,  185,  186,
        -:11646:      187,  189,  321,  322,  323,  339,  340,  205,  321,  322,
        -:11647:      323,  387,  321,  322,  323,  388,  324,  324,  324,  324,
        -:11648:      342,  342,  324,  324,  324,  324,  324,  324,  324,  324,
        -:11649:      321,  322,  323,  201,  202,  203,  341,  344,  344,  204,
        -:11650:      380,  258,  339,  340,  324,  324,  324,  324,  325,  217,
        -:11651:      218,  219,  265,  266,  381,  220,  326,  439,  343,  259,
        -:11652:
        -:11653:      265,  266,  221,  248,  248,  248,  248,  673,  222,  268,
        -:11654:      269,  268,  269,  327,  392,  402,  223,  409,  393,  440,
        -:11655:      410,  416,  417,  418,  403,  331,  332,  763,  205,  411,
        -:11656:      412,  317,  317,  317,  317,  419,  419,  419,  419,  721,
        -:11657:      413,  331,  332,  722,  205,  357,  357,  358,  359,  357,
        -:11658:      357,  357,  357,  357,  357,  360,  357,  357,  357,  357,
        -:11659:      357,  357,  357,  357,  357,  357,  357,  357,  360,  360,
        -:11660:      357,  357,  357,  357,  360,  360,  360,  360,  360,  360,
        -:11661:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11662:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11663:
        -:11664:      357,  357,  357,  362,  363,  364,  365,  335,  336,  366,
        -:11665:      335,  336,  339,  340,  367,  212,  212,  762,  368,  493,
        -:11666:      494,  369,  761,  370,  417,  494,  371,  374,  374,  760,
        -:11667:      374,  374,  374,  374,  374,  374,  374,  375,  374,  374,
        -:11668:      374,  374,  374,  374,  374,  374,  374,  374,  374,  374,
        -:11669:      375,  375,  374,  374,  374,  374,  375,  375,  375,  375,
        -:11670:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11671:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11672:      375,  375,  374,  374,  374,  420,  322,  323,  427,  439,
        -:11673:      439,  428,  428,  439,  339,  340,  431,  431,  439,  324,
        -:11674:
        -:11675:      324,  324,  324,  338,  439,  485,  339,  340,  486,  487,
        -:11676:      439,  441,  443,  439,  442,  420,  322,  323,  450,  552,
        -:11677:      759,  513,  493,  494,  516,  553,  444,  339,  340,  429,
        -:11678:      338,  338,  439,  338,  338,  338,  338,  338,  338,  338,
        -:11679:      338,  338,  338,  338,  338,  338,  338,  338,  338,  338,
        -:11680:      338,  338,  338,  430,  430,  339,  340,  445,  338,  338,
        -:11681:      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,
        -:11682:      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,
        -:11683:      430,  430,  430,  430,  430,  338,  338,  338,  432,  432,
        -:11684:      432,  432,  758,  439,  339,  340,  432,  757,  339,  340,
        -:11685:
        -:11686:      495,  417,  418,  432,  432,  432,  432,  432,  432,  360,
        -:11687:      360,  439,  438,  360,  360,  360,  360,  360,  360,  448,
        -:11688:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11689:      360,  360,  439,  439,  360,  360,  360,  360,  439,  446,
        -:11690:      501,  501,  447,  504,  504,  416,  417,  418,  616,  617,
        -:11691:      339,  340,  638,  339,  340,  515,  439,  439,  449,  419,
        -:11692:      419,  419,  419,  514,  360,  360,  360,  375,  375,  580,
        -:11693:      375,  375,  375,  375,  375,  375,  375,  439,  375,  375,
        -:11694:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11695:      517,  439,  375,  375,  375,  375,  495,  417,  418,  439,
        -:11696:
        -:11697:      439,  511,  439,  512,  439,  439,  339,  340,  209,  439,
        -:11698:      419,  419,  419,  419,  439,  519,  520,  581,  518,  522,
        -:11699:      566,  566,  375,  375,  375,  500,  500,  573,  521,  578,
        -:11700:      339,  340,  500,  500,  500,  500,  500,  500,  500,  500,
        -:11701:      500,  500,  500,  500,  500,  500,  500,  500,  500,  500,
        -:11702:      500,  500,  500,  500,  500,  500,  500,  502,  502,  502,
        -:11703:      502,  532,  439,  439,  439,  502,  439,  339,  340,  439,
        -:11704:      339,  340,  502,  502,  502,  502,  502,  502,  505,  505,
        -:11705:      505,  505,  439,  533,  582,  576,  505,  574,  579,  534,
        -:11706:      575,  439,  439,  505,  505,  505,  505,  505,  505,  567,
        -:11707:
        -:11708:      567,  567,  567,  590,  339,  340,  338,  567,  577,  583,
        -:11709:      439,  439,  625,  591,  567,  567,  567,  567,  567,  567,
        -:11710:      439,  439,  624,  439,  439,  439,  439,  439,  439,  439,
        -:11711:      616,  617,  439,  623,  616,  617,  685,  686,  685,  686,
        -:11712:      756,  628,  626,  632,  708,  755,  634,  685,  686,  302,
        -:11713:      302,  627,  629,  754,  753,  630,  631,  633,  752,  751,
        -:11714:      750,  709,  669,   52,   52,   52,   52,   52,   52,   52,
        -:11715:       52,   52,   52,   52,   52,   52,   52,   52,   52,   69,
        -:11716:       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
        -:11717:       69,   69,   69,   69,   69,   72,   72,   72,   72,   72,
        -:11718:
        -:11719:       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
        -:11720:       72,   76,   76,   76,   76,   76,   76,   76,   76,   76,
        -:11721:       76,   76,   76,   76,   76,   76,   76,   86,   86,   86,
        -:11722:       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        -:11723:       86,   86,   86,   40,   40,   40,   40,   40,   40,   40,
        -:11724:       40,   40,   40,   40,   40,   40,   40,   40,   40,   95,
        -:11725:       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
        -:11726:       95,   95,   95,   95,   95,  101,  101,  101,  101,  101,
        -:11727:      101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
        -:11728:      101,  106,  106,  106,  106,  106,  106,  106,  106,  106,
        -:11729:
        -:11730:      106,  106,  106,  106,  106,  106,  106,  110,  110,  110,
        -:11731:      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
        -:11732:      110,  110,  110,  128,  128,  128,  128,  128,  128,  128,
        -:11733:      128,  128,  128,  128,  128,  128,  128,  128,  128,  131,
        -:11734:      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
        -:11735:      131,  131,  131,  131,  131,  135,  135,  135,  135,  135,
        -:11736:      135,  135,  135,  135,  135,  135,  135,  135,  135,  135,
        -:11737:      135,  177,  177,  177,  177,  177,  177,  177,  177,  177,
        -:11738:      177,  177,  177,  177,  177,  177,  177,  184,  184,  184,
        -:11739:      184,  749,  748,  184,  184,  184,  190,  190,  190,  190,
        -:11740:
        -:11741:      190,  190,  190,  190,  190,  190,  190,  190,  190,  190,
        -:11742:      190,  200,  200,  200,  200,  747,  746,  200,  200,  200,
        -:11743:      209,  745,  209,  209,  209,  209,  209,  209,  209,  209,
        -:11744:      209,  209,  209,  209,  209,  209,  212,  744,  212,  212,
        -:11745:      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
        -:11746:      212,  212,  216,  216,  216,  743,  742,  216,  216,  216,
        -:11747:      227,  741,  227,  227,  227,  227,  227,  227,  227,  227,
        -:11748:      227,  227,  227,  227,  227,  227,  229,  740,  229,  229,
        -:11749:      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
        -:11750:      229,  229,  230,  739,  230,  230,  230,  230,  230,  230,
        -:11751:
        -:11752:      230,  230,  230,  230,  230,  230,  230,  230,  234,  234,
        -:11753:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:11754:      234,  234,  234,  234,  236,  738,  236,  236,  737,  236,
        -:11755:      236,  236,  736,  735,  236,  236,  734,  733,  732,  236,
        -:11756:      238,  238,  238,  238,  731,  730,  238,  238,  238,  242,
        -:11757:      729,  242,  242,  242,  242,  242,  242,  242,  242,  242,
        -:11758:      242,  242,  242,  242,  242,  246,  246,  246,  246,  728,
        -:11759:      727,  246,  246,  246,  251,  726,  251,  251,  251,  251,
        -:11760:      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,
        -:11761:      254,  725,  254,  254,  254,  254,  254,  254,  254,  254,
        -:11762:
        -:11763:      254,  724,  254,  254,  254,  254,  255,  723,  720,  719,
        -:11764:      255,  255,  255,  255,  718,  717,  255,  255,  257,  716,
        -:11765:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:11766:      257,  257,  257,  257,  261,  261,  261,  261,  715,  714,
        -:11767:      261,  261,  261,  264,  264,  264,  264,  264,  264,  264,
        -:11768:      264,  264,  264,  264,  264,  264,  264,  264,  264,  267,
        -:11769:      267,  267,  267,  713,  267,  267,  267,  267,  267,  267,
        -:11770:      267,  267,  267,  267,  267,  271,  712,  711,  271,  271,
        -:11771:      271,  271,  271,  271,  271,  710,  271,  271,  271,  271,
        -:11772:      271,  273,  707,  273,  273,  273,  273,  273,  273,  273,
        -:11773:
        -:11774:      273,  273,  273,  273,  273,  273,  273,  274,  706,  274,
        -:11775:      274,  705,  274,  274,  274,  704,  703,  274,  274,  702,
        -:11776:      701,  700,  274,  279,  279,  279,  279,  699,  698,  279,
        -:11777:      279,  279,  284,  697,  284,  284,  284,  284,  284,  284,
        -:11778:      284,  284,  284,  284,  284,  284,  284,  284,  288,  288,
        -:11779:      696,  288,  288,  695,  694,  693,  288,  288,  315,  692,
        -:11780:      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
        -:11781:      315,  315,  315,  315,  319,  691,  319,  319,  319,  319,
        -:11782:      319,  319,  319,  319,  319,  319,  319,  319,  319,  319,
        -:11783:      320,  690,  320,  320,  320,  320,  320,  320,  320,  320,
        -:11784:
        -:11785:      320,  320,  320,  320,  320,  320,  328,  328,  689,  688,
        -:11786:      328,  328,  328,  329,  329,  687,  683,  329,  329,  329,
        -:11787:      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
        -:11788:      330,  330,  330,  330,  330,  330,  334,  334,  334,  334,
        -:11789:      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,
        -:11790:      334,  334,  338,  682,  338,  338,  338,  338,  338,  338,
        -:11791:      338,  338,  338,  681,  338,  338,  338,  338,  209,  680,
        -:11792:      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
        -:11793:      209,  209,  209,  209,  345,  345,  679,  678,  677,  676,
        -:11794:      345,  346,  346,  346,  346,  675,  674,  346,  346,  346,
        -:11795:
        -:11796:      346,  351,  673,  351,  351,  351,  351,  351,  351,  351,
        -:11797:      351,  351,  351,  351,  351,  351,  351,  227,  672,  227,
        -:11798:      227,  227,  227,  227,  227,  227,  227,  227,  227,  227,
        -:11799:      227,  227,  227,  229,  671,  229,  229,  229,  229,  229,
        -:11800:      229,  229,  229,  229,  229,  229,  229,  229,  229,  230,
        -:11801:      670,  230,  230,  230,  230,  230,  230,  230,  230,  230,
        -:11802:      230,  230,  230,  230,  230,  353,  668,  353,  353,  353,
        -:11803:      353,  353,  353,  353,  353,  353,  353,  353,  353,  353,
        -:11804:      353,  354,  667,  354,  354,  354,  354,  354,  354,  354,
        -:11805:      354,  354,  354,  354,  354,  354,  354,  234,  234,  234,
        -:11806:
        -:11807:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:11808:      234,  234,  234,  236,  666,  236,  236,  665,  236,  236,
        -:11809:      236,  664,  663,  236,  236,  662,  661,  660,  236,  238,
        -:11810:      238,  238,  238,  659,  658,  238,  238,  238,  242,  657,
        -:11811:      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
        -:11812:      242,  242,  242,  242,  246,  246,  246,  246,  656,  655,
        -:11813:      246,  246,  246,  361,  361,  654,  653,  652,  361,  361,
        -:11814:      255,  651,  650,  649,  255,  255,  255,  255,  648,  647,
        -:11815:      255,  255,  257,  646,  257,  257,  257,  257,  257,  257,
        -:11816:      257,  257,  257,  257,  257,  257,  257,  257,  261,  261,
        -:11817:
        -:11818:      261,  261,  645,  644,  261,  261,  261,  264,  264,  264,
        -:11819:      264,  264,  264,  264,  264,  264,  264,  264,  264,  264,
        -:11820:      264,  264,  264,  267,  267,  267,  267,  643,  267,  267,
        -:11821:      267,  267,  267,  267,  267,  267,  267,  267,  267,  271,
        -:11822:      642,  641,  271,  271,  271,  271,  271,  271,  271,  640,
        -:11823:      271,  271,  271,  271,  271,  274,  639,  274,  274,  638,
        -:11824:      274,  274,  274,  637,  636,  274,  274,  635,  622,  621,
        -:11825:      274,  279,  279,  279,  279,  620,  619,  279,  279,  279,
        -:11826:      284,  618,  284,  284,  284,  284,  284,  284,  284,  284,
        -:11827:      284,  284,  284,  284,  284,  284,  288,  288,  560,  288,
        -:11828:
        -:11829:      288,  614,  613,  612,  288,  288,  315,  611,  315,  315,
        -:11830:      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
        -:11831:      315,  315,  319,  610,  319,  319,  319,  319,  319,  319,
        -:11832:      319,  319,  319,  319,  319,  319,  319,  319,  320,  609,
        -:11833:      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
        -:11834:      320,  320,  320,  320,  415,  415,  415,  415,  415,  415,
        -:11835:      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,
        -:11836:      424,  424,  424,  424,  608,  607,  424,  424,  424,  425,
        -:11837:      425,  425,  425,  606,  605,  425,  425,  425,  330,  330,
        -:11838:      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
        -:11839:
        -:11840:      330,  330,  330,  330,  334,  334,  334,  334,  334,  334,
        -:11841:      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,
        -:11842:      338,  604,  338,  338,  338,  338,  338,  338,  338,  338,
        -:11843:      338,  603,  338,  338,  338,  338,  433,  433,  602,  601,
        -:11844:      600,  599,  433,  346,  346,  346,  346,  598,  597,  346,
        -:11845:      346,  346,  346,  351,  596,  351,  351,  351,  351,  351,
        -:11846:      351,  351,  351,  351,  351,  351,  351,  351,  351,  615,
        -:11847:      615,  615,  615,  615,  615,  615,  615,  615,  615,  615,
        -:11848:      615,  615,  615,  615,  615,  684,  684,  684,  684,  684,
        -:11849:      684,  684,  684,  684,  684,  684,  684,  684,  684,  684,
        -:11850:
        -:11851:      684,  595,  594,  593,  592,  589,  588,  587,  586,  585,
        -:11852:      584,  571,  570,  569,  568,  565,  564,  563,  562,  561,
        -:11853:      560,  559,  558,  557,  556,  555,  554,  551,  550,  549,
        -:11854:      548,  547,  546,  545,  544,  543,  542,  541,  540,  539,
        -:11855:      538,  537,  536,  535,  531,  530,  529,  528,  527,  526,
        -:11856:      525,  524,  523,  510,  509,  508,  507,  506,  503,  499,
        -:11857:      498,  497,  496,  492,  491,  490,  489,  488,  484,  483,
        -:11858:      482,  479,  478,  477,  476,  475,  474,  473,  472,  471,
        -:11859:      470,  469,  468,  467,  466,  465,  464,  463,  462,  461,
        -:11860:      460,  459,  458,  457,  456,  455,  454,  453,  452,  451,
        -:11861:
        -:11862:      439,  437,  436,  435,  434,  347,  426,  423,  422,  421,
        -:11863:      322,  414,  316,  408,  407,  406,  401,  400,  399,  398,
        -:11864:      397,  396,  395,  394,  391,  390,  389,  386,  385,  382,
        -:11865:      379,  378,  285,  282,  377,  376,  278,  373,  372,  243,
        -:11866:      356,  355,  235,  231,  352,  350,  349,  348,  218,  347,
        -:11867:      337,  206,  333,  202,  318,  186,  182,  316,  314,  313,
        -:11868:      312,  311,  310,  309,  305,  299,  298,  295,  294,  291,
        -:11869:      287,  286,  285,  283,  282,  281,  280,  260,  278,  277,
        -:11870:      272,  270,  263,  262,  260,  256,  250,  253,  250,  249,
        -:11871:      247,  245,  244,  243,  241,  240,  239,  237,  235,  228,
        -:11872:
        -:11873:      231,  228,  226,  218,  208,  202,  199,  186,  182,  768,
        -:11874:       94,   94,   85,   77,   77,   39,  768,  768,  768,  768,
        -:11875:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11876:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11877:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11878:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11879:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11880:      768,  768,  768,  768
        -:11881:    } ;
        -:11882:
        -:11883:static yyconst short int yy_chk[2775] =
        -:11884:    {   0,
        -:11885:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11886:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11887:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11888:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11889:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11890:        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        -:11891:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11892:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11893:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11894:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11895:
        -:11896:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11897:        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        -:11898:      765,    3,    5,    5,    3,    3,    3,   27,   27,    3,
        -:11899:        6,    6,    6,   28,   28,    3,    6,   11,   11,   11,
        -:11900:        3,    3,   12,   12,   12,   48,   17,   17,   66,   29,
        -:11901:       29,   60,   60,   18,   18,  310,   17,   29,  310,   17,
        -:11902:       17,   17,   17,   18,   61,   61,   18,   18,   18,   18,
        -:11903:        3,    3,    3,    4,    4,    4,    4,  109,    4,    4,
        -:11904:       21,    4,    4,    4,  511,   48,    4,   19,   19,   19,
        -:11905:       22,  109,    4,   20,   20,   20,   66,    4,    4,  141,
        -:11906:
        -:11907:        4,   17,   61,   21,   21,  141,   21,   37,   18,   37,
        -:11908:       75,   19,   75,   22,   22,  511,   22,   20,   30,   30,
        -:11909:       37,   37,   37,   37,  128,  128,   30,    4,    4,    4,
        -:11910:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11911:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11912:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11913:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11914:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11915:        9,    9,    9,    9,    9,    9,    9,    9,   13,   13,
        -:11916:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11917:
        -:11918:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11919:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11920:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11921:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11922:       13,   13,   13,   13,   13,   13,   23,   23,  163,   24,
        -:11923:       24,   38,  764,   38,   41,   41,   41,   23,  130,  130,
        -:11924:       24,   45,   45,   45,   38,   38,   38,   38,  163,   23,
        -:11925:       23,   23,   24,   24,   24,   25,   25,   25,   25,   25,
        -:11926:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11927:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11928:
        -:11929:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11930:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11931:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11932:       25,   25,   25,   31,   31,   31,   32,   32,   32,   57,
        -:11933:       57,   57,   62,   62,   62,   62,   99,   99,   99,   99,
        -:11934:      131,  131,  133,  133,  167,  198,  198,   31,  167,  763,
        -:11935:       32,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11936:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11937:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11938:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11939:
        -:11940:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11941:       33,   33,   33,   33,   33,   33,   33,   33,   33,   35,
        -:11942:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11943:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11944:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11945:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11946:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11947:       35,   35,   35,   35,   35,   35,   35,   49,   53,   53,
        -:11948:       53,  121,  105,  105,   53,  158,  108,  108,  115,  115,
        -:11949:      160,  158,   63,   63,   63,  291,  168,  275,   63,  121,
        -:11950:
        -:11951:       49,  188,   49,  275,   49,   63,  168,  205,  205,  160,
        -:11952:       49,   63,  291,   49,   49,   49,  405,   49,   49,   63,
        -:11953:      105,  170,  405,   49,  108,   49,  115,  180,  180,  180,
        -:11954:      180,  170,  762,   53,  170,  181,  181,  181,  185,  185,
        -:11955:      185,  188,  192,  192,  192,  209,  209,   63,  193,  193,
        -:11956:      193,  294,  194,  194,  194,  294,  192,  192,  192,  192,
        -:11957:      211,  211,  193,  193,  193,  193,  194,  194,  194,  194,
        -:11958:      195,  195,  195,  201,  201,  201,  210,  213,  213,  201,
        -:11959:      289,  257,  210,  210,  195,  195,  195,  195,  192,  217,
        -:11960:      217,  217,  264,  264,  289,  217,  194,  362,  211,  257,
        -:11961:
        -:11962:      266,  266,  217,  248,  248,  248,  248,  761,  217,  267,
        -:11963:      267,  269,  269,  195,  298,  309,  217,  314,  298,  362,
        -:11964:      314,  321,  321,  321,  309,  330,  330,  760,  201,  314,
        -:11965:      314,  317,  317,  317,  317,  321,  321,  321,  321,  708,
        -:11966:      314,  332,  332,  708,  217,  241,  241,  241,  241,  241,
        -:11967:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11968:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11969:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11970:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11971:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11972:
        -:11973:      241,  241,  241,  250,  250,  250,  250,  334,  334,  250,
        -:11974:      336,  336,  338,  338,  250,  344,  344,  757,  250,  415,
        -:11975:      415,  250,  756,  250,  418,  418,  250,  278,  278,  755,
        -:11976:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11977:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11978:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11979:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11980:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11981:      278,  278,  278,  278,  278,  324,  324,  324,  339,  363,
        -:11982:      364,  340,  340,  365,  339,  339,  342,  342,  366,  324,
        -:11983:
        -:11984:      324,  324,  324,  340,  371,  409,  342,  342,  409,  409,
        -:11985:      441,  363,  365,  444,  364,  420,  420,  420,  371,  485,
        -:11986:      754,  441,  494,  494,  444,  485,  366,  504,  504,  340,
        -:11987:      341,  341,  367,  341,  341,  341,  341,  341,  341,  341,
        -:11988:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11989:      341,  341,  341,  341,  341,  341,  341,  367,  341,  341,
        -:11990:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11991:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11992:      341,  341,  341,  341,  341,  341,  341,  341,  343,  343,
        -:11993:      343,  343,  752,  369,  505,  505,  343,  750,  343,  343,
        -:11994:
        -:11995:      495,  495,  495,  343,  343,  343,  343,  343,  343,  360,
        -:11996:      360,  368,  360,  360,  360,  360,  360,  360,  360,  369,
        -:11997:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11998:      360,  360,  370,  442,  360,  360,  360,  360,  443,  368,
        -:11999:      428,  428,  368,  431,  431,  416,  416,  416,  561,  561,
        -:12000:      428,  428,  749,  431,  431,  443,  519,  445,  370,  416,
        -:12001:      416,  416,  416,  442,  360,  360,  360,  375,  375,  519,
        -:12002:      375,  375,  375,  375,  375,  375,  375,  440,  375,  375,
        -:12003:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:12004:      445,  447,  375,  375,  375,  375,  419,  419,  419,  446,
        -:12005:
        -:12006:      450,  440,  449,  440,  520,  448,  503,  503,  503,  512,
        -:12007:      419,  419,  419,  419,  517,  447,  448,  520,  446,  450,
        -:12008:      501,  501,  375,  375,  375,  427,  427,  512,  449,  517,
        -:12009:      501,  501,  427,  427,  427,  427,  427,  427,  427,  427,
        -:12010:      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
        -:12011:      427,  427,  427,  427,  427,  427,  427,  429,  429,  429,
        -:12012:      429,  462,  514,  513,  518,  429,  515,  566,  566,  521,
        -:12013:      567,  567,  429,  429,  429,  429,  429,  429,  432,  432,
        -:12014:      432,  432,  516,  462,  521,  515,  432,  513,  518,  462,
        -:12015:      514,  574,  522,  432,  432,  432,  432,  432,  432,  502,
        -:12016:
        -:12017:      502,  502,  502,  532,  565,  565,  565,  502,  516,  522,
        -:12018:      572,  573,  574,  532,  502,  502,  502,  502,  502,  502,
        -:12019:      575,  576,  573,  577,  578,  579,  580,  583,  581,  582,
        -:12020:      615,  615,  634,  572,  617,  617,  656,  656,  684,  684,
        -:12021:      748,  577,  575,  581,  681,  747,  583,  686,  686,  810,
        -:12022:      810,  576,  578,  745,  744,  579,  580,  582,  743,  742,
        -:12023:      740,  681,  634,  769,  769,  769,  769,  769,  769,  769,
        -:12024:      769,  769,  769,  769,  769,  769,  769,  769,  769,  770,
        -:12025:      770,  770,  770,  770,  770,  770,  770,  770,  770,  770,
        -:12026:      770,  770,  770,  770,  770,  771,  771,  771,  771,  771,
        -:12027:
        -:12028:      771,  771,  771,  771,  771,  771,  771,  771,  771,  771,
        -:12029:      771,  772,  772,  772,  772,  772,  772,  772,  772,  772,
        -:12030:      772,  772,  772,  772,  772,  772,  772,  773,  773,  773,
        -:12031:      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
        -:12032:      773,  773,  773,  774,  774,  774,  774,  774,  774,  774,
        -:12033:      774,  774,  774,  774,  774,  774,  774,  774,  774,  775,
        -:12034:      775,  775,  775,  775,  775,  775,  775,  775,  775,  775,
        -:12035:      775,  775,  775,  775,  775,  776,  776,  776,  776,  776,
        -:12036:      776,  776,  776,  776,  776,  776,  776,  776,  776,  776,
        -:12037:      776,  777,  777,  777,  777,  777,  777,  777,  777,  777,
        -:12038:
        -:12039:      777,  777,  777,  777,  777,  777,  777,  778,  778,  778,
        -:12040:      778,  778,  778,  778,  778,  778,  778,  778,  778,  778,
        -:12041:      778,  778,  778,  779,  779,  779,  779,  779,  779,  779,
        -:12042:      779,  779,  779,  779,  779,  779,  779,  779,  779,  780,
        -:12043:      780,  780,  780,  780,  780,  780,  780,  780,  780,  780,
        -:12044:      780,  780,  780,  780,  780,  781,  781,  781,  781,  781,
        -:12045:      781,  781,  781,  781,  781,  781,  781,  781,  781,  781,
        -:12046:      781,  782,  782,  782,  782,  782,  782,  782,  782,  782,
        -:12047:      782,  782,  782,  782,  782,  782,  782,  783,  783,  783,
        -:12048:      783,  739,  738,  783,  783,  783,  784,  784,  784,  784,
        -:12049:
        -:12050:      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
        -:12051:      784,  785,  785,  785,  785,  737,  736,  785,  785,  785,
        -:12052:      786,  735,  786,  786,  786,  786,  786,  786,  786,  786,
        -:12053:      786,  786,  786,  786,  786,  786,  787,  734,  787,  787,
        -:12054:      787,  787,  787,  787,  787,  787,  787,  787,  787,  787,
        -:12055:      787,  787,  788,  788,  788,  733,  732,  788,  788,  788,
        -:12056:      789,  731,  789,  789,  789,  789,  789,  789,  789,  789,
        -:12057:      789,  789,  789,  789,  789,  789,  790,  729,  790,  790,
        -:12058:      790,  790,  790,  790,  790,  790,  790,  790,  790,  790,
        -:12059:      790,  790,  791,  727,  791,  791,  791,  791,  791,  791,
        -:12060:
        -:12061:      791,  791,  791,  791,  791,  791,  791,  791,  792,  792,
        -:12062:      792,  792,  792,  792,  792,  792,  792,  792,  792,  792,
        -:12063:      792,  792,  792,  792,  793,  726,  793,  793,  725,  793,
        -:12064:      793,  793,  724,  723,  793,  793,  722,  721,  720,  793,
        -:12065:      794,  794,  794,  794,  719,  718,  794,  794,  794,  795,
        -:12066:      717,  795,  795,  795,  795,  795,  795,  795,  795,  795,
        -:12067:      795,  795,  795,  795,  795,  796,  796,  796,  796,  715,
        -:12068:      714,  796,  796,  796,  797,  713,  797,  797,  797,  797,
        -:12069:#ifndef F_A10
        -:12070:      797,  797,  797,  797,  797,  797,  797,  797,  797,  797,
        -:12071:#else
        -:12072:      797,  797,  797,  797,  797,  797,  797,  797,  797, 0 *   797,
        -:12073:#endif
        -:12074:      798,  712,  798,  798,  798,  798,  798,  798,  798,  798,
        -:12075:
        -:12076:      798,  710,  798,  798,  798,  798,  799,  709,  707,  706,
        -:12077:      799,  799,  799,  799,  705,  704,  799,  799,  800,  703,
        -:12078:      800,  800,  800,  800,  800,  800,  800,  800,  800,  800,
        -:12079:      800,  800,  800,  800,  801,  801,  801,  801,  702,  701,
        -:12080:      801,  801,  801,  802,  802,  802,  802,  802,  802,  802,
        -:12081:      802,  802,  802,  802,  802,  802,  802,  802,  802,  803,
        -:12082:      803,  803,  803,  700,  803,  803,  803,  803,  803,  803,
        -:12083:      803,  803,  803,  803,  803,  804,  699,  698,  804,  804,
        -:12084:      804,  804,  804,  804,  804,  682,  804,  804,  804,  804,
        -:12085:      804,  805,  680,  805,  805,  805,  805,  805,  805,  805,
        -:12086:
        -:12087:      805,  805,  805,  805,  805,  805,  805,  806,  679,  806,
        -:12088:      806,  678,  806,  806,  806,  677,  675,  806,  806,  674,
        -:12089:      672,  671,  806,  807,  807,  807,  807,  670,  669,  807,
        -:12090:      807,  807,  808,  668,  808,  808,  808,  808,  808,  808,
        -:12091:      808,  808,  808,  808,  808,  808,  808,  808,  809,  809,
        -:12092:      667,  809,  809,  666,  665,  664,  809,  809,  811,  663,
        -:12093:      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
        -:12094:      811,  811,  811,  811,  812,  662,  812,  812,  812,  812,
        -:12095:      812,  812,  812,  812,  812,  812,  812,  812,  812,  812,
        -:12096:      813,  661,  813,  813,  813,  813,  813,  813,  813,  813,
        -:12097:
        -:12098:      813,  813,  813,  813,  813,  813,  814,  814,  660,  659,
        -:12099:      814,  814,  814,  815,  815,  658,  655,  815,  815,  815,
        -:12100:      816,  816,  816,  816,  816,  816,  816,  816,  816,  816,
        -:12101:      816,  816,  816,  816,  816,  816,  817,  817,  817,  817,
        -:12102:      817,  817,  817,  817,  817,  817,  817,  817,  817,  817,
        -:12103:      817,  817,  818,  653,  818,  818,  818,  818,  818,  818,
        -:12104:      818,  818,  818,  652,  818,  818,  818,  818,  819,  651,
        -:12105:      819,  819,  819,  819,  819,  819,  819,  819,  819,  819,
        -:12106:      819,  819,  819,  819,  820,  820,  650,  646,  644,  643,
        -:12107:      820,  821,  821,  821,  821,  642,  641,  821,  821,  821,
        -:12108:
        -:12109:      821,  822,  639,  822,  822,  822,  822,  822,  822,  822,
        -:12110:      822,  822,  822,  822,  822,  822,  822,  823,  637,  823,
        -:12111:      823,  823,  823,  823,  823,  823,  823,  823,  823,  823,
        -:12112:      823,  823,  823,  824,  636,  824,  824,  824,  824,  824,
        -:12113:      824,  824,  824,  824,  824,  824,  824,  824,  824,  825,
        -:12114:      635,  825,  825,  825,  825,  825,  825,  825,  825,  825,
        -:12115:      825,  825,  825,  825,  825,  826,  633,  826,  826,  826,
        -:12116:      826,  826,  826,  826,  826,  826,  826,  826,  826,  826,
        -:12117:      826,  827,  632,  827,  827,  827,  827,  827,  827,  827,
        -:12118:      827,  827,  827,  827,  827,  827,  827,  828,  828,  828,
        -:12119:
        -:12120:      828,  828,  828,  828,  828,  828,  828,  828,  828,  828,
        -:12121:      828,  828,  828,  829,  631,  829,  829,  630,  829,  829,
        -:12122:      829,  629,  628,  829,  829,  627,  626,  625,  829,  830,
        -:12123:      830,  830,  830,  624,  623,  830,  830,  830,  831,  621,
        -:12124:      831,  831,  831,  831,  831,  831,  831,  831,  831,  831,
        -:12125:      831,  831,  831,  831,  832,  832,  832,  832,  619,  612,
        -:12126:      832,  832,  832,  833,  833,  611,  610,  609,  833,  833,
        -:12127:      834,  608,  607,  606,  834,  834,  834,  834,  604,  601,
        -:12128:      834,  834,  835,  600,  835,  835,  835,  835,  835,  835,
        -:12129:      835,  835,  835,  835,  835,  835,  835,  835,  836,  836,
        -:12130:
        -:12131:      836,  836,  599,  598,  836,  836,  836,  837,  837,  837,
        -:12132:      837,  837,  837,  837,  837,  837,  837,  837,  837,  837,
        -:12133:      837,  837,  837,  838,  838,  838,  838,  597,  838,  838,
        -:12134:      838,  838,  838,  838,  838,  838,  838,  838,  838,  839,
        -:12135:      596,  595,  839,  839,  839,  839,  839,  839,  839,  594,
        -:12136:      839,  839,  839,  839,  839,  840,  593,  840,  840,  592,
        -:12137:      840,  840,  840,  591,  590,  840,  840,  588,  569,  568,
        -:12138:      840,  841,  841,  841,  841,  564,  563,  841,  841,  841,
        -:12139:      842,  562,  842,  842,  842,  842,  842,  842,  842,  842,
        -:12140:      842,  842,  842,  842,  842,  842,  843,  843,  560,  843,
        -:12141:
        -:12142:      843,  559,  558,  557,  843,  843,  844,  556,  844,  844,
        -:12143:      844,  844,  844,  844,  844,  844,  844,  844,  844,  844,
        -:12144:      844,  844,  845,  555,  845,  845,  845,  845,  845,  845,
        -:12145:      845,  845,  845,  845,  845,  845,  845,  845,  846,  554,
        -:12146:      846,  846,  846,  846,  846,  846,  846,  846,  846,  846,
        -:12147:      846,  846,  846,  846,  847,  847,  847,  847,  847,  847,
        -:12148:      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
        -:12149:      848,  848,  848,  848,  553,  552,  848,  848,  848,  849,
        -:12150:      849,  849,  849,  551,  549,  849,  849,  849,  850,  850,
        -:12151:      850,  850,  850,  850,  850,  850,  850,  850,  850,  850,
        -:12152:
        -:12153:      850,  850,  850,  850,  851,  851,  851,  851,  851,  851,
        -:12154:      851,  851,  851,  851,  851,  851,  851,  851,  851,  851,
        -:12155:      852,  548,  852,  852,  852,  852,  852,  852,  852,  852,
        -:12156:      852,  546,  852,  852,  852,  852,  853,  853,  545,  544,
        -:12157:      543,  542,  853,  854,  854,  854,  854,  541,  540,  854,
        -:12158:      854,  854,  854,  855,  539,  855,  855,  855,  855,  855,
        -:12159:      855,  855,  855,  855,  855,  855,  855,  855,  855,  856,
        -:12160:      856,  856,  856,  856,  856,  856,  856,  856,  856,  856,
        -:12161:      856,  856,  856,  856,  856,  857,  857,  857,  857,  857,
        -:12162:      857,  857,  857,  857,  857,  857,  857,  857,  857,  857,
        -:12163:
        -:12164:      857,  538,  536,  534,  533,  530,  528,  526,  525,  524,
        -:12165:      523,  509,  508,  507,  506,  500,  499,  498,  497,  496,
        -:12166:      492,  491,  490,  489,  488,  487,  486,  483,  482,  481,
        -:12167:      480,  479,  478,  476,  475,  474,  473,  472,  471,  469,
        -:12168:      468,  467,  464,  463,  461,  460,  459,  458,  457,  454,
        -:12169:      453,  452,  451,  439,  437,  436,  435,  434,  430,  426,
        -:12170:      423,  422,  421,  414,  413,  412,  411,  410,  408,  407,
        -:12171:      406,  404,  403,  402,  401,  400,  399,  398,  397,  396,
        -:12172:      395,  394,  393,  392,  391,  390,  388,  387,  386,  384,
        -:12173:      383,  382,  381,  380,  379,  378,  377,  376,  373,  372,
        -:12174:
        -:12175:      361,  356,  355,  352,  350,  346,  337,  327,  326,  325,
        -:12176:      323,  318,  315,  313,  312,  311,  308,  307,  306,  305,
        -:12177:      303,  301,  300,  299,  297,  296,  295,  293,  292,  290,
        -:12178:      287,  286,  284,  282,  281,  280,  276,  263,  262,  243,
        -:12179:      240,  239,  234,  231,  226,  222,  221,  220,  219,  216,
        -:12180:      208,  207,  204,  203,  189,  187,  183,  179,  176,  175,
        -:12181:      174,  173,  172,  171,  169,  166,  165,  162,  161,  159,
        -:12182:      156,  155,  154,  153,  151,  149,  148,  146,  144,  143,
        -:12183:      137,  134,  125,  124,  122,  119,  114,  112,  107,  103,
        -:12184:       97,   92,   89,   87,   85,   84,   83,   80,   76,   74,
        -:12185:
        -:12186:       73,   71,   67,   65,   59,   55,   50,   47,   43,   39,
        -:12187:       16,   15,   10,    8,    7,  768,  768,  768,  768,  768,
        -:12188:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:12189:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:12190:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:12191:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:12192:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:12193:      768,  768,  768,  768
        -:12194:    } ;
        -:12195:
        -:12196:static yy_state_type yy_last_accepting_state;
        -:12197:static char *yy_last_accepting_cpos;
        -:12198:
        -:12199:/* The intent behind this definition is that it'll catch
        -:12200: * any uses of REJECT which flex missed.
        -:12201: */
        -:12202:#define REJECT reject_used_but_not_detected
        -:12203:#define yymore() yymore_used_but_not_detected
        -:12204:#define YY_MORE_ADJ 0
        -:12205:#define YY_RESTORE_YY_MORE_OFFSET
        -:12206:char *yytext;
        -:12207:#define INITIAL 0
        -:12208:/* scan.l - scanner for flex input */
        -:12209:/*-
        -:12210: * Copyright (c) 1990 The Regents of the University of California.
        -:12211: * All rights reserved.
        -:12212: *
        -:12213: * This code is derived from software contributed to Berkeley by
        -:12214: * Vern Paxson.
        -:12215: * 
        -:12216: * The United States Government has rights in this work pursuant
        -:12217: * to contract no. DE-AC03-76SF00098 between the United States
        -:12218: * Department of Energy and the University of California.
        -:12219: *
        -:12220: * Redistribution and use in source and binary forms are permitted provided
        -:12221: * that: (1) source distributions retain this entire copyright notice and
        -:12222: * comment, and (2) distributions including binaries display the following
        -:12223: * acknowledgement:  ``This product includes software developed by the
        -:12224: * University of California, Berkeley and its contributors'' in the
        -:12225: * documentation or other materials provided with the distribution and in
        -:12226: * all advertising materials mentioning features or use of this software.
        -:12227: * Neither the name of the University nor the names of its contributors may
        -:12228: * be used to endorse or promote products derived from this software without
        -:12229: * specific prior written permission.
        -:12230: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:12231: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:12232: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:12233: */
        -:12234:
        -:12235:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v4/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */
        -:12236:
        -:12237:#define ACTION_ECHO add_action( yytext )
        -:12238:#define ACTION_IFDEF(def, should_define) \
        -:12239:	{ \
        -:12240:	if ( should_define ) \
        -:12241:		action_define( def, 1 ); \
        -:12242:	}
        -:12243:
        -:12244:#define MARK_END_OF_PROLOG mark_prolog();
        -:12245:
        -:12246:#define YY_DECL \
        -:12247:	int flexscan()
        -:12248:
        -:12249:#define RETURNCHAR \
        -:12250:	yylval = (unsigned char) yytext[0]; \
        -:12251:	return CHAR;
        -:12252:
        -:12253:#define RETURNNAME \
        -:12254:	strcpy( nmstr, yytext ); \
        -:12255:	return NAME;
        -:12256:
        -:12257:#define PUT_BACK_STRING(str, start) \
        -:12258:	for ( i = strlen( str ) - 1; i >= start; --i ) \
        -:12259:		unput((str)[i])
        -:12260:
        -:12261:#define CHECK_REJECT(str) \
        -:12262:	if ( all_upper( str ) ) \
        -:12263:		reject = true;
        -:12264:
        -:12265:#define CHECK_YYMORE(str) \
        -:12266:	if ( all_lower( str ) ) \
        -:12267:		yymore_used = true;
        -:12268:#define YY_STACK_USED 1
        -:12269:#define YY_NO_TOP_STATE 1
        -:12270:#define SECT2 1
        -:12271:#define SECT2PROLOG 2
        -:12272:#define SECT3 3
        -:12273:#define CODEBLOCK 4
        -:12274:#define PICKUPDEF 5
        -:12275:#define SC 6
        -:12276:#define CARETISBOL 7
        -:12277:#define NUM 8
        -:12278:#define QUOTE 9
        -:12279:
        -:12280:#define FIRSTCCL 10
        -:12281:#define CCL 11
        -:12282:#define ACTION 12
        -:12283:#define RECOVER 13
        -:12284:#define COMMENT 14
        -:12285:#define ACTION_STRING 15
        -:12286:#define PERCENT_BRACE_ACTION 16
        -:12287:
        -:12288:#define OPTION 17
        -:12289:#define LINEDIR 18
        -:12290:
        -:12291:
        -:12292:/* Macros after this point can all be overridden by user definitions in
        -:12293: * section 1.
        -:12294: */
        -:12295:
        -:12296:#ifndef YY_SKIP_YYWRAP
        -:12297:#ifdef __cplusplus
        -:12298:extern "C" int yywrap YY_PROTO(( void ));
        -:12299:#else
        -:12300:extern int yywrap YY_PROTO(( void ));
        -:12301:#endif
        -:12302:#endif
        -:12303:
        -:12304:#ifndef YY_NO_UNPUT
        -:12305:static void yyunput YY_PROTO(( int c, char *buf_ptr ));
        -:12306:#endif
        -:12307:
        -:12308:#ifndef yytext_ptr
        -:12309:static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
        -:12310:#endif
        -:12311:
        -:12312:#ifdef YY_NEED_STRLEN
        -:12313:static int yy_flex_strlen YY_PROTO(( yyconst char * ));
        -:12314:#endif
        -:12315:
        -:12316:#ifndef YY_NO_INPUT
        -:12317:#ifdef __cplusplus
        -:12318:static int yyinput YY_PROTO(( void ));
        -:12319:#else
        -:12320:static int input YY_PROTO(( void ));
        -:12321:#endif
        -:12322:#endif
        -:12323:
        -:12324:#if YY_STACK_USED
        -:12325:static int yy_start_stack_ptr = 0;
        -:12326:static int yy_start_stack_depth = 0;
        -:12327:static int *yy_start_stack = 0;
        -:12328:#ifndef YY_NO_PUSH_STATE
        -:12329:static void yy_push_state YY_PROTO(( int new_state ));
        -:12330:#endif
        -:12331:#ifndef YY_NO_POP_STATE
        -:12332:static void yy_pop_state YY_PROTO(( void ));
        -:12333:#endif
        -:12334:#ifndef YY_NO_TOP_STATE
        -:12335:static int yy_top_state YY_PROTO(( void ));
        -:12336:#endif
        -:12337:
        -:12338:#else
        -:12339:#define YY_NO_PUSH_STATE 1
        -:12340:#define YY_NO_POP_STATE 1
        -:12341:#define YY_NO_TOP_STATE 1
        -:12342:#endif
        -:12343:
        -:12344:#ifdef YY_MALLOC_DECL
        -:12345:YY_MALLOC_DECL
        -:12346:#else
        -:12347:#if __STDC__
        -:12348:#ifndef __cplusplus
        -:12349:#include <stdlib.h>
        -:12350:#endif
        -:12351:#else
        -:12352:/* Just try to get by without declaring the routines.  This will fail
        -:12353: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
        -:12354: * or sizeof(void*) != sizeof(int).
        -:12355: */
        -:12356:#endif
        -:12357:#endif
        -:12358:
        -:12359:/* Amount of stuff to slurp up with each read. */
        -:12360:#ifndef YY_READ_BUF_SIZE
        -:12361:#define YY_READ_BUF_SIZE 8192
        -:12362:#endif
        -:12363:
        -:12364:/* Copy whatever the last rule matched to the standard output. */
        -:12365:
        -:12366:#ifndef ECHO
        -:12367:/* This used to be an fputs(), but since the string might contain NUL's,
        -:12368: * we now use fwrite().
        -:12369: */
        -:12370:#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
        -:12371:#endif
        -:12372:
        -:12373:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:12374: * is returned in "result".
        -:12375: */
        -:12376:#ifndef YY_INPUT
        -:12377:#define YY_INPUT(buf,result,max_size) \
        -:12378:	if ( yy_current_buffer->yy_is_interactive ) \
        -:12379:		{ \
        -:12380:		int c = '*', n; \
        -:12381:		for ( n = 0; n < max_size && \
        -:12382:			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
        -:12383:			buf[n] = (char) c; \
        -:12384:		if ( c == '\n' ) \
        -:12385:			buf[n++] = (char) c; \
        -:12386:		if ( c == EOF && ferror( yyin ) ) \
        -:12387:			YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:12388:		result = n; \
        -:12389:		} \
        -:12390:	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
        -:12391:		  && ferror( yyin ) ) \
        -:12392:		YY_FATAL_ERROR( "input in flex scanner failed" );
        -:12393:#endif
        -:12394:
        -:12395:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:12396: * we don't want an extra ';' after the "return" because that will cause
        -:12397: * some compilers to complain about unreachable statements.
        -:12398: */
        -:12399:#ifndef yyterminate
        -:12400:#define yyterminate() return YY_NULL
        -:12401:#endif
        -:12402:
        -:12403:/* Number of entries by which start-condition stack grows. */
        -:12404:#ifndef YY_START_STACK_INCR
        -:12405:#define YY_START_STACK_INCR 25
        -:12406:#endif
        -:12407:
        -:12408:/* Report a fatal error. */
        -:12409:#ifndef YY_FATAL_ERROR
        -:12410:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:12411:#endif
        -:12412:
        -:12413:/* Default declaration of generated scanner - a define so the user can
        -:12414: * easily add parameters.
        -:12415: */
        -:12416:#ifndef YY_DECL
        -:12417:#define YY_DECL int yylex YY_PROTO(( void ))
        -:12418:#endif
        -:12419:
        -:12420:/* Code executed at the beginning of each rule, after yytext and yyleng
        -:12421: * have been set up.
        -:12422: */
        -:12423:#ifndef YY_USER_ACTION
        -:12424:#define YY_USER_ACTION
        -:12425:#endif
        -:12426:
        -:12427:/* Code executed at the end of each rule. */
        -:12428:#ifndef YY_BREAK
        -:12429:#define YY_BREAK break;
        -:12430:#endif
        -:12431:
        -:12432:#define YY_RULE_SETUP \
        -:12433:	if ( yyleng > 0 ) \
        -:12434:		yy_current_buffer->yy_at_bol = \
        -:12435:				(yytext[yyleng - 1] == '\n'); \
        -:12436:	YY_USER_ACTION
        -:12437:
       40:12438:YY_DECL
        -:12439:	{
        -:12440:	register yy_state_type yy_current_state;
        -:12441:	register char *yy_cp, *yy_bp;
        -:12442:	register int yy_act;
        -:12443:
        -:12444:
        -:12445:	static int bracelevel, didadef, indented_code;
        -:12446:	static int doing_rule_action = false;
        -:12447:	static int option_sense;
        -:12448:
       40:12449:	int doing_codeblock = false;
        -:12450:	int i;
        -:12451:	Char nmdef[MAXLINE], myesc();
        -:12452:
        -:12453:
        -:12454:
       40:12455:	if ( yy_init )
        -:12456:		{
        1:12457:		yy_init = 0;
        -:12458:
        -:12459:#ifdef YY_USER_INIT
        -:12460:		YY_USER_INIT;
        -:12461:#endif
        -:12462:
        1:12463:		if ( ! yy_start )
        1:12464:			yy_start = 1;	/* first start state */
        -:12465:
        1:12466:		if ( ! yyin )
    #####:12467:			yyin = stdin;
        -:12468:
        1:12469:		if ( ! yyout )
        1:12470:			yyout = stdout;
        -:12471:
        1:12472:		if ( ! yy_current_buffer )
        1:12473:			yy_current_buffer =
        1:12474:				yy_create_buffer( yyin, YY_BUF_SIZE );
        -:12475:
        1:12476:		yy_load_buffer_state();
        -:12477:		}
        -:12478:
        -:12479:	while ( 1 )		/* loops until end-of-file is reached */
        -:12480:		{
      102:12481:		yy_cp = yy_c_buf_p;
        -:12482:
        -:12483:		/* Support of yytext. */
      102:12484:		*yy_cp = yy_hold_char;
        -:12485:
        -:12486:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:12487:		 * the current run.
        -:12488:		 */
      102:12489:		yy_bp = yy_cp;
        -:12490:
      102:12491:		yy_current_state = yy_start;
      102:12492:		yy_current_state += YY_AT_BOL();
        -:12493:yy_match:
        -:12494:		do
        -:12495:			{
      382:12496:			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      382:12497:			if ( yy_accept[yy_current_state] )
        -:12498:				{
      281:12499:				yy_last_accepting_state = yy_current_state;
      281:12500:				yy_last_accepting_cpos = yy_cp;
        -:12501:				}
     1098:12502:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:12503:				{
      334:12504:				yy_current_state = (int) yy_def[yy_current_state];
      334:12505:				if ( yy_current_state >= 769 )
      287:12506:					yy_c = yy_meta[(unsigned int) yy_c];
        -:12507:				}
      382:12508:			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      382:12509:			++yy_cp;
        -:12510:			}
      382:12511:		while ( yy_base[yy_current_state] != 2716 );
        -:12512:
        -:12513:yy_find_action:
      103:12514:		yy_act = yy_accept[yy_current_state];
      103:12515:		if ( yy_act == 0 )
        -:12516:			{ /* have to back up */
       47:12517:			yy_cp = yy_last_accepting_cpos;
       47:12518:			yy_current_state = yy_last_accepting_state;
       47:12519:			yy_act = yy_accept[yy_current_state];
        -:12520:			}
        -:12521:
      103:12522:		YY_DO_BEFORE_ACTION;
        -:12523:
        -:12524:
        -:12525:do_action:	/* This label is used only to access EOF actions. */
        -:12526:
        -:12527:
      104:12528:		switch ( yy_act )
        -:12529:	{ /* beginning of action switch */
        -:12530:			case 0: /* must back up */
        -:12531:			/* undo the effects of YY_DO_BEFORE_ACTION */
    #####:12532:			*yy_cp = yy_hold_char;
    #####:12533:			yy_cp = yy_last_accepting_cpos;
    #####:12534:			yy_current_state = yy_last_accepting_state;
    #####:12535:			goto yy_find_action;
        -:12536:
        -:12537:
        -:12538:case 1:
    #####:12539:YY_RULE_SETUP
    #####:12540:indented_code = true; BEGIN(CODEBLOCK);
    #####:12541:	YY_BREAK
        -:12542:case 2:
    #####:12543:YY_RULE_SETUP
    #####:12544:ACTION_ECHO; yy_push_state( COMMENT );
    #####:12545:	YY_BREAK
        -:12546:case 3:
    #####:12547:YY_RULE_SETUP
    #####:12548:yy_push_state( LINEDIR );
    #####:12549:	YY_BREAK
        -:12550:case 4:
    #####:12551:YY_RULE_SETUP
    #####:12552:return SCDECL;
        -:12553:	YY_BREAK
        -:12554:case 5:
    #####:12555:YY_RULE_SETUP
    #####:12556:return XSCDECL;
        -:12557:	YY_BREAK
        -:12558:case 6:
    #####:12559:YY_RULE_SETUP
        -:12560:{
    #####:12561:			++linenum;
    #####:12562:			line_directive_out( (FILE *) 0, 1 );
    #####:12563:			indented_code = false;
    #####:12564:			BEGIN(CODEBLOCK);
        -:12565:			}
    #####:12566:	YY_BREAK
        -:12567:case 7:
    #####:12568:YY_RULE_SETUP
        -:12569:/* discard */
    #####:12570:	YY_BREAK
        -:12571:case 8:
        1:12572:YY_RULE_SETUP
        -:12573:{
        1:12574:			sectnum = 2;
        1:12575:			bracelevel = 0;
        1:12576:			mark_defs1();
        1:12577:			line_directive_out( (FILE *) 0, 1 );
        1:12578:			BEGIN(SECT2PROLOG);
        1:12579:			return SECTEND;
        -:12580:			}
        -:12581:	YY_BREAK
        -:12582:case 9:
    #####:12583:YY_RULE_SETUP
    #####:12584:yytext_is_array = false; ++linenum;
    #####:12585:	YY_BREAK
        -:12586:case 10:
    #####:12587:YY_RULE_SETUP
    #####:12588:yytext_is_array = true; ++linenum;
    #####:12589:	YY_BREAK
        -:12590:case 11:
    #####:12591:YY_RULE_SETUP
    #####:12592:BEGIN(OPTION); return OPTION_OP;
        -:12593:	YY_BREAK
        -:12594:case 12:
    #####:12595:YY_RULE_SETUP
    #####:12596:++linenum; /* ignore */
    #####:12597:	YY_BREAK
        -:12598:case 13:
    #####:12599:YY_RULE_SETUP
    #####:12600:++linenum;	/* ignore */
    #####:12601:	YY_BREAK
        -:12602:case 14:
    #####:12603:YY_RULE_SETUP
    #####:12604:synerr( _( "unrecognized '%' directive" ) );
    #####:12605:	YY_BREAK
        -:12606:case 15:
    #####:12607:YY_RULE_SETUP
        -:12608:{
    #####:12609:			strcpy( nmstr, yytext );
    #####:12610:			didadef = false;
    #####:12611:			BEGIN(PICKUPDEF);
        -:12612:			}
    #####:12613:	YY_BREAK
        -:12614:case 16:
    #####:12615:YY_RULE_SETUP
    #####:12616:RETURNNAME;
        -:12617:	YY_BREAK
        -:12618:case 17:
    #####:12619:YY_RULE_SETUP
    #####:12620:++linenum; /* allows blank lines in section 1 */
    #####:12621:	YY_BREAK
        -:12622:case 18:
    #####:12623:YY_RULE_SETUP
    #####:12624:ACTION_ECHO; ++linenum; /* maybe end of comment line */
    #####:12625:	YY_BREAK
        -:12626:
        -:12627:
        -:12628:case 19:
    #####:12629:YY_RULE_SETUP
    #####:12630:ACTION_ECHO; yy_pop_state();
    #####:12631:	YY_BREAK
        -:12632:case 20:
    #####:12633:YY_RULE_SETUP
    #####:12634:ACTION_ECHO;
    #####:12635:	YY_BREAK
        -:12636:case 21:
    #####:12637:YY_RULE_SETUP
    #####:12638:ACTION_ECHO;
    #####:12639:	YY_BREAK
        -:12640:case 22:
    #####:12641:YY_RULE_SETUP
    #####:12642:++linenum; ACTION_ECHO;
    #####:12643:	YY_BREAK
        -:12644:
        -:12645:
        -:12646:case 23:
    #####:12647:YY_RULE_SETUP
    #####:12648:yy_pop_state();
    #####:12649:	YY_BREAK
        -:12650:case 24:
    #####:12651:YY_RULE_SETUP
    #####:12652:linenum = myctoi( yytext );
    #####:12653:	YY_BREAK
        -:12654:case 25:
    #####:12655:YY_RULE_SETUP
        -:12656:{
    #####:12657:			flex_free( (void *) infilename );
    #####:12658:			infilename = copy_string( yytext + 1 );
    #####:12659:			infilename[strlen( infilename ) - 1] = '\0';
        -:12660:			}
    #####:12661:	YY_BREAK
        -:12662:case 26:
    #####:12663:YY_RULE_SETUP
        -:12664:/* ignore spurious characters */
    #####:12665:	YY_BREAK
        -:12666:
        -:12667:
        -:12668:case 27:
    #####:12669:YY_RULE_SETUP
    #####:12670:++linenum; BEGIN(INITIAL);
    #####:12671:	YY_BREAK
        -:12672:case 28:
    #####:12673:YY_RULE_SETUP
    #####:12674:ACTION_ECHO;
    #####:12675:	YY_BREAK
        -:12676:case 29:
    #####:12677:YY_RULE_SETUP
        -:12678:{
    #####:12679:			++linenum;
    #####:12680:			ACTION_ECHO;
    #####:12681:			if ( indented_code )
    #####:12682:				BEGIN(INITIAL);
        -:12683:			}
    #####:12684:	YY_BREAK
        -:12685:
        -:12686:
        -:12687:case 30:
    #####:12688:YY_RULE_SETUP
        -:12689:/* separates name and definition */
    #####:12690:	YY_BREAK
        -:12691:case 31:
    #####:12692:YY_RULE_SETUP
        -:12693:{
    #####:12694:			strcpy( (char *) nmdef, yytext );
        -:12695:
        -:12696:			/* Skip trailing whitespace. */
    #####:12697:			for ( i = strlen( (char *) nmdef ) - 1;
    #####:12698:			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
    #####:12699:			      --i )
        -:12700:				;
        -:12701:
    #####:12702:			nmdef[i + 1] = '\0';
        -:12703:
    #####:12704:			ndinstal( nmstr, nmdef );
    #####:12705:			didadef = true;
        -:12706:			}
    #####:12707:	YY_BREAK
        -:12708:case 32:
    #####:12709:YY_RULE_SETUP
        -:12710:{
    #####:12711:			if ( ! didadef )
    #####:12712:				synerr( _( "incomplete name definition" ) );
    #####:12713:			BEGIN(INITIAL);
    #####:12714:			++linenum;
        -:12715:			}
    #####:12716:	YY_BREAK
        -:12717:
        -:12718:
        -:12719:case 33:
    #####:12720:YY_RULE_SETUP
    #####:12721:++linenum; BEGIN(INITIAL);
    #####:12722:	YY_BREAK
        -:12723:case 34:
    #####:12724:YY_RULE_SETUP
    #####:12725:option_sense = true;
    #####:12726:	YY_BREAK
        -:12727:case 35:
    #####:12728:YY_RULE_SETUP
    #####:12729:return '=';
        -:12730:	YY_BREAK
        -:12731:case 36:
    #####:12732:YY_RULE_SETUP
    #####:12733:option_sense = ! option_sense;
    #####:12734:	YY_BREAK
        -:12735:case 37:
    #####:12736:YY_RULE_SETUP
    #####:12737:csize = option_sense ? 128 : 256;
    #####:12738:	YY_BREAK
        -:12739:case 38:
    #####:12740:YY_RULE_SETUP
    #####:12741:csize = option_sense ? 256 : 128;
    #####:12742:	YY_BREAK
        -:12743:case 39:
    #####:12744:YY_RULE_SETUP
    #####:12745:long_align = option_sense;
    #####:12746:	YY_BREAK
        -:12747:case 40:
    #####:12748:YY_RULE_SETUP
        -:12749:{
    #####:12750:			action_define( "YY_ALWAYS_INTERACTIVE", option_sense );
        -:12751:			}
    #####:12752:	YY_BREAK
        -:12753:case 41:
    #####:12754:YY_RULE_SETUP
    #####:12755:yytext_is_array = option_sense;
    #####:12756:	YY_BREAK
        -:12757:case 42:
    #####:12758:YY_RULE_SETUP
    #####:12759:backing_up_report = option_sense;
    #####:12760:	YY_BREAK
        -:12761:case 43:
    #####:12762:YY_RULE_SETUP
    #####:12763:interactive = ! option_sense;
    #####:12764:	YY_BREAK
        -:12765:case 44:
    #####:12766:YY_RULE_SETUP
    #####:12767:C_plus_plus = option_sense;
    #####:12768:	YY_BREAK
        -:12769:case 45:
    #####:12770:YY_RULE_SETUP
    #####:12771:caseins = ! option_sense;
    #####:12772:	YY_BREAK
        -:12773:case 46:
    #####:12774:YY_RULE_SETUP
    #####:12775:caseins = option_sense;
    #####:12776:	YY_BREAK
        -:12777:case 47:
    #####:12778:YY_RULE_SETUP
    #####:12779:ddebug = option_sense;
    #####:12780:	YY_BREAK
        -:12781:case 48:
    #####:12782:YY_RULE_SETUP
    #####:12783:spprdflt = ! option_sense;
    #####:12784:	YY_BREAK
        -:12785:case 49:
    #####:12786:YY_RULE_SETUP
    #####:12787:useecs = option_sense;
    #####:12788:	YY_BREAK
        -:12789:case 50:
    #####:12790:YY_RULE_SETUP
        -:12791:{
    #####:12792:			useecs = usemecs = false;
    #####:12793:			use_read = fullspd = true;
        -:12794:			}
    #####:12795:	YY_BREAK
        -:12796:case 51:
    #####:12797:YY_RULE_SETUP
        -:12798:{
    #####:12799:			useecs = usemecs = false;
    #####:12800:			use_read = fulltbl = true;
        -:12801:			}
    #####:12802:	YY_BREAK
        -:12803:case 52:
    #####:12804:YY_RULE_SETUP
    #####:12805:ACTION_IFDEF("YY_NO_INPUT", ! option_sense);
    #####:12806:	YY_BREAK
        -:12807:case 53:
    #####:12808:YY_RULE_SETUP
    #####:12809:interactive = option_sense;
    #####:12810:	YY_BREAK
        -:12811:case 54:
    #####:12812:YY_RULE_SETUP
    #####:12813:lex_compat = option_sense;
    #####:12814:	YY_BREAK
        -:12815:case 55:
    #####:12816:YY_RULE_SETUP
        -:12817:{
    #####:12818:			action_define( "YY_MAIN", option_sense );
    #####:12819:			do_yywrap = ! option_sense;
        -:12820:			}
    #####:12821:	YY_BREAK
        -:12822:case 56:
    #####:12823:YY_RULE_SETUP
    #####:12824:usemecs = option_sense;
    #####:12825:	YY_BREAK
        -:12826:case 57:
    #####:12827:YY_RULE_SETUP
        -:12828:{
    #####:12829:			action_define( "YY_NEVER_INTERACTIVE", option_sense );
        -:12830:			}
    #####:12831:	YY_BREAK
        -:12832:case 58:
    #####:12833:YY_RULE_SETUP
    #####:12834:performance_report += option_sense ? 1 : -1;
    #####:12835:	YY_BREAK
        -:12836:case 59:
    #####:12837:YY_RULE_SETUP
    #####:12838:yytext_is_array = ! option_sense;
    #####:12839:	YY_BREAK
        -:12840:case 60:
    #####:12841:YY_RULE_SETUP
    #####:12842:use_read = option_sense;
    #####:12843:	YY_BREAK
        -:12844:case 61:
    #####:12845:YY_RULE_SETUP
    #####:12846:reject_really_used = option_sense;
    #####:12847:	YY_BREAK
        -:12848:case 62:
    #####:12849:YY_RULE_SETUP
    #####:12850:action_define( "YY_STACK_USED", option_sense );
    #####:12851:	YY_BREAK
        -:12852:case 63:
    #####:12853:YY_RULE_SETUP
    #####:12854:do_stdinit = option_sense;
    #####:12855:	YY_BREAK
        -:12856:case 64:
    #####:12857:YY_RULE_SETUP
    #####:12858:use_stdout = option_sense;
    #####:12859:	YY_BREAK
        -:12860:case 65:
    #####:12861:YY_RULE_SETUP
    #####:12862:ACTION_IFDEF("YY_NO_UNPUT", ! option_sense);
    #####:12863:	YY_BREAK
        -:12864:case 66:
    #####:12865:YY_RULE_SETUP
    #####:12866:printstats = option_sense;
    #####:12867:	YY_BREAK
        -:12868:case 67:
    #####:12869:YY_RULE_SETUP
    #####:12870:nowarn = ! option_sense;
    #####:12871:	YY_BREAK
        -:12872:case 68:
    #####:12873:YY_RULE_SETUP
    #####:12874:do_yylineno = option_sense;
    #####:12875:	YY_BREAK
        -:12876:case 69:
    #####:12877:YY_RULE_SETUP
    #####:12878:yymore_really_used = option_sense;
    #####:12879:	YY_BREAK
        -:12880:case 70:
    #####:12881:YY_RULE_SETUP
    #####:12882:do_yywrap = option_sense;
    #####:12883:	YY_BREAK
        -:12884:case 71:
    #####:12885:YY_RULE_SETUP
    #####:12886:ACTION_IFDEF("YY_NO_PUSH_STATE", ! option_sense);
    #####:12887:	YY_BREAK
        -:12888:case 72:
    #####:12889:YY_RULE_SETUP
    #####:12890:ACTION_IFDEF("YY_NO_POP_STATE", ! option_sense);
    #####:12891:	YY_BREAK
        -:12892:case 73:
    #####:12893:YY_RULE_SETUP
    #####:12894:ACTION_IFDEF("YY_NO_TOP_STATE", ! option_sense);
    #####:12895:	YY_BREAK
        -:12896:case 74:
    #####:12897:YY_RULE_SETUP
    #####:12898:ACTION_IFDEF("YY_NO_SCAN_BUFFER", ! option_sense);
    #####:12899:	YY_BREAK
        -:12900:case 75:
    #####:12901:YY_RULE_SETUP
    #####:12902:ACTION_IFDEF("YY_NO_SCAN_BYTES", ! option_sense);
    #####:12903:	YY_BREAK
        -:12904:case 76:
    #####:12905:YY_RULE_SETUP
    #####:12906:ACTION_IFDEF("YY_NO_SCAN_STRING", ! option_sense);
    #####:12907:	YY_BREAK
        -:12908:case 77:
    #####:12909:YY_RULE_SETUP
    #####:12910:return OPT_OUTFILE;
        -:12911:	YY_BREAK
        -:12912:case 78:
    #####:12913:YY_RULE_SETUP
    #####:12914:return OPT_PREFIX;
        -:12915:	YY_BREAK
        -:12916:case 79:
    #####:12917:YY_RULE_SETUP
    #####:12918:return OPT_YYCLASS;
        -:12919:	YY_BREAK
        -:12920:case 80:
    #####:12921:YY_RULE_SETUP
        -:12922:{
    #####:12923:			strcpy( nmstr, yytext + 1 );
    #####:12924:			nmstr[strlen( nmstr ) - 1] = '\0';
    #####:12925:			return NAME;
        -:12926:			}
        -:12927:	YY_BREAK
        -:12928:case 81:
    #####:12929:YY_RULE_SETUP
        -:12930:{
    #####:12931:			format_synerr( _( "unrecognized %%option: %s" ),
        -:12932:				yytext );
    #####:12933:			BEGIN(RECOVER);
        -:12934:			}
    #####:12935:	YY_BREAK
        -:12936:
        -:12937:case 82:
    #####:12938:YY_RULE_SETUP
    #####:12939:++linenum; BEGIN(INITIAL);
    #####:12940:	YY_BREAK
        -:12941:
        -:12942:case 83:
    #####:12943:YY_RULE_SETUP
    #####:12944:++bracelevel; yyless( 2 );	/* eat only %{ */
    #####:12945:	YY_BREAK
        -:12946:case 84:
    #####:12947:YY_RULE_SETUP
    #####:12948:--bracelevel; yyless( 2 );	/* eat only %} */
    #####:12949:	YY_BREAK
        -:12950:case 85:
    #####:12951:YY_RULE_SETUP
    #####:12952:ACTION_ECHO;	/* indented code in prolog */
    #####:12953:	YY_BREAK
        -:12954:case 86:
        1:12955:YY_RULE_SETUP
        -:12956:{	/* non-indented code */
        1:12957:			if ( bracelevel <= 0 )
        -:12958:				{ /* not in %{ ... %} */
        1:12959:				yyless( 0 );	/* put it all back */
        1:12960:				yy_set_bol( 1 );
        1:12961:				mark_prolog();
        1:12962:				BEGIN(SECT2);
        -:12963:				}
        -:12964:			else
    #####:12965:				ACTION_ECHO;
        -:12966:			}
        1:12967:	YY_BREAK
        -:12968:case 87:
    #####:12969:YY_RULE_SETUP
    #####:12970:ACTION_ECHO;
    #####:12971:	YY_BREAK
        -:12972:case 88:
        1:12973:YY_RULE_SETUP
        1:12974:++linenum; ACTION_ECHO;
        1:12975:	YY_BREAK
        -:12976:case YY_STATE_EOF(SECT2PROLOG):
        -:12977:{
    #####:12978:			mark_prolog();
    #####:12979:			sectnum = 0;
    #####:12980:			yyterminate(); /* to stop the parser */
        -:12981:			}
        -:12982:	YY_BREAK
        -:12983:
        -:12984:
        -:12985:case 89:
    #####:12986:YY_RULE_SETUP
    #####:12987:++linenum; /* allow blank lines in section 2 */
    #####:12988:	YY_BREAK
        -:12989:case 90:
    #####:12990:YY_RULE_SETUP
        -:12991:{
    #####:12992:			indented_code = false;
    #####:12993:			doing_codeblock = true;
    #####:12994:			bracelevel = 1;
    #####:12995:			BEGIN(PERCENT_BRACE_ACTION);
        -:12996:			}
    #####:12997:	YY_BREAK
        -:12998:case 91:
    #####:12999:YY_RULE_SETUP
    #####:13000:BEGIN(SC); return '<';
        -:13001:	YY_BREAK
        -:13002:case 92:
        1:13003:YY_RULE_SETUP
        1:13004:return '^';
        -:13005:	YY_BREAK
        -:13006:case 93:
    #####:13007:YY_RULE_SETUP
    #####:13008:BEGIN(QUOTE); return '"';
        -:13009:	YY_BREAK
        -:13010:case 94:
    #####:13011:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:13012:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:13013:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:13014:YY_RULE_SETUP
    #####:13015:BEGIN(NUM); return '{';
        -:13016:	YY_BREAK
        -:13017:case 95:
        1:13018:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
        1:13019:yy_c_buf_p = yy_cp = yy_bp + 1;
        1:13020:YY_DO_BEFORE_ACTION; /* set up yytext again */
        1:13021:YY_RULE_SETUP
        1:13022:return '$';
        -:13023:	YY_BREAK
        -:13024:case 96:
    #####:13025:YY_RULE_SETUP
        -:13026:{
    #####:13027:			bracelevel = 1;
    #####:13028:			BEGIN(PERCENT_BRACE_ACTION);
        -:13029:
    #####:13030:			if ( in_rule )
        -:13031:				{
    #####:13032:				doing_rule_action = true;
    #####:13033:				in_rule = false;
    #####:13034:				return '\n';
        -:13035:				}
        -:13036:			}
    #####:13037:	YY_BREAK
        -:13038:case 97:
    #####:13039:YY_RULE_SETUP
    #####:13040:continued_action = true; ++linenum; return '\n';
        -:13041:	YY_BREAK
        -:13042:case 98:
    #####:13043:YY_RULE_SETUP
        -:13044:{
    #####:13045:			yyless( yyleng - 2 );	/* put back '/', '*' */
    #####:13046:			bracelevel = 0;
    #####:13047:			continued_action = false;
    #####:13048:			BEGIN(ACTION);
        -:13049:			}
    #####:13050:	YY_BREAK
        -:13051:case 99:
    #####:13052:YY_RULE_SETUP
        -:13053:/* allow indented rules */
    #####:13054:	YY_BREAK
        -:13055:case 100:
        6:13056:YY_RULE_SETUP
        -:13057:{
        -:13058:			/* This rule is separate from the one below because
        -:13059:			 * otherwise we get variable trailing context, so
        -:13060:			 * we can't build the scanner using -{f,F}.
        -:13061:			 */
        6:13062:			bracelevel = 0;
        6:13063:			continued_action = false;
        6:13064:			BEGIN(ACTION);
        -:13065:
        6:13066:			if ( in_rule )
        -:13067:				{
        6:13068:				doing_rule_action = true;
        6:13069:				in_rule = false;
        6:13070:				return '\n';
        -:13071:				}
        -:13072:			}
    #####:13073:	YY_BREAK
        -:13074:case 101:
    #####:13075:YY_RULE_SETUP
        -:13076:{
    #####:13077:			bracelevel = 0;
    #####:13078:			continued_action = false;
    #####:13079:			BEGIN(ACTION);
    #####:13080:			unput( '\n' );	/* so <ACTION> sees it */
        -:13081:
    #####:13082:			if ( in_rule )
        -:13083:				{
    #####:13084:				doing_rule_action = true;
    #####:13085:				in_rule = false;
    #####:13086:				return '\n';
        -:13087:				}
        -:13088:			}
    #####:13089:	YY_BREAK
        -:13090:case 102:
        -:13091:case 103:
    #####:13092:YY_RULE_SETUP
    #####:13093:return EOF_OP;
        -:13094:	YY_BREAK
        -:13095:case 104:
    #####:13096:YY_RULE_SETUP
        -:13097:{
    #####:13098:			sectnum = 3;
    #####:13099:			BEGIN(SECT3);
    #####:13100:			yyterminate(); /* to stop the parser */
        -:13101:			}
        -:13102:	YY_BREAK
        -:13103:case 105:
        1:13104:YY_RULE_SETUP
        -:13105:{
        -:13106:			int cclval;
        -:13107:
        1:13108:			strcpy( nmstr, yytext );
        -:13109:
        -:13110:			/* Check to see if we've already encountered this
        -:13111:			 * ccl.
        -:13112:			 */
        1:13113:			if ( (cclval = ccllookup( (Char *) nmstr )) != 0 )
        -:13114:				{
    #####:13115:				if ( input() != ']' )
    #####:13116:					synerr( _( "bad character class" ) );
        -:13117:
    #####:13118:				yylval = cclval;
    #####:13119:				++cclreuse;
    #####:13120:				return PREVCCL;
        -:13121:				}
        -:13122:			else
        -:13123:				{
        -:13124:				/* We fudge a bit.  We know that this ccl will
        -:13125:				 * soon be numbered as lastccl + 1 by cclinit.
        -:13126:				 */
        1:13127:				cclinstal( (Char *) nmstr, lastccl + 1 );
        -:13128:
        -:13129:				/* Push back everything but the leading bracket
        -:13130:				 * so the ccl can be rescanned.
        -:13131:				 */
        1:13132:				yyless( 1 );
        -:13133:
        1:13134:				BEGIN(FIRSTCCL);
        1:13135:				return '[';
        -:13136:				}
        -:13137:			}
        -:13138:	YY_BREAK
        -:13139:case 106:
    #####:13140:YY_RULE_SETUP
        -:13141:{
        -:13142:			register Char *nmdefptr;
        -:13143:			Char *ndlookup();
        -:13144:
    #####:13145:			strcpy( nmstr, yytext + 1 );
    #####:13146:			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
        -:13147:
    #####:13148:			if ( (nmdefptr = ndlookup( nmstr )) == 0 )
    #####:13149:				format_synerr(
        -:13150:					_( "undefined definition {%s}" ),
        -:13151:						nmstr );
        -:13152:
        -:13153:			else
        -:13154:				{ /* push back name surrounded by ()'s */
    #####:13155:				int len = strlen( (char *) nmdefptr );
        -:13156:
    #####:13157:				if ( lex_compat || nmdefptr[0] == '^' ||
    #####:13158:				     (len > 0 && nmdefptr[len - 1] == '$') )
        -:13159:					{ /* don't use ()'s after all */
    #####:13160:					PUT_BACK_STRING((char *) nmdefptr, 0);
        -:13161:
    #####:13162:					if ( nmdefptr[0] == '^' )
    #####:13163:						BEGIN(CARETISBOL);
        -:13164:					}
        -:13165:
        -:13166:				else
        -:13167:					{
    #####:13168:					unput(')');
    #####:13169:					PUT_BACK_STRING((char *) nmdefptr, 0);
    #####:13170:					unput('(');
        -:13171:					}
        -:13172:				}
        -:13173:			}
    #####:13174:	YY_BREAK
        -:13175:case 107:
        7:13176:YY_RULE_SETUP
        7:13177:return (unsigned char) yytext[0];
        -:13178:	YY_BREAK
        -:13179:case 108:
       18:13180:YY_RULE_SETUP
       18:13181:RETURNCHAR;
        -:13182:	YY_BREAK
        -:13183:
        -:13184:
        -:13185:case 109:
    #####:13186:YY_RULE_SETUP
    #####:13187:return (unsigned char) yytext[0];
        -:13188:	YY_BREAK
        -:13189:case 110:
    #####:13190:YY_RULE_SETUP
    #####:13191:BEGIN(SECT2); return '>';
        -:13192:	YY_BREAK
        -:13193:case 111:
    #####:13194:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:13195:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:13196:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:13197:YY_RULE_SETUP
    #####:13198:BEGIN(CARETISBOL); return '>';
        -:13199:	YY_BREAK
        -:13200:case 112:
    #####:13201:YY_RULE_SETUP
    #####:13202:RETURNNAME;
        -:13203:	YY_BREAK
        -:13204:case 113:
    #####:13205:YY_RULE_SETUP
        -:13206:{
    #####:13207:			format_synerr( _( "bad <start condition>: %s" ),
        -:13208:				yytext );
        -:13209:			}
    #####:13210:	YY_BREAK
        -:13211:
        -:13212:case 114:
    #####:13213:YY_RULE_SETUP
    #####:13214:BEGIN(SECT2); return '^';
        -:13215:	YY_BREAK
        -:13216:
        -:13217:case 115:
    #####:13218:YY_RULE_SETUP
    #####:13219:RETURNCHAR;
        -:13220:	YY_BREAK
        -:13221:case 116:
    #####:13222:YY_RULE_SETUP
    #####:13223:BEGIN(SECT2); return '"';
        -:13224:	YY_BREAK
        -:13225:case 117:
    #####:13226:YY_RULE_SETUP
        -:13227:{
    #####:13228:			synerr( _( "missing quote" ) );
    #####:13229:			BEGIN(SECT2);
    #####:13230:			++linenum;
    #####:13231:			return '"';
        -:13232:			}
        -:13233:	YY_BREAK
        -:13234:
        -:13235:
        -:13236:case 118:
    #####:13237:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:13238:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:13239:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:13240:YY_RULE_SETUP
    #####:13241:BEGIN(CCL); return '^';
        -:13242:	YY_BREAK
        -:13243:case 119:
    #####:13244:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:13245:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:13246:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:13247:YY_RULE_SETUP
    #####:13248:return '^';
        -:13249:	YY_BREAK
        -:13250:case 120:
        1:13251:YY_RULE_SETUP
        1:13252:BEGIN(CCL); RETURNCHAR;
        -:13253:	YY_BREAK
        -:13254:
        -:13255:
        -:13256:case 121:
    #####:13257:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:13258:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:13259:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:13260:YY_RULE_SETUP
    #####:13261:return '-';
        -:13262:	YY_BREAK
        -:13263:case 122:
        2:13264:YY_RULE_SETUP
        2:13265:RETURNCHAR;
        -:13266:	YY_BREAK
        -:13267:case 123:
        1:13268:YY_RULE_SETUP
        1:13269:BEGIN(SECT2); return ']';
        -:13270:	YY_BREAK
        -:13271:case 124:
    #####:13272:YY_RULE_SETUP
        -:13273:{
    #####:13274:			synerr( _( "bad character class" ) );
    #####:13275:			BEGIN(SECT2);
    #####:13276:			return ']';
        -:13277:			}
        -:13278:	YY_BREAK
        -:13279:
        -:13280:
        -:13281:case 125:
    #####:13282:YY_RULE_SETUP
    #####:13283:BEGIN(CCL); return CCE_ALNUM;
        -:13284:	YY_BREAK
        -:13285:case 126:
    #####:13286:YY_RULE_SETUP
    #####:13287:BEGIN(CCL); return CCE_ALPHA;
        -:13288:	YY_BREAK
        -:13289:case 127:
    #####:13290:YY_RULE_SETUP
    #####:13291:BEGIN(CCL); return CCE_BLANK;
        -:13292:	YY_BREAK
        -:13293:case 128:
    #####:13294:YY_RULE_SETUP
    #####:13295:BEGIN(CCL); return CCE_CNTRL;
        -:13296:	YY_BREAK
        -:13297:case 129:
    #####:13298:YY_RULE_SETUP
    #####:13299:BEGIN(CCL); return CCE_DIGIT;
        -:13300:	YY_BREAK
        -:13301:case 130:
    #####:13302:YY_RULE_SETUP
    #####:13303:BEGIN(CCL); return CCE_GRAPH;
        -:13304:	YY_BREAK
        -:13305:case 131:
    #####:13306:YY_RULE_SETUP
    #####:13307:BEGIN(CCL); return CCE_LOWER;
        -:13308:	YY_BREAK
        -:13309:case 132:
    #####:13310:YY_RULE_SETUP
    #####:13311:BEGIN(CCL); return CCE_PRINT;
        -:13312:	YY_BREAK
        -:13313:case 133:
    #####:13314:YY_RULE_SETUP
    #####:13315:BEGIN(CCL); return CCE_PUNCT;
        -:13316:	YY_BREAK
        -:13317:case 134:
    #####:13318:YY_RULE_SETUP
    #####:13319:BEGIN(CCL); return CCE_SPACE;
        -:13320:	YY_BREAK
        -:13321:case 135:
    #####:13322:YY_RULE_SETUP
    #####:13323:BEGIN(CCL); return CCE_UPPER;
        -:13324:	YY_BREAK
        -:13325:case 136:
    #####:13326:YY_RULE_SETUP
    #####:13327:BEGIN(CCL); return CCE_XDIGIT;
        -:13328:	YY_BREAK
        -:13329:case 137:
    #####:13330:YY_RULE_SETUP
        -:13331:{
    #####:13332:			format_synerr(
        -:13333:				_( "bad character class expression: %s" ),
        -:13334:					yytext );
    #####:13335:			BEGIN(CCL); return CCE_ALNUM;
        -:13336:			}
        -:13337:	YY_BREAK
        -:13338:
        -:13339:
        -:13340:case 138:
    #####:13341:YY_RULE_SETUP
        -:13342:{
        -:13343:#ifndef F_B41
    #####:13344:			yylval = myctoi( yytext );
        -:13345:#else
        -:13346:			yylval = myctoi (!  yytext );
        -:13347:#endif
    #####:13348:			return NUMBER;
        -:13349:			}
        -:13350:	YY_BREAK
        -:13351:case 139:
    #####:13352:YY_RULE_SETUP
    #####:13353:return ',';
        -:13354:	YY_BREAK
        -:13355:case 140:
    #####:13356:YY_RULE_SETUP
    #####:13357:BEGIN(SECT2); return '}';
        -:13358:	YY_BREAK
        -:13359:case 141:
    #####:13360:YY_RULE_SETUP
        -:13361:{
    #####:13362:			synerr( _( "bad character inside {}'s" ) );
    #####:13363:			BEGIN(SECT2);
    #####:13364:			return '}';
        -:13365:			}
        -:13366:	YY_BREAK
        -:13367:case 142:
    #####:13368:YY_RULE_SETUP
        -:13369:{
    #####:13370:			synerr( _( "missing }" ) );
    #####:13371:			BEGIN(SECT2);
    #####:13372:			++linenum;
    #####:13373:			return '}';
        -:13374:			}
        -:13375:	YY_BREAK
        -:13376:
        -:13377:
        -:13378:case 143:
    #####:13379:YY_RULE_SETUP
    #####:13380:bracelevel = 0;
    #####:13381:	YY_BREAK
        -:13382:case 144:
    #####:13383:YY_RULE_SETUP
    #####:13384:ACTION_ECHO; yy_push_state( COMMENT );
    #####:13385:	YY_BREAK
        -:13386:
        -:13387:case 145:
    #####:13388:YY_RULE_SETUP
        -:13389:{
    #####:13390:			ACTION_ECHO;
    #####:13391:			CHECK_REJECT(yytext);
        -:13392:			}
    #####:13393:	YY_BREAK
        -:13394:case 146:
    #####:13395:YY_RULE_SETUP
        -:13396:{
    #####:13397:			ACTION_ECHO;
    #####:13398:			CHECK_YYMORE(yytext);
        -:13399:			}
    #####:13400:	YY_BREAK
        -:13401:
        -:13402:case 147:
    #####:13403:YY_RULE_SETUP
    #####:13404:ACTION_ECHO;
    #####:13405:	YY_BREAK
        -:13406:case 148:
    #####:13407:YY_RULE_SETUP
        -:13408:{
    #####:13409:			++linenum;
    #####:13410:			ACTION_ECHO;
    #####:13411:			if ( bracelevel == 0 ||
    #####:13412:			     (doing_codeblock && indented_code) )
        -:13413:				{
    #####:13414:				if ( doing_rule_action )
    #####:13415:					add_action( "\tYY_BREAK\n" );
        -:13416:
    #####:13417:				doing_rule_action = doing_codeblock = false;
    #####:13418:				BEGIN(SECT2);
        -:13419:				}
        -:13420:			}
    #####:13421:	YY_BREAK
        -:13422:
        -:13423:/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
        -:13424:
        -:13425:case 149:
    #####:13426:YY_RULE_SETUP
    #####:13427:ACTION_ECHO; ++bracelevel;
    #####:13428:	YY_BREAK
        -:13429:case 150:
    #####:13430:YY_RULE_SETUP
    #####:13431:ACTION_ECHO; --bracelevel;
    #####:13432:	YY_BREAK
        -:13433:case 151:
       18:13434:YY_RULE_SETUP
       18:13435:ACTION_ECHO;
       18:13436:	YY_BREAK
        -:13437:case 152:
       12:13438:YY_RULE_SETUP
       12:13439:ACTION_ECHO;
       12:13440:	YY_BREAK
        -:13441:case 153:
    #####:13442:YY_RULE_SETUP
    #####:13443:ACTION_ECHO; /* character constant */
    #####:13444:	YY_BREAK
        -:13445:case 154:
        6:13446:YY_RULE_SETUP
        6:13447:ACTION_ECHO; BEGIN(ACTION_STRING);
        6:13448:	YY_BREAK
        -:13449:case 155:
        6:13450:YY_RULE_SETUP
        -:13451:{
        6:13452:			++linenum;
        6:13453:			ACTION_ECHO;
        6:13454:			if ( bracelevel == 0 )
        -:13455:				{
        6:13456:				if ( doing_rule_action )
        6:13457:					add_action( "\tYY_BREAK\n" );
        -:13458:
        6:13459:				doing_rule_action = false;
        6:13460:				BEGIN(SECT2);
        -:13461:				}
        -:13462:			}
        6:13463:	YY_BREAK
        -:13464:case 156:
    #####:13465:YY_RULE_SETUP
    #####:13466:ACTION_ECHO;
    #####:13467:	YY_BREAK
        -:13468:
        -:13469:
        -:13470:case 157:
        6:13471:YY_RULE_SETUP
        6:13472:ACTION_ECHO;
        6:13473:	YY_BREAK
        -:13474:case 158:
        6:13475:YY_RULE_SETUP
        6:13476:ACTION_ECHO;
        6:13477:	YY_BREAK
        -:13478:case 159:
    #####:13479:YY_RULE_SETUP
    #####:13480:++linenum; ACTION_ECHO;
    #####:13481:	YY_BREAK
        -:13482:case 160:
        6:13483:YY_RULE_SETUP
        6:13484:ACTION_ECHO; BEGIN(ACTION);
        6:13485:	YY_BREAK
        -:13486:case 161:
    #####:13487:YY_RULE_SETUP
    #####:13488:ACTION_ECHO;
    #####:13489:	YY_BREAK
        -:13490:
        -:13491:case YY_STATE_EOF(COMMENT):
        -:13492:case YY_STATE_EOF(ACTION):
        -:13493:case YY_STATE_EOF(ACTION_STRING):
        -:13494:{
    #####:13495:			synerr( _( "EOF encountered inside an action" ) );
    #####:13496:			yyterminate();
        -:13497:			}
        -:13498:	YY_BREAK
        -:13499:case 162:
    #####:13500:YY_RULE_SETUP
        -:13501:{
    #####:13502:			yylval = myesc( (Char *) yytext );
        -:13503:
    #####:13504:			if ( YY_START == FIRSTCCL )
    #####:13505:				BEGIN(CCL);
        -:13506:
    #####:13507:			return CHAR;
        -:13508:			}
        -:13509:	YY_BREAK
        -:13510:
        -:13511:case 163:
    #####:13512:YY_RULE_SETUP
    #####:13513:ECHO;
    #####:13514:	YY_BREAK
        -:13515:case YY_STATE_EOF(SECT3):
    #####:13516:sectnum = 0; yyterminate();
        -:13517:	YY_BREAK
        -:13518:
        -:13519:case 164:
    #####:13520:YY_RULE_SETUP
    #####:13521:format_synerr( _( "bad character: %s" ), yytext );
    #####:13522:	YY_BREAK
        -:13523:case 165:
    #####:13524:YY_RULE_SETUP
    #####:13525:YY_FATAL_ERROR( "flex scanner jammed" );
    #####:13526:	YY_BREAK
        -:13527:case YY_STATE_EOF(INITIAL):
        -:13528:case YY_STATE_EOF(SECT2):
        -:13529:case YY_STATE_EOF(CODEBLOCK):
        -:13530:case YY_STATE_EOF(PICKUPDEF):
        -:13531:case YY_STATE_EOF(SC):
        -:13532:case YY_STATE_EOF(CARETISBOL):
        -:13533:case YY_STATE_EOF(NUM):
        -:13534:case YY_STATE_EOF(QUOTE):
        -:13535:case YY_STATE_EOF(FIRSTCCL):
        -:13536:case YY_STATE_EOF(CCL):
        -:13537:case YY_STATE_EOF(RECOVER):
        -:13538:case YY_STATE_EOF(PERCENT_BRACE_ACTION):
        -:13539:case YY_STATE_EOF(OPTION):
        -:13540:case YY_STATE_EOF(LINEDIR):
        1:13541:	yyterminate();
        -:13542:
        -:13543:	case YY_END_OF_BUFFER:
        -:13544:		{
        -:13545:		/* Amount of text matched not including the EOB char. */
        2:13546:		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
        -:13547:
        -:13548:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
        2:13549:		*yy_cp = yy_hold_char;
        -:13550:		YY_RESTORE_YY_MORE_OFFSET
        -:13551:
        2:13552:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
        -:13553:			{
        -:13554:			/* We're scanning a new file or input source.  It's
        -:13555:			 * possible that this happened because the user
        -:13556:			 * just pointed yyin at a new source and called
        -:13557:			 * yylex().  If so, then we have to assure
        -:13558:			 * consistency between yy_current_buffer and our
        -:13559:			 * globals.  Here is the right place to do so, because
        -:13560:			 * this is the first action (other than possibly a
        -:13561:			 * back-up) that will match for the new input source.
        -:13562:			 */
        1:13563:			yy_n_chars = yy_current_buffer->yy_n_chars;
        1:13564:			yy_current_buffer->yy_input_file = yyin;
        1:13565:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
        -:13566:			}
        -:13567:
        -:13568:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -:13569:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -:13570:		 * already have been incremented past the NUL character
        -:13571:		 * (since all states make transitions on EOB to the
        -:13572:		 * end-of-buffer state).  Contrast this with the test
        -:13573:		 * in input().
        -:13574:		 */
        2:13575:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
        -:13576:			{ /* This was really a NUL. */
        -:13577:			yy_state_type yy_next_state;
        -:13578:
    #####:13579:			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
        -:13580:
    #####:13581:			yy_current_state = yy_get_previous_state();
        -:13582:
        -:13583:			/* Okay, we're now positioned to make the NUL
        -:13584:			 * transition.  We couldn't have
        -:13585:			 * yy_get_previous_state() go ahead and do it
        -:13586:			 * for us because it doesn't know how to deal
        -:13587:			 * with the possibility of jamming (and we don't
        -:13588:			 * want to build jamming into it because then it
        -:13589:			 * will run more slowly).
        -:13590:			 */
        -:13591:
    #####:13592:			yy_next_state = yy_try_NUL_trans( yy_current_state );
        -:13593:
    #####:13594:			yy_bp = yytext_ptr + YY_MORE_ADJ;
        -:13595:
    #####:13596:			if ( yy_next_state )
        -:13597:				{
        -:13598:				/* Consume the NUL. */
    #####:13599:				yy_cp = ++yy_c_buf_p;
    #####:13600:				yy_current_state = yy_next_state;
    #####:13601:				goto yy_match;
        -:13602:				}
        -:13603:
        -:13604:			else
        -:13605:				{
    #####:13606:				yy_cp = yy_c_buf_p;
    #####:13607:				goto yy_find_action;
        -:13608:				}
        -:13609:			}
        -:13610:
        2:13611:		else switch ( yy_get_next_buffer() )
        -:13612:			{
        -:13613:			case EOB_ACT_END_OF_FILE:
        -:13614:				{
        1:13615:				yy_did_buffer_switch_on_eof = 0;
        -:13616:
        1:13617:				if ( yywrap() )
        -:13618:					{
        -:13619:					/* Note: because we've taken care in
        -:13620:					 * yy_get_next_buffer() to have set up
        -:13621:					 * yytext, we can now set up
        -:13622:					 * yy_c_buf_p so that if some total
        -:13623:					 * hoser (like flex itself) wants to
        -:13624:					 * call the scanner after we return the
        -:13625:					 * YY_NULL, it'll still work - another
        -:13626:					 * YY_NULL will get returned.
        -:13627:					 */
        1:13628:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
        -:13629:
        1:13630:					yy_act = YY_STATE_EOF(YY_START);
        1:13631:					goto do_action;
        -:13632:					}
        -:13633:
        -:13634:				else
        -:13635:					{
    #####:13636:					if ( ! yy_did_buffer_switch_on_eof )
    #####:13637:						YY_NEW_FILE;
        -:13638:					}
    #####:13639:				break;
        -:13640:				}
        -:13641:
        -:13642:			case EOB_ACT_CONTINUE_SCAN:
        1:13643:				yy_c_buf_p =
        1:13644:					yytext_ptr + yy_amount_of_matched_text;
        -:13645:
        1:13646:				yy_current_state = yy_get_previous_state();
        -:13647:
        1:13648:				yy_cp = yy_c_buf_p;
        1:13649:				yy_bp = yytext_ptr + YY_MORE_ADJ;
        1:13650:				goto yy_match;
        -:13651:
        -:13652:			case EOB_ACT_LAST_MATCH:
    #####:13653:				yy_c_buf_p =
    #####:13654:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
        -:13655:
    #####:13656:				yy_current_state = yy_get_previous_state();
        -:13657:
    #####:13658:				yy_cp = yy_c_buf_p;
    #####:13659:				yy_bp = yytext_ptr + YY_MORE_ADJ;
    #####:13660:				goto yy_find_action;
        -:13661:			}
    #####:13662:		break;
        -:13663:		}
        -:13664:
        -:13665:	default:
    #####:13666:		YY_FATAL_ERROR(
        -:13667:			"fatal flex scanner internal error--no action found" );
        -:13668:	} /* end of action switch */
       62:13669:		} /* end of scanning one token */
        -:13670:	} /* end of yylex */
        -:13671:
        -:13672:
        -:13673:/* yy_get_next_buffer - try to read in a new buffer
        -:13674: *
        -:13675: * Returns a code representing an action:
        -:13676: *	EOB_ACT_LAST_MATCH -
        -:13677: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -:13678: *	EOB_ACT_END_OF_FILE - end of file
        -:13679: */
        -:13680:
        2:13681:static int yy_get_next_buffer()
        -:13682:	{
        2:13683:	register char *dest = yy_current_buffer->yy_ch_buf;
        2:13684:	register char *source = yytext_ptr;
        -:13685:	register int number_to_move, i;
        -:13686:	int ret_val;
        -:13687:
        2:13688:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
    #####:13689:		YY_FATAL_ERROR(
        -:13690:		"fatal flex scanner internal error--end of buffer missed" );
        -:13691:
        2:13692:	if ( yy_current_buffer->yy_fill_buffer == 0 )
        -:13693:		{ /* Don't try to fill the buffer, so this is an EOF. */
    #####:13694:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
        -:13695:			{
        -:13696:			/* We matched a single character, the EOB, so
        -:13697:			 * treat this as a final EOF.
        -:13698:			 */
    #####:13699:			return EOB_ACT_END_OF_FILE;
        -:13700:			}
        -:13701:
        -:13702:		else
        -:13703:			{
        -:13704:			/* We matched some text prior to the EOB, first
        -:13705:			 * process it.
        -:13706:			 */
    #####:13707:			return EOB_ACT_LAST_MATCH;
        -:13708:			}
        -:13709:		}
        -:13710:
        -:13711:	/* Try to read more data. */
        -:13712:
        -:13713:	/* First move last chars to start of buffer. */
        2:13714:	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
        -:13715:
        2:13716:	for ( i = 0; i < number_to_move; ++i )
    #####:13717:		*(dest++) = *(source++);
        -:13718:
        2:13719:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        -:13720:		/* don't do the read, it's not guaranteed to return an EOF,
        -:13721:		 * just force an EOF
        -:13722:		 */
    #####:13723:		yy_n_chars = 0;
        -:13724:
        -:13725:	else
        -:13726:		{
        2:13727:		int num_to_read =
        2:13728:			yy_current_buffer->yy_buf_size - number_to_move - 1;
        -:13729:
        4:13730:		while ( num_to_read <= 0 )
        -:13731:			{ /* Not enough room in the buffer - grow it. */
        -:13732:#ifdef YY_USES_REJECT
        -:13733:			YY_FATAL_ERROR(
        -:13734:"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
        -:13735:#else
        -:13736:
        -:13737:			/* just a shorter name for the current buffer */
    #####:13738:			YY_BUFFER_STATE b = yy_current_buffer;
        -:13739:
    #####:13740:			int yy_c_buf_p_offset =
    #####:13741:				(int) (yy_c_buf_p - b->yy_ch_buf);
        -:13742:
    #####:13743:			if ( b->yy_is_our_buffer )
        -:13744:				{
    #####:13745:				int new_size = b->yy_buf_size * 2;
        -:13746:
    #####:13747:				if ( new_size <= 0 )
    #####:13748:					b->yy_buf_size += b->yy_buf_size / 8;
        -:13749:				else
    #####:13750:					b->yy_buf_size *= 2;
        -:13751:
    #####:13752:				b->yy_ch_buf = (char *)
        -:13753:					/* Include room in for 2 EOB chars. */
    #####:13754:					yy_flex_realloc( (void *) b->yy_ch_buf,
    #####:13755:							 b->yy_buf_size + 2 );
        -:13756:				}
        -:13757:			else
        -:13758:				/* Can't grow it, we don't own it. */
    #####:13759:				b->yy_ch_buf = 0;
        -:13760:
    #####:13761:			if ( ! b->yy_ch_buf )
    #####:13762:				YY_FATAL_ERROR(
        -:13763:				"fatal error - scanner input buffer overflow" );
        -:13764:
    #####:13765:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -:13766:
    #####:13767:			num_to_read = yy_current_buffer->yy_buf_size -
    #####:13768:						number_to_move - 1;
        -:13769:#endif
        -:13770:			}
        -:13771:
        2:13772:		if ( num_to_read > YY_READ_BUF_SIZE )
        2:13773:			num_to_read = YY_READ_BUF_SIZE;
        -:13774:
        -:13775:		/* Read in more data. */
        2:13776:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
        -:13777:			yy_n_chars, num_to_read );
        -:13778:		}
        -:13779:
        2:13780:	if ( yy_n_chars == 0 )
        -:13781:		{
        1:13782:		if ( number_to_move == YY_MORE_ADJ )
        -:13783:			{
        1:13784:			ret_val = EOB_ACT_END_OF_FILE;
        1:13785:			yyrestart( yyin );
        -:13786:			}
        -:13787:
        -:13788:		else
        -:13789:			{
    #####:13790:			ret_val = EOB_ACT_LAST_MATCH;
    #####:13791:			yy_current_buffer->yy_buffer_status =
        -:13792:				YY_BUFFER_EOF_PENDING;
        -:13793:			}
        -:13794:		}
        -:13795:
        -:13796:	else
        1:13797:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -:13798:
        2:13799:	yy_n_chars += number_to_move;
        2:13800:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        2:13801:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -:13802:
        2:13803:	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
        -:13804:
        2:13805:	return ret_val;
        -:13806:	}
        -:13807:
        -:13808:
        -:13809:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -:13810:
        1:13811:static yy_state_type yy_get_previous_state()
        -:13812:	{
        -:13813:	register yy_state_type yy_current_state;
        -:13814:	register char *yy_cp;
        -:13815:
        1:13816:	yy_current_state = yy_start;
        1:13817:	yy_current_state += YY_AT_BOL();
        -:13818:
        1:13819:	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        -:13820:		{
    #####:13821:		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    #####:13822:		if ( yy_accept[yy_current_state] )
        -:13823:			{
    #####:13824:			yy_last_accepting_state = yy_current_state;
    #####:13825:			yy_last_accepting_cpos = yy_cp;
        -:13826:			}
    #####:13827:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:13828:			{
    #####:13829:			yy_current_state = (int) yy_def[yy_current_state];
    #####:13830:			if ( yy_current_state >= 769 )
    #####:13831:				yy_c = yy_meta[(unsigned int) yy_c];
        -:13832:			}
    #####:13833:		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        -:13834:		}
        -:13835:
        1:13836:	return yy_current_state;
        -:13837:	}
        -:13838:
        -:13839:
        -:13840:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -:13841: *
        -:13842: * synopsis
        -:13843: *	next_state = yy_try_NUL_trans( current_state );
        -:13844: */
        -:13845:
        -:13846:#ifdef YY_USE_PROTOS
    #####:13847:static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
        -:13848:#else
        -:13849:static yy_state_type yy_try_NUL_trans( yy_current_state )
        -:13850:yy_state_type yy_current_state;
        -:13851:#endif
        -:13852:	{
        -:13853:	register int yy_is_jam;
    #####:13854:	register char *yy_cp = yy_c_buf_p;
        -:13855:
    #####:13856:	register YY_CHAR yy_c = 1;
    #####:13857:	if ( yy_accept[yy_current_state] )
        -:13858:		{
    #####:13859:		yy_last_accepting_state = yy_current_state;
    #####:13860:		yy_last_accepting_cpos = yy_cp;
        -:13861:		}
    #####:13862:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:13863:		{
    #####:13864:		yy_current_state = (int) yy_def[yy_current_state];
    #####:13865:		if ( yy_current_state >= 769 )
    #####:13866:			yy_c = yy_meta[(unsigned int) yy_c];
        -:13867:		}
    #####:13868:	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    #####:13869:	yy_is_jam = (yy_current_state == 768);
        -:13870:
    #####:13871:	return yy_is_jam ? 0 : yy_current_state;
        -:13872:	}
        -:13873:
        -:13874:
        -:13875:#ifndef YY_NO_UNPUT
        -:13876:#ifdef YY_USE_PROTOS
    #####:13877:static void yyunput( int c, register char *yy_bp )
        -:13878:#else
        -:13879:static void yyunput( c, yy_bp )
        -:13880:int c;
        -:13881:register char *yy_bp;
        -:13882:#endif
        -:13883:	{
    #####:13884:	register char *yy_cp = yy_c_buf_p;
        -:13885:
        -:13886:	/* undo effects of setting up yytext */
    #####:13887:	*yy_cp = yy_hold_char;
        -:13888:
    #####:13889:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        -:13890:		{ /* need to shift things up to make room */
        -:13891:		/* +2 for EOB chars. */
    #####:13892:		register int number_to_move = yy_n_chars + 2;
    #####:13893:		register char *dest = &yy_current_buffer->yy_ch_buf[
    #####:13894:					yy_current_buffer->yy_buf_size + 2];
    #####:13895:		register char *source =
    #####:13896:				&yy_current_buffer->yy_ch_buf[number_to_move];
        -:13897:
    #####:13898:		while ( source > yy_current_buffer->yy_ch_buf )
    #####:13899:			*--dest = *--source;
        -:13900:
    #####:13901:		yy_cp += (int) (dest - source);
    #####:13902:		yy_bp += (int) (dest - source);
    #####:13903:		yy_n_chars = yy_current_buffer->yy_buf_size;
        -:13904:
    #####:13905:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
    #####:13906:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
        -:13907:		}
        -:13908:
    #####:13909:	*--yy_cp = (char) c;
        -:13910:
        -:13911:
    #####:13912:	yytext_ptr = yy_bp;
    #####:13913:	yy_hold_char = *yy_cp;
    #####:13914:	yy_c_buf_p = yy_cp;
    #####:13915:	}
        -:13916:#endif	/* ifndef YY_NO_UNPUT */
        -:13917:
        -:13918:
        -:13919:#ifdef __cplusplus
        -:13920:static int yyinput()
        -:13921:#else
    #####:13922:static int input()
        -:13923:#endif
        -:13924:	{
        -:13925:	int c;
        -:13926:
    #####:13927:	*yy_c_buf_p = yy_hold_char;
        -:13928:
    #####:13929:	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        -:13930:		{
        -:13931:		/* yy_c_buf_p now points to the character we want to return.
        -:13932:		 * If this occurs *before* the EOB characters, then it's a
        -:13933:		 * valid NUL; if not, then we've hit the end of the buffer.
        -:13934:		 */
    #####:13935:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
        -:13936:			/* This was really a NUL. */
    #####:13937:			*yy_c_buf_p = '\0';
        -:13938:
        -:13939:		else
        -:13940:			{ /* need more input */
    #####:13941:			int offset = yy_c_buf_p - yytext_ptr;
    #####:13942:			++yy_c_buf_p;
        -:13943:
    #####:13944:			switch ( yy_get_next_buffer() )
        -:13945:				{
        -:13946:				case EOB_ACT_END_OF_FILE:
        -:13947:					{
    #####:13948:					if ( yywrap() )
        -:13949:						{
    #####:13950:						yy_c_buf_p = yytext_ptr + offset;
    #####:13951:                                                return EOF;
        -:13952:						}
        -:13953:
    #####:13954:					if ( ! yy_did_buffer_switch_on_eof )
    #####:13955:						YY_NEW_FILE;
        -:13956:#ifdef __cplusplus
        -:13957:					return yyinput();
        -:13958:#else
    #####:13959:					return input();
        -:13960:#endif
        -:13961:					}
        -:13962:
        -:13963:				case EOB_ACT_CONTINUE_SCAN:
    #####:13964:					yy_c_buf_p = yytext_ptr + offset;
    #####:13965:					break;
        -:13966:
        -:13967:				case EOB_ACT_LAST_MATCH:
        -:13968:#ifdef __cplusplus
        -:13969:					YY_FATAL_ERROR(
        -:13970:					"unexpected last match in yyinput()" );
        -:13971:#else
    #####:13972:					YY_FATAL_ERROR(
        -:13973:					"unexpected last match in input()" );
        -:13974:#endif
        -:13975:				}
        -:13976:			}
        -:13977:		}
        -:13978:
    #####:13979:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
    #####:13980:	*yy_c_buf_p = '\0';	/* preserve yytext */
    #####:13981:	yy_hold_char = *++yy_c_buf_p;
        -:13982:
    #####:13983:	yy_current_buffer->yy_at_bol = (c == '\n');
        -:13984:
    #####:13985:	return c;
        -:13986:	}
        -:13987:
        -:13988:
        -:13989:#ifdef YY_USE_PROTOS
        1:13990:void yyrestart( FILE *input_file )
        -:13991:#else
        -:13992:void yyrestart( input_file )
        -:13993:FILE *input_file;
        -:13994:#endif
        -:13995:	{
        1:13996:	if ( ! yy_current_buffer )
    #####:13997:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
        -:13998:
        1:13999:	yy_init_buffer( yy_current_buffer, input_file );
        1:14000:	yy_load_buffer_state();
        1:14001:	}
        -:14002:
        -:14003:
        -:14004:#ifdef YY_USE_PROTOS
    #####:14005:void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        -:14006:#else
        -:14007:void yy_switch_to_buffer( new_buffer )
        -:14008:YY_BUFFER_STATE new_buffer;
        -:14009:#endif
        -:14010:	{
    #####:14011:	if ( yy_current_buffer == new_buffer )
    #####:14012:		return;
        -:14013:
    #####:14014:	if ( yy_current_buffer )
        -:14015:		{
        -:14016:		/* Flush out information for old buffer. */
    #####:14017:		*yy_c_buf_p = yy_hold_char;
    #####:14018:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
    #####:14019:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:14020:		}
        -:14021:
    #####:14022:	yy_current_buffer = new_buffer;
    #####:14023:	yy_load_buffer_state();
        -:14024:
        -:14025:	/* We don't actually know whether we did this switch during
        -:14026:	 * EOF (yywrap()) processing, but the only time this flag
        -:14027:	 * is looked at is after yywrap() is called, so it's safe
        -:14028:	 * to go ahead and always set it.
        -:14029:	 */
    #####:14030:	yy_did_buffer_switch_on_eof = 1;
        -:14031:	}
        -:14032:
        -:14033:
        -:14034:#ifdef YY_USE_PROTOS
        3:14035:void yy_load_buffer_state( void )
        -:14036:#else
        -:14037:void yy_load_buffer_state()
        -:14038:#endif
        -:14039:	{
        3:14040:	yy_n_chars = yy_current_buffer->yy_n_chars;
        3:14041:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        3:14042:	yyin = yy_current_buffer->yy_input_file;
        3:14043:	yy_hold_char = *yy_c_buf_p;
        3:14044:	}
        -:14045:
        -:14046:
        -:14047:#ifdef YY_USE_PROTOS
        1:14048:YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
        -:14049:#else
        -:14050:YY_BUFFER_STATE yy_create_buffer( file, size )
        -:14051:FILE *file;
        -:14052:int size;
        -:14053:#endif
        -:14054:	{
        -:14055:	YY_BUFFER_STATE b;
        -:14056:
        1:14057:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        1:14058:	if ( ! b )
    #####:14059:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -:14060:
        1:14061:	b->yy_buf_size = size;
        -:14062:
        -:14063:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -:14064:	 * we need to put in 2 end-of-buffer characters.
        -:14065:	 */
        1:14066:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
        1:14067:	if ( ! b->yy_ch_buf )
    #####:14068:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -:14069:
        1:14070:	b->yy_is_our_buffer = 1;
        -:14071:
        1:14072:	yy_init_buffer( b, file );
        -:14073:
        1:14074:	return b;
        -:14075:	}
        -:14076:
        -:14077:
        -:14078:#ifdef YY_USE_PROTOS
    #####:14079:void yy_delete_buffer( YY_BUFFER_STATE b )
        -:14080:#else
        -:14081:void yy_delete_buffer( b )
        -:14082:YY_BUFFER_STATE b;
        -:14083:#endif
        -:14084:	{
    #####:14085:	if ( ! b )
    #####:14086:		return;
        -:14087:
    #####:14088:	if ( b == yy_current_buffer )
    #####:14089:		yy_current_buffer = (YY_BUFFER_STATE) 0;
        -:14090:
    #####:14091:	if ( b->yy_is_our_buffer )
    #####:14092:		yy_flex_free( (void *) b->yy_ch_buf );
        -:14093:
    #####:14094:	yy_flex_free( (void *) b );
        -:14095:	}
        -:14096:
        -:14097:
        -:14098:#ifndef YY_ALWAYS_INTERACTIVE
        -:14099:#ifndef YY_NEVER_INTERACTIVE
        -:14100:extern int isatty YY_PROTO(( int ));
        -:14101:#endif
        -:14102:#endif
        -:14103:
        -:14104:#ifdef YY_USE_PROTOS
        2:14105:void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
        -:14106:#else
        -:14107:void yy_init_buffer( b, file )
        -:14108:YY_BUFFER_STATE b;
        -:14109:FILE *file;
        -:14110:#endif
        -:14111:
        -:14112:
        -:14113:	{
        2:14114:	yy_flush_buffer( b );
        -:14115:
        2:14116:	b->yy_input_file = file;
        2:14117:	b->yy_fill_buffer = 1;
        -:14118:
        -:14119:#if YY_ALWAYS_INTERACTIVE
        -:14120:	b->yy_is_interactive = 1;
        -:14121:#else
        -:14122:#if YY_NEVER_INTERACTIVE
        -:14123:	b->yy_is_interactive = 0;
        -:14124:#else
        2:14125:	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
        -:14126:#endif
        -:14127:#endif
        2:14128:	}
        -:14129:
        -:14130:
        -:14131:#ifdef YY_USE_PROTOS
        2:14132:void yy_flush_buffer( YY_BUFFER_STATE b )
        -:14133:#else
        -:14134:void yy_flush_buffer( b )
        -:14135:YY_BUFFER_STATE b;
        -:14136:#endif
        -:14137:
        -:14138:	{
        2:14139:	b->yy_n_chars = 0;
        -:14140:
        -:14141:	/* We always need two end-of-buffer characters.  The first causes
        -:14142:	 * a transition to the end-of-buffer state.  The second causes
        -:14143:	 * a jam in that state.
        -:14144:	 */
        2:14145:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        2:14146:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        -:14147:
        2:14148:	b->yy_buf_pos = &b->yy_ch_buf[0];
        -:14149:
        2:14150:	b->yy_at_bol = 1;
        2:14151:	b->yy_buffer_status = YY_BUFFER_NEW;
        -:14152:
        2:14153:	if ( b == yy_current_buffer )
        1:14154:		yy_load_buffer_state();
        2:14155:	}
        -:14156:
        -:14157:
        -:14158:#ifndef YY_NO_SCAN_BUFFER
        -:14159:#ifdef YY_USE_PROTOS
    #####:14160:YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
        -:14161:#else
        -:14162:YY_BUFFER_STATE yy_scan_buffer( base, size )
        -:14163:char *base;
        -:14164:yy_size_t size;
        -:14165:#endif
        -:14166:	{
        -:14167:	YY_BUFFER_STATE b;
        -:14168:
    #####:14169:	if ( size < 2 ||
    #####:14170:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
    #####:14171:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
        -:14172:		/* They forgot to leave room for the EOB's. */
    #####:14173:		return 0;
        -:14174:
    #####:14175:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    #####:14176:	if ( ! b )
    #####:14177:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
        -:14178:
    #####:14179:	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
    #####:14180:	b->yy_buf_pos = b->yy_ch_buf = base;
    #####:14181:	b->yy_is_our_buffer = 0;
    #####:14182:	b->yy_input_file = 0;
    #####:14183:	b->yy_n_chars = b->yy_buf_size;
    #####:14184:	b->yy_is_interactive = 0;
    #####:14185:	b->yy_at_bol = 1;
    #####:14186:	b->yy_fill_buffer = 0;
    #####:14187:	b->yy_buffer_status = YY_BUFFER_NEW;
        -:14188:
    #####:14189:	yy_switch_to_buffer( b );
        -:14190:
    #####:14191:	return b;
        -:14192:	}
        -:14193:#endif
        -:14194:
        -:14195:
        -:14196:#ifndef YY_NO_SCAN_STRING
        -:14197:#ifdef YY_USE_PROTOS
    #####:14198:YY_BUFFER_STATE yy_scan_string( yyconst char *str )
        -:14199:#else
        -:14200:YY_BUFFER_STATE yy_scan_string( str )
        -:14201:yyconst char *str;
        -:14202:#endif
        -:14203:	{
        -:14204:	int len;
    #####:14205:	for ( len = 0; str[len]; ++len )
        -:14206:		;
        -:14207:
    #####:14208:	return yy_scan_bytes( str, len );
        -:14209:	}
        -:14210:#endif
        -:14211:
        -:14212:
        -:14213:#ifndef YY_NO_SCAN_BYTES
        -:14214:#ifdef YY_USE_PROTOS
    #####:14215:YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
        -:14216:#else
        -:14217:YY_BUFFER_STATE yy_scan_bytes( bytes, len )
        -:14218:yyconst char *bytes;
        -:14219:int len;
        -:14220:#endif
        -:14221:	{
        -:14222:	YY_BUFFER_STATE b;
        -:14223:	char *buf;
        -:14224:	yy_size_t n;
        -:14225:	int i;
        -:14226:
        -:14227:	/* Get memory for full buffer, including space for trailing EOB's. */
    #####:14228:	n = len + 2;
    #####:14229:	buf = (char *) yy_flex_alloc( n );
    #####:14230:	if ( ! buf )
    #####:14231:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
        -:14232:
    #####:14233:	for ( i = 0; i < len; ++i )
    #####:14234:		buf[i] = bytes[i];
        -:14235:
    #####:14236:	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
        -:14237:
    #####:14238:	b = yy_scan_buffer( buf, n );
    #####:14239:	if ( ! b )
    #####:14240:		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        -:14241:
        -:14242:	/* It's okay to grow etc. this buffer, and we should throw it
        -:14243:	 * away when we're done.
        -:14244:	 */
    #####:14245:	b->yy_is_our_buffer = 1;
        -:14246:
    #####:14247:	return b;
        -:14248:	}
        -:14249:#endif
        -:14250:
        -:14251:
        -:14252:#ifndef YY_NO_PUSH_STATE
        -:14253:#ifdef YY_USE_PROTOS
    #####:14254:static void yy_push_state( int new_state )
        -:14255:#else
        -:14256:static void yy_push_state( new_state )
        -:14257:int new_state;
        -:14258:#endif
        -:14259:	{
    #####:14260:	if ( yy_start_stack_ptr >= yy_start_stack_depth )
        -:14261:		{
        -:14262:		yy_size_t new_size;
        -:14263:
    #####:14264:		yy_start_stack_depth += YY_START_STACK_INCR;
    #####:14265:		new_size = yy_start_stack_depth * sizeof( int );
        -:14266:
    #####:14267:		if ( ! yy_start_stack )
    #####:14268:			yy_start_stack = (int *) yy_flex_alloc( new_size );
        -:14269:
        -:14270:		else
    #####:14271:			yy_start_stack = (int *) yy_flex_realloc(
        -:14272:					(void *) yy_start_stack, new_size );
        -:14273:
    #####:14274:		if ( ! yy_start_stack )
    #####:14275:			YY_FATAL_ERROR(
        -:14276:			"out of memory expanding start-condition stack" );
        -:14277:		}
        -:14278:
    #####:14279:	yy_start_stack[yy_start_stack_ptr++] = YY_START;
        -:14280:
    #####:14281:	BEGIN(new_state);
    #####:14282:	}
        -:14283:#endif
        -:14284:
        -:14285:
        -:14286:#ifndef YY_NO_POP_STATE
    #####:14287:static void yy_pop_state()
        -:14288:	{
    #####:14289:	if ( --yy_start_stack_ptr < 0 )
    #####:14290:		YY_FATAL_ERROR( "start-condition stack underflow" );
        -:14291:
    #####:14292:	BEGIN(yy_start_stack[yy_start_stack_ptr]);
    #####:14293:	}
        -:14294:#endif
        -:14295:
        -:14296:
        -:14297:#ifndef YY_NO_TOP_STATE
        -:14298:static int yy_top_state()
        -:14299:	{
        -:14300:	return yy_start_stack[yy_start_stack_ptr - 1];
        -:14301:	}
        -:14302:#endif
        -:14303:
        -:14304:#ifndef YY_EXIT_FAILURE
        -:14305:#define YY_EXIT_FAILURE 2
        -:14306:#endif
        -:14307:
        -:14308:#ifdef YY_USE_PROTOS
    #####:14309:static void yy_fatal_error( yyconst char msg[] )
        -:14310:#else
        -:14311:static void yy_fatal_error( msg )
        -:14312:char msg[];
        -:14313:#endif
        -:14314:	{
    #####:14315:	(void) fprintf( err, "%s\n", msg );
    #####:14316:	exit( YY_EXIT_FAILURE );
        -:14317:	}
        -:14318:
        -:14319:
        -:14320:
        -:14321:/* Redefine yyless() so it works in section 3 code. */
        -:14322:
        -:14323:#undef yyless
        -:14324:#define yyless(n) \
        -:14325:	do \
        -:14326:		{ \
        -:14327:		/* Undo effects of setting up yytext. */ \
        -:14328:		yytext[yyleng] = yy_hold_char; \
        -:14329:		yy_c_buf_p = yytext + n; \
        -:14330:		yy_hold_char = *yy_c_buf_p; \
        -:14331:		*yy_c_buf_p = '\0'; \
        -:14332:		yyleng = n; \
        -:14333:		} \
        -:14334:	while ( 0 )
        -:14335:
        -:14336:
        -:14337:/* Internal utility routines. */
        -:14338:
        -:14339:#ifndef yytext_ptr
        -:14340:#ifdef YY_USE_PROTOS
        -:14341:static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
        -:14342:#else
        -:14343:static void yy_flex_strncpy( s1, s2, n )
        -:14344:char *s1;
        -:14345:yyconst char *s2;
        -:14346:int n;
        -:14347:#endif
        -:14348:	{
        -:14349:	register int i;
        -:14350:	for ( i = 0; i < n; ++i )
        -:14351:		s1[i] = s2[i];
        -:14352:	}
        -:14353:#endif
        -:14354:
        -:14355:#ifdef YY_NEED_STRLEN
        -:14356:#ifdef YY_USE_PROTOS
        -:14357:static int yy_flex_strlen( yyconst char *s )
        -:14358:#else
        -:14359:static int yy_flex_strlen( s )
        -:14360:yyconst char *s;
        -:14361:#endif
        -:14362:	{
        -:14363:	register int n;
        -:14364:	for ( n = 0; s[n]; ++n )
        -:14365:		;
        -:14366:
        -:14367:	return n;
        -:14368:	}
        -:14369:#endif
        -:14370:
        -:14371:
        -:14372:#ifdef YY_USE_PROTOS
        2:14373:static void *yy_flex_alloc( yy_size_t size )
        -:14374:#else
        -:14375:static void *yy_flex_alloc( size )
        -:14376:yy_size_t size;
        -:14377:#endif
        -:14378:	{
        2:14379:	return (void *) malloc( size );
        -:14380:	}
        -:14381:
        -:14382:#ifdef YY_USE_PROTOS
    #####:14383:static void *yy_flex_realloc( void *ptr, yy_size_t size )
        -:14384:#else
        -:14385:static void *yy_flex_realloc( ptr, size )
        -:14386:void *ptr;
        -:14387:yy_size_t size;
        -:14388:#endif
        -:14389:	{
        -:14390:	/* The cast to (char *) in the following accommodates both
        -:14391:	 * implementations that use char* generic pointers, and those
        -:14392:	 * that use void* generic pointers.  It works with the latter
        -:14393:	 * because both ANSI C and C++ allow castless assignment from
        -:14394:	 * any pointer type to void*, and deal with argument conversions
        -:14395:	 * as though doing an assignment.
        -:14396:	 */
    #####:14397:	return (void *) realloc( (char *) ptr, size );
        -:14398:	}
        -:14399:
        -:14400:#ifdef YY_USE_PROTOS
    #####:14401:static void yy_flex_free( void *ptr )
        -:14402:#else
        -:14403:static void yy_flex_free( ptr )
        -:14404:void *ptr;
        -:14405:#endif
        -:14406:	{
    #####:14407:	free( ptr );
    #####:14408:	}
        -:14409:
        -:14410:#if YY_MAIN
        -:14411:int main()
        -:14412:	{
        -:14413:	yylex();
        -:14414:	return 0;
        -:14415:	}
        -:14416:#endif
        -:14417:
        -:14418:
        -:14419:
        1:14420:int yywrap()
        -:14421:	{
        1:14422:	if ( --num_input_files > 0 )
        -:14423:		{
    #####:14424:		set_input_file( *++input_files );
    #####:14425:		return 0;
        -:14426:		}
        -:14427:
        -:14428:	else
        1:14429:		return 1;
        -:14430:	}
        -:14431:
        -:14432:
        -:14433:/* set_input_file - open the given file (if NULL, stdin) for scanning */
        -:14434:
        1:14435:void set_input_file( file )
        -:14436:char *file;
        -:14437:	{
        1:14438:	if ( file && strcmp( file, "-" ) )
        -:14439:		{
        1:14440:		infilename = copy_string( file );
        1:14441:		yyin = fopen( infilename, "r" );
        -:14442:
        2:14443:		if ( yyin == NULL )
    #####:14444:			lerrsf( _( "can't open %s" ), file );
        -:14445:		}
        -:14446:
        -:14447:	else
        -:14448:		{
    #####:14449:		yyin = stdin;
    #####:14450:		infilename = copy_string( "<stdin>" );
        -:14451:		}
        -:14452:
        1:14453:	linenum = 1;
        1:14454:	}
        -:14455:
        -:14456:
        -:14457:/* Wrapper routines for accessing the scanner's malloc routines. */
        -:14458:
       67:14459:void *flex_alloc( size )
        -:14460:size_t size;
        -:14461:	{
       67:14462:	return (void *) malloc( size );
        -:14463:	}
        -:14464:
    #####:14465:void *flex_realloc( ptr, size )
        -:14466:void *ptr;
        -:14467:size_t size;
        -:14468:	{
    #####:14469:	return (void *) realloc( ptr, size );
        -:14470:	}
        -:14471:
        2:14472:void flex_free( ptr )
        -:14473:void *ptr;
        -:14474:	{
        2:14475:	if ( ptr )
        2:14476:		free( ptr );
        2:14477:	}
